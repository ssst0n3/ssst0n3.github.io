{"matrix":[[],[{"ID":74,"CreatedAt":"2023-08-11T06:37:34.5Z","UpdatedAt":"2023-08-30T07:58:23.613Z","DeletedAt":null,"title":"Linux Kernel CAP_CHOWN 源码分析","function_declare":"","git_url":"","note":"","code":"","markdown":"# Linux Kernel CAP_CHOWN 源码分析\n\n* version: v0.1.0\n* author: ssst0n3\n* code-version: v6.4","child":0,"next":75},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":75,"CreatedAt":"2023-08-11T07:11:21.09Z","UpdatedAt":"2023-08-11T07:59:06.661Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"搜索关键字 `CAP_CHOWN` ，源码中有4处用到 `CAP_CHOWN` ","last":74,"child":76,"next":0},{"ID":76,"CreatedAt":"2023-08-11T07:59:51.47Z","UpdatedAt":"2023-08-30T07:34:13.148Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 1. define CAP_CHOWN 0\n\n在众多capability中，CAP_CHOWN 的 编号是0，它用于提供修改文件UID,GID的权限。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/capability.h#L113\n\n```c\n/* In a system with the [_POSIX_CHOWN_RESTRICTED] option defined, this\n   overrides the restriction of changing file ownership and group\n   ownership. */\n\n#define CAP_CHOWN            0\n```\n","parent":75,"child":0,"next":77},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":0,"markdown":""},{"ID":77,"CreatedAt":"2023-08-11T08:00:02.086Z","UpdatedAt":"2023-08-30T07:34:23.659Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 2. chown_ok()\n\n* vfsuid，当前task的cred的 fsuid，inode 将要修改的 vfsuid 相等 (<span style=\"color:red\">这不是等于没有修改吗？</span>)\n* 任务在当前 user namespace 中拥有 CAP_CHOWN，且 vfsuid 在当前 user namespace 中有mapping\n* 如果vfsuid是溢出值，任务在inode 中存储的文件系统 userns 中拥有 CAP_CHOWN\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/attr.c#L98\n\n```c\n/**\n * chown_ok - verify permissions to chown inode\n * @idmap:\tidmap of the mount @inode was found from\n * @inode:\tinode to check permissions on\n * @ia_vfsuid:\tuid to chown @inode to\n *\n * If the inode has been found through an idmapped mount the idmap of\n * the vfsmount must be passed through @idmap. This function will then\n * take care to map the inode according to @idmap before checking\n * permissions. On non-idmapped mounts or if permission checking is to be\n * performed on the raw inode simply pass @nop_mnt_idmap.\n */\nstatic bool chown_ok(struct mnt_idmap *idmap,\n\t\t     const struct inode *inode, vfsuid_t ia_vfsuid)\n{\n    vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n    if (vfsuid_eq_kuid(vfsuid, current_fsuid()) &&\n        vfsuid_eq(ia_vfsuid, vfsuid))\n        return true;\n    if (capable_wrt_inode_uidgid(idmap, inode, CAP_CHOWN))\n        return true;\n    if (!vfsuid_valid(vfsuid) &&\n        ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n        return true;\n    return false;\n}\n```","last":76,"child":123,"next":78},{"ID":123,"CreatedAt":"2023-08-30T07:51:26.074Z","UpdatedAt":"2023-08-30T07:56:35.239Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.0 uid, ns\n\n* vfsuid: inode_kuid -> uid -> mnt_kuid\n* fsuid: task->cred->fsuid\n\n---\n\n* current_userns: task->cred->user_ns\n* fs_userns: inode->i_sb->s_user_ns\n* mnt_userns: mnt_userns = idmap->owner","parent":77,"child":0,"next":119},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":0,"markdown":""},{"ID":78,"CreatedAt":"2023-08-11T08:00:14.772Z","UpdatedAt":"2023-08-30T07:34:31.056Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 3. chgrp_ok()\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/attr.c#L125\n\n```c\n/**\n * chgrp_ok - verify permissions to chgrp inode\n * @idmap:\tidmap of the mount @inode was found from\n * @inode:\tinode to check permissions on\n * @ia_vfsgid:\tgid to chown @inode to\n *\n * If the inode has been found through an idmapped mount the idmap of\n * the vfsmount must be passed through @idmap. This function will then\n * take care to map the inode according to @idmap before checking\n * permissions. On non-idmapped mounts or if permission checking is to be\n * performed on the raw inode simply pass @nop_mnt_idmap.\n */\nstatic bool chgrp_ok(struct mnt_idmap *idmap,\n\t\t     const struct inode *inode, vfsgid_t ia_vfsgid)\n{\n    vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n    vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n    if (vfsuid_eq_kuid(vfsuid, current_fsuid())) {\n        if (vfsgid_eq(ia_vfsgid, vfsgid))\n            return true;\n        if (vfsgid_in_group_p(ia_vfsgid))\n            return true;\n    }\n    if (capable_wrt_inode_uidgid(idmap, inode, CAP_CHOWN))\n        return true;\n    if (!vfsgid_valid(vfsgid) &&\n        ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n        return true;\n    return false;\n}\n```","last":77,"child":0,"next":79},{"ID":119,"CreatedAt":"2023-08-30T07:38:04.992Z","UpdatedAt":"2023-08-30T07:40:29.51Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.1 vfsuid == fsuid == ia_vfsuid\n\n```c\nstatic bool chown_ok(struct mnt_idmap *idmap,\n             const struct inode *inode, vfsuid_t ia_vfsuid)\n{\n    vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n    if (vfsuid_eq_kuid(vfsuid, current_fsuid()) &&\n        vfsuid_eq(ia_vfsuid, vfsuid))\n        return true;\n    ...\n}\n```","last":123,"child":80,"next":120},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":80,"CreatedAt":"2023-08-14T08:38:40.266Z","UpdatedAt":"2023-08-28T08:08:26.584Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将文件系统记录的kuid 映射成mnt_userns 的 kuid，映射的依据是 uid (mnt_userns 和 fs_userns 的uid)\n\n// 我猜测 mnt_userns 中的kuid 才是原始的 kuid，统一都是用它用来比较。\n\n参数说明：\n\n* idmap 中存储了 mnt_userns\n* inode 中存储了 fs_userns\n* inode 中记录的 uid 就是 文件系统中记录的 kuid\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/fs.h#L1325\n\n```c\n/**\n * i_uid_into_vfsuid - map an inode's i_uid down according to an idmapping\n * @idmap: idmap of the mount the inode was found from\n * @inode: inode to map\n *\n * Return: whe inode's i_uid mapped down according to @idmap.\n * If the inode's i_uid has no mapping INVALID_VFSUID is returned.\n */\nstatic inline vfsuid_t i_uid_into_vfsuid(struct mnt_idmap *idmap,\n\t\t\t\t\t const struct inode *inode)\n{\n\treturn make_vfsuid(idmap, i_user_ns(inode), inode->i_uid);\n}\n```","parent":119,"child":97,"next":98},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":97,"CreatedAt":"2023-08-26T09:54:48.243Z","UpdatedAt":"2023-08-26T09:58:57.131Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"读取 inode 中存储的文件系统 userns\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/fs.h#L1287\n\n```c\nstatic inline struct user_namespace *i_user_ns(const struct inode *inode)\n{\n\treturn inode->i_sb->s_user_ns;\n}\n```","parent":80,"child":0,"next":81},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":0,"markdown":""},{"ID":79,"CreatedAt":"2023-08-11T08:00:24.648Z","UpdatedAt":"2023-08-30T07:34:40.009Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 4. ocfs2_vfs_reflink\n\nOracle Cluster File System 2， 似乎默认未加载该模块，略","last":78,"child":0,"next":0},{"ID":120,"CreatedAt":"2023-08-30T07:43:54.538Z","UpdatedAt":"2023-08-30T07:49:55.755Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.2. current_userns capable\n\n```c\nstatic bool chown_ok(struct mnt_idmap *idmap,\n             const struct inode *inode, vfsuid_t ia_vfsuid)\n{\n    ...\n    if (capable_wrt_inode_uidgid(idmap, inode, CAP_CHOWN))\n        return true;\n    ...\n}\n```","last":119,"child":104,"next":122},{"ID":104,"CreatedAt":"2023-08-28T09:12:17.308Z","UpdatedAt":"2023-08-29T09:11:20.245Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"任务在当前 user namespace 中拥有cap，且inode 中记录的kuid 是否在 user namespace 中有mapping\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/kernel/capability.c#L491\n\n```c\n/**\n * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped\n * @inode: The inode in question\n * @cap: The capability in question\n *\n * Return true if the current task has the given capability targeted at\n * its own user namespace and that the given inode's uid and gid are\n * mapped into the current user namespace.\n */\nbool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,\n\t\t\t      const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) &&\n\t       privileged_wrt_inode_uidgid(ns, idmap, inode);\n}\nEXPORT_SYMBOL(capable_wrt_inode_uidgid);\n```","parent":120,"child":105,"next":0},{"ID":105,"CreatedAt":"2023-08-28T09:13:55.357Z","UpdatedAt":"2023-08-28T09:13:55.357Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/include/linux/cred.h#L395\n\n```c\n#ifdef CONFIG_USER_NS\n#define current_user_ns()\t(current_cred_xxx(user_ns))\n#else\nstatic inline struct user_namespace *current_user_ns(void)\n{\n\treturn &init_user_ns;\n}\n#endif\n```","parent":104,"child":0,"next":106},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":98,"CreatedAt":"2023-08-28T08:23:17.803Z","UpdatedAt":"2023-08-28T08:23:47.975Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`current_fsuid()` 返回fsuid\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/cred.h#L387\n\n```c\n#define current_cred_xxx(xxx)\t\t\t\\\n({\t\t\t\t\t\t\\\n\tcurrent_cred()->xxx;\t\t\t\\\n})\n...\n#define current_fsuid() \t(current_cred_xxx(fsuid))\n```","last":80,"child":99,"next":103},{"ID":99,"CreatedAt":"2023-08-28T08:25:26.738Z","UpdatedAt":"2023-08-28T08:25:50.017Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/include/linux/cred.h#L298\n\n```c\n/**\n * current_cred - Access the current task's subjective credentials\n *\n * Access the subjective credentials of the current task.  RCU-safe,\n * since nobody else can modify it.\n */\n#define current_cred() \\\n\trcu_dereference_protected(current->cred, 1)\n```","parent":98,"child":100,"next":102},{"ID":100,"CreatedAt":"2023-08-28T08:36:29.568Z","UpdatedAt":"2023-08-28T08:36:29.568Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"current 返回当前task结构体。\n\n不同架构实现不同，以 x86 为例:\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/arch/x86/include/asm/current.h#L39-L44\n\n```c\nstatic __always_inline struct task_struct *get_current(void)\n{\n\treturn this_cpu_read_stable(pcpu_hot.current_task);\n}\n\n#define current get_current()\n```","parent":99,"child":0,"next":0},{"ID":81,"CreatedAt":"2023-08-25T03:49:19.454Z","UpdatedAt":"2023-08-26T09:04:49.052Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"从 fs_userns 的 idmapping 中，将kuid映射为uid，再从 mnt_userns 的 idmapping 中映射回 kuid。\n\n* 如果不需要映射，直接返回 kuid。\n* 如果 fs_userns 是 init_userns , 从kuid到uid的映射很简单，uid就是kuid, 就不用调用 from_kuid() 函数了。\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/fs/mnt_idmapping.c#L96\n\n```c\n/**\n * make_vfsuid - map a filesystem kuid according to an idmapping\n * @idmap: the mount's idmapping\n * @fs_userns: the filesystem's idmapping\n * @kuid : kuid to be mapped\n *\n * Take a @kuid and remap it from @fs_userns into @idmap. Use this\n * function when preparing a @kuid to be reported to userspace.\n *\n * If no_idmapping() determines that this is not an idmapped mount we can\n * simply return @kuid unchanged.\n * If initial_idmapping() tells us that the filesystem is not mounted with an\n * idmapping we know the value of @kuid won't change when calling\n * from_kuid() so we can simply retrieve the value via __kuid_val()\n * directly.\n *\n * Return: @kuid mapped according to @idmap.\n * If @kuid has no mapping in either @idmap or @fs_userns INVALID_UID is\n * returned.\n */\n\nvfsuid_t make_vfsuid(struct mnt_idmap *idmap,\n\t\t\t\t   struct user_namespace *fs_userns,\n\t\t\t\t   kuid_t kuid)\n{\n\tuid_t uid;\n\tstruct user_namespace *mnt_userns = idmap->owner;\n\n\tif (no_idmapping(mnt_userns, fs_userns))\n\t\treturn VFSUIDT_INIT(kuid);\n\tif (initial_idmapping(fs_userns))\n\t\tuid = __kuid_val(kuid);\n\telse\n\t\tuid = from_kuid(fs_userns, kuid);\n\tif (uid == (uid_t)-1)\n\t\treturn INVALID_VFSUID;\n\treturn VFSUIDT_INIT(make_kuid(mnt_userns, uid));\n}\n```","last":97,"child":89,"next":0},{"ID":89,"CreatedAt":"2023-08-26T04:06:15.586Z","UpdatedAt":"2023-08-26T09:17:33.392Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"如果 mnt_userns 是 init_userns, 或 mnt_userns 和 fs_userns 相同，则不需要 remapping 。\n\n如果 mnt_userns 是 init_userns ，fs_userns 也是 init_userns。\n\n> If a filesystem were to be mounted in the initial user namespaces (as most filesystems are) then the initial idmapping will be used. \n> https://docs.kernel.org/filesystems/idmappings.html\n\n如果 mnt_userns 和 fs_userns 相同，则 idmapping 也相同，则无必要将 kuid 映射为 uid, 再映射会 kuid， 因为两个映射是相同的。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/mnt_idmapping.c#L55-L73\n\n```c\n/**\n * no_idmapping - check whether we can skip remapping a kuid/gid\n * @mnt_userns: the mount's idmapping\n * @fs_userns: the filesystem's idmapping\n *\n * This function can be used to check whether a remapping between two\n * idmappings is required.\n * An idmapped mount is a mount that has an idmapping attached to it that\n * is different from the filsystem's idmapping and the initial idmapping.\n * If the initial mapping is used or the idmapping of the mount and the\n * filesystem are identical no remapping is required.\n *\n * Return: true if remapping can be skipped, false if not.\n */\nstatic inline bool no_idmapping(const struct user_namespace *mnt_userns,\n\t\t\t\tconst struct user_namespace *fs_userns)\n{\n\treturn initial_idmapping(mnt_userns) || mnt_userns == fs_userns;\n}\n```","parent":81,"child":90,"next":96},{"ID":90,"CreatedAt":"2023-08-26T06:39:14.792Z","UpdatedAt":"2023-08-26T06:39:14.792Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/mnt_idmapping.c#L41-L53\n\n```c\n/**\n * initial_idmapping - check whether this is the initial mapping\n * @ns: idmapping to check\n *\n * Check whether this is the initial mapping, mapping 0 to 0, 1 to 1,\n * [...], 1000 to 1000 [...].\n *\n * Return: true if this is the initial mapping, false if not.\n */\nstatic inline bool initial_idmapping(const struct user_namespace *ns)\n{\n\treturn ns == &init_user_ns;\n}\n```","parent":89,"child":0,"next":0},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":122,"CreatedAt":"2023-08-30T07:48:45.777Z","UpdatedAt":"2023-08-30T07:48:45.777Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.3 fs_userns capable\n\n```c\nstatic bool chown_ok(struct mnt_idmap *idmap,\n             const struct inode *inode, vfsuid_t ia_vfsuid)\n{\n    vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n    ...\n    if (!vfsuid_valid(vfsuid) &&\n        ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n        return true;\n    ...\n}\n```","last":120,"child":121,"next":0},{"ID":121,"CreatedAt":"2023-08-30T07:47:20.452Z","UpdatedAt":"2023-08-30T07:47:40.181Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"vfsuid 不等于溢出值，即vfsuid有效\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/mnt_idmapping.h#L49\n\n```c\nstatic inline bool vfsuid_valid(vfsuid_t uid)\n{\n\treturn __vfsuid_val(uid) != (uid_t)-1;\n}\n```","parent":122,"child":0,"next":0},{"ID":106,"CreatedAt":"2023-08-28T09:16:20.087Z","UpdatedAt":"2023-08-30T07:50:13.991Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"#### * ns_capable\n\n判断 user namespace 中，是否有 cap\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/kernel/capability.c#L351-L385\n\n```c\nstatic bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#ifdef CONFIG_MULTIUSER\n...\n/**\n * ns_capable - Determine if the current task has a superior capability in effect\n * @ns:  The usernamespace we want the capability in\n * @cap: The capability to be tested for\n *\n * Return true if the current task has the given superior capability currently\n * available for use, false if not.\n *\n * This sets PF_SUPERPRIV on the task if the capability is available on the\n * assumption that it's about to be used.\n */\nbool ns_capable(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);\n}\nEXPORT_SYMBOL(ns_capable);\n...\n#endif /* CONFIG_MULTIUSER */\n```","last":105,"child":107,"next":112},{"ID":107,"CreatedAt":"2023-08-28T09:25:02.643Z","UpdatedAt":"2023-08-28T09:25:02.643Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/include/linux/security.h#L573\n\n```c\nstatic inline int security_capable(const struct cred *cred,\n\t\t\t\t   struct user_namespace *ns,\n\t\t\t\t   int cap,\n\t\t\t\t   unsigned int opts)\n{\n\treturn cap_capable(cred, ns, cap, opts);\n}\n```","parent":106,"child":108,"next":0},{"ID":108,"CreatedAt":"2023-08-28T09:29:22.509Z","UpdatedAt":"2023-08-29T08:35:43.076Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"* 如果任务当前的userns 就是目标 ns(在本条执行链路中，判断的就是当前userns中是否存在cap，因此是成立的)\n  * cap_effective 中存在相应cap的bit为1， 和 1<<cap 进行与运算，确定是否有cap。 \n* 如果目标ns->level <= 当前ns->level, 则不必再向上搜索目标ns的父ns\n* 如果当前ns是目标ns的父ns，则目标ns的拥有者拥有全部caps\n* 向上搜索目标ns的父ns\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/security/commoncap.c#L66\n\n```c\n/**\n * cap_capable - Determine whether a task has a particular effective capability\n * @cred: The credentials to use\n * @targ_ns:  The user namespace in which we need the capability\n * @cap: The capability to check for\n * @opts: Bitmask of options defined in include/linux/security.h\n *\n * Determine whether the nominated task has the specified capability amongst\n * its effective set, returning 0 if it does, -ve if it does not.\n *\n * NOTE WELL: cap_has_capability() cannot be used like the kernel's capable()\n * and has_capability() functions.  That is, it has the reverse semantics:\n * cap_has_capability() returns 0 when a task has a capability, but the\n * kernel's capable() and has_capability() returns 1 for this case.\n */\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, unsigned int opts)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}\n```","parent":107,"child":111,"next":0},{"ID":111,"CreatedAt":"2023-08-29T07:50:55.928Z","UpdatedAt":"2023-08-29T07:50:55.928Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"cred结构体中记录的caps，每个存在的cap对应的bit为1\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/capability.h#L64\n\n```c\n#define CAP_VALID_MASK\t (BIT_ULL(CAP_LAST_CAP+1)-1)\n```","parent":108,"child":0,"next":109},{"ID":103,"CreatedAt":"2023-08-28T08:53:33.057Z","UpdatedAt":"2023-08-28T08:53:33.057Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"比较 uid 是否相等\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/mnt_idmapping.h#L79\n\n```c\n/**\n * vfsuid_eq_kuid - check whether kuid and vfsuid have the same value\n * @vfsuid: the vfsuid to compare\n * @kuid: the kuid to compare\n *\n * Check whether @vfsuid and @kuid have the same values.\n *\n * Return: true if @vfsuid and @kuid have the same value, false if not.\n * Comparison between two invalid uids returns false.\n */\nstatic inline bool vfsuid_eq_kuid(vfsuid_t vfsuid, kuid_t kuid)\n{\n\treturn vfsuid_valid(vfsuid) && __vfsuid_val(vfsuid) == __kuid_val(kuid);\n}\n```\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/mnt_idmapping.h#L59\n\n```c\nstatic inline bool vfsuid_eq(vfsuid_t left, vfsuid_t right)\n{\n\treturn vfsuid_valid(left) && __vfsuid_val(left) == __vfsuid_val(right);\n}\n```","last":98,"child":0,"next":0},{"ID":102,"CreatedAt":"2023-08-28T08:45:57.951Z","UpdatedAt":"2023-08-28T08:45:57.951Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"cred 结构体中记录了各种uid，包括fsuid。\n\nfsuid 和 euid 可能是不同的。\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/cred.h#L125\n\n```c\n/*\n * The security context of a task\n *\n * The parts of the context break down into two categories:\n *\n *  (1) The objective context of a task.  These parts are used when some other\n *\ttask is attempting to affect this one.\n *\n *  (2) The subjective context.  These details are used when the task is acting\n *\tupon another object, be that a file, a task, a key or whatever.\n *\n * Note that some members of this structure belong to both categories - the\n * LSM security pointer for instance.\n *\n * A task has two security pointers.  task->real_cred points to the objective\n * context that defines that task's actual details.  The objective part of this\n * context is used whenever that task is acted upon.\n *\n * task->cred points to the subjective context that defines the details of how\n * that task is going to act upon another object.  This may be overridden\n * temporarily to point to another security context, but normally points to the\n * same context as task->real_cred.\n */\nstruct cred {\n\t...\n\tkuid_t\t\tuid;\t\t/* real UID of the task */\n\tkgid_t\t\tgid;\t\t/* real GID of the task */\n\tkuid_t\t\tsuid;\t\t/* saved UID of the task */\n\tkgid_t\t\tsgid;\t\t/* saved GID of the task */\n\tkuid_t\t\teuid;\t\t/* effective UID of the task */\n\tkgid_t\t\tegid;\t\t/* effective GID of the task */\n\tkuid_t\t\tfsuid;\t\t/* UID for VFS ops */\n\tkgid_t\t\tfsgid;\t\t/* GID for VFS ops */\n\t...\n} __randomize_layout;\n```","last":99,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":96,"CreatedAt":"2023-08-26T08:43:38.803Z","UpdatedAt":"2023-08-26T08:46:21.394Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/include/linux/mnt_idmapping.h#L103\n\n```c\n/*\n * vfs{g,u}ids are created from k{g,u}ids.\n * We don't allow them to be created from regular {u,g}id.\n */\n#define VFSUIDT_INIT(val) (vfsuid_t){ __kuid_val(val) }\n```\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/uidgid.h#L34\n\n```c\n#ifdef CONFIG_MULTIUSER\nstatic inline uid_t __kuid_val(kuid_t uid)\n{\n\treturn uid.val;\n}\n\nstatic inline gid_t __kgid_val(kgid_t gid)\n{\n\treturn gid.val;\n}\n#else\nstatic inline uid_t __kuid_val(kuid_t uid)\n{\n\treturn 0;\n}\n\nstatic inline gid_t __kgid_val(kgid_t gid)\n{\n\treturn 0;\n}\n#endif\n```","last":89,"child":0,"next":82},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":112,"CreatedAt":"2023-08-29T08:41:04.822Z","UpdatedAt":"2023-08-29T09:26:04.166Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"判断 vfsuid 是否在当前 user namespace 中有mapping\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/kernel/capability.c#L474\n\n```c\n/**\n * privileged_wrt_inode_uidgid - Do capabilities in the namespace work over the inode?\n * @ns: The user namespace in question\n * @inode: The inode in question\n *\n * Return true if the inode uid and gid are within the namespace.\n */\nbool privileged_wrt_inode_uidgid(struct user_namespace *ns,\n\t\t\t\t struct mnt_idmap *idmap,\n\t\t\t\t const struct inode *inode)\n{\n\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&\n\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));\n}\n```","last":106,"child":115,"next":0},{"ID":115,"CreatedAt":"2023-08-29T08:52:47.5Z","UpdatedAt":"2023-08-29T08:57:58.56Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`i_uid_into_vfsuid()`上文分析过，是将文件系统记录的kuid 映射成mnt_userns 的 kuid，映射的依据是 uid (mnt_userns 和 fs_userns 的uid)\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/fs.h#L1325\n\n```c\n/**\n * i_uid_into_vfsuid - map an inode's i_uid down according to an idmapping\n * @idmap: idmap of the mount the inode was found from\n * @inode: inode to map\n *\n * Return: whe inode's i_uid mapped down according to @idmap.\n * If the inode's i_uid has no mapping INVALID_VFSUID is returned.\n */\nstatic inline vfsuid_t i_uid_into_vfsuid(struct mnt_idmap *idmap,\n\t\t\t\t\t const struct inode *inode)\n{\n\treturn make_vfsuid(idmap, i_user_ns(inode), inode->i_uid);\n}\n```","parent":112,"child":0,"next":113},{"ID":0,"markdown":""},{"ID":109,"CreatedAt":"2023-08-28T09:45:34.772Z","UpdatedAt":"2023-08-29T07:48:57.807Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"当前cap c 和 目标cap 1 << flag 进行 & 运算\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/capability.h#L75\n\n```c\n#define cap_raised(c, flag) (((c).val & BIT_ULL(flag)) != 0)\n```","last":111,"child":110,"next":0},{"ID":110,"CreatedAt":"2023-08-29T03:57:16.592Z","UpdatedAt":"2023-08-29T03:57:16.592Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/include/vdso/bits.h#L8\n\n```c\n#define BIT_ULL(nr)\t\t(ULL(1) << (nr))\n```","parent":109,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":82,"CreatedAt":"2023-08-25T06:33:10.248Z","UpdatedAt":"2023-08-25T09:50:46.75Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"从 user namespace 的 idmapping 中，将 kuid 映射为 uid\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/user_namespace.c#L427\n\n```c\n/**\n *\tfrom_kuid - Create a uid from a kuid user-namespace pair.\n *\t@targ: The user namespace we want a uid in.\n *\t@kuid: The kernel internal uid to start with.\n *\n *\tMap @kuid into the user-namespace specified by @targ and\n *\treturn the resulting uid.\n *\n *\tThere is always a mapping into the initial user_namespace.\n *\n *\tIf @kuid has no mapping in @targ (uid_t)-1 is returned.\n */\nuid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\n{\n\t/* Map the uid from a global kernel uid */\n\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));\n}\n```","last":96,"child":83,"next":91},{"ID":83,"CreatedAt":"2023-08-25T06:43:35.235Z","UpdatedAt":"2023-08-26T08:48:51.365Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`map_id_up()` 函数将 id 向上映射，通常是将kid映射到用户空间。\n\n* id映射的数量 `nr_extents` <= 5, 则调用 `map_id_up_base()` 函数返回 id 所在的 idmapping\n* id映射的数量 `nr_extents` > 5, 则调用 `map_id_up_max()` 函数返回 id 所在的 idmapping\n\n再根据idmapping 规则映射id：\n\n* 如果找到了 idmapping (即 extent) ，则向上映射`id = id - lower_first + first`\n* 否则，返回溢出值 u32(-1)\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/user_namespace.c#L375\n\n```c\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}\n```","parent":82,"child":84,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":84,"CreatedAt":"2023-08-25T06:47:44.193Z","UpdatedAt":"2023-08-25T08:16:21.5Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"uid_gid_map 中有3个字段来存储 idmapping ，nr_extents 记录 idmapping 的数量。\n\n* extent: 最大可以存储5个 idmapping\n* forward/reverse: 超过5个时，存储在 forward, reverse 中\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/user_namespace.h#L24\n\n```c\nstruct uid_gid_map { /* 64 bytes -- 1 cache line */\n\tu32 nr_extents;\n\tunion {\n\t\tstruct uid_gid_extent extent[UID_GID_MAP_MAX_BASE_EXTENTS];\n\t\tstruct {\n\t\t\tstruct uid_gid_extent *forward;\n\t\t\tstruct uid_gid_extent *reverse;\n\t\t};\n\t};\n};\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/user_namespace.h#L14\n\n```c\n#define UID_GID_MAP_MAX_BASE_EXTENTS 5\n```\n","parent":83,"child":87,"next":85},{"ID":87,"CreatedAt":"2023-08-25T07:42:36.212Z","UpdatedAt":"2023-08-25T07:42:36.212Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"uid_gid_extent 是 idmapping 的数据结构，表达 `u:k:r`。 \n\n* u 表示 upper idmapset 中的第一个元素 U, 即 uid_gid_extent 结构体中的 first；\n* k 表示 lower idmapset 中的第一个元素 K，即 uid_gid_extent 结构体中的 lower_first；\n* r 表示idmapping的范围，即映射了多少个id，即 uid_gid_extent 结构体中的 count;\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/user_namespace.h#L17-L21\n\n```c\nstruct uid_gid_extent {\n\tu32 first;\n\tu32 lower_first;\n\tu32 count;\n};\n```","parent":84,"child":0,"next":0},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":113,"CreatedAt":"2023-08-29T08:42:02.8Z","UpdatedAt":"2023-08-29T09:04:52.751Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`from_kuid()`上文分析过，是从 user namespace 的 idmapping 中，将 kuid 映射为 uid。\n\n此执行流程中，user namespace 是当前任务的user namespace, 判断其uid是否为溢出值。非溢出值，说明vfsuid有mapping\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/include/linux/mnt_idmapping.h#L149\n\n```c\nstatic inline bool vfsuid_has_mapping(struct user_namespace *userns,\n\t\t\t\t      vfsuid_t vfsuid)\n{\n\treturn from_kuid(userns, AS_KUIDT(vfsuid)) != (uid_t)-1;\n}\n```","last":115,"child":0,"next":114},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":91,"CreatedAt":"2023-08-26T07:53:59.076Z","UpdatedAt":"2023-08-26T07:53:59.076Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将 uid 映射到 user_namespace 中 idmapping 的 kuid\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/kernel/user_namespace.c#L408\n\n```c\n/**\n *\tmake_kuid - Map a user-namespace uid pair into a kuid.\n *\t@ns:  User namespace that the uid is in\n *\t@uid: User identifier\n *\n *\tMaps a user-namespace uid pair into a kernel internal kuid,\n *\tand returns that kuid.\n *\n *\tWhen there is no mapping defined for the user-namespace uid\n *\tpair INVALID_UID is returned.  Callers are expected to test\n *\tfor and handle INVALID_UID being returned.  INVALID_UID\n *\tmay be tested for using uid_valid().\n */\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}\n```","last":82,"child":92,"next":0},{"ID":92,"CreatedAt":"2023-08-26T07:57:34.36Z","UpdatedAt":"2023-08-26T07:57:34.36Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/kernel/user_namespace.c#L332\n\n```c\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}\n```","parent":91,"child":93,"next":0},{"ID":93,"CreatedAt":"2023-08-26T07:58:10.311Z","UpdatedAt":"2023-08-26T09:34:21.2Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`map_id_range_down()` 函数将 id 向下映射，通常是将uid映射到kuid。\n\n* id映射的数量 `nr_extents` <= 5, 则调用 `map_id_range_down_base()` 函数返回 id 所在的 idmapping\n* id映射的数量 `nr_extents` > 5, 则调用 `map_id_range_down_max()` 函数返回 id 所在的 idmapping\n\n再根据idmapping 规则映射id：\n\n* 如果找到了 idmapping (即 extent) ，则向下映射`kuid = uid - first + lower_first`\n* 否则，返回溢出值 u32(-1)\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/kernel/user_namespace.c#L312\n\n```c\nstatic u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}\n```","parent":92,"child":94,"next":0},{"ID":94,"CreatedAt":"2023-08-26T07:59:14.605Z","UpdatedAt":"2023-08-26T09:39:16.665Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"传入的count为1，因此 id2, count 无需考虑。\n\n返回 id 所在范围的 idmapping\n\nhttps://github.com/ssst0n3/linux/blob/v6.4/kernel/user_namespace.c#L288-L310\n\n```c\n/**\n * map_id_range_down_base - Find idmap via binary search in static extent array.\n * Can only be called if number of mappings is equal or less than\n * UID_GID_MAP_MAX_BASE_EXTENTS.\n */\nstatic struct uid_gid_extent *\nmap_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}\n```","parent":93,"child":0,"next":95},{"ID":85,"CreatedAt":"2023-08-25T06:48:04.833Z","UpdatedAt":"2023-08-25T09:07:41.764Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"在 extents 数量 <= 5 时，遍历 extents， 计算 id 是否在 (lower_fist, lower_firt + count - 1) 范围内\n\n* 如果在范围内，范围所在范围的 extent, 即idmapping\n* 否则，返回 NULL\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/user_namespace.c#L343\n\n```c\n/**\n * map_id_up_base - Find idmap via binary search in static extent array.\n * Can only be called if number of mappings is equal or less than\n * UID_GID_MAP_MAX_BASE_EXTENTS.\n */\nstatic struct uid_gid_extent *\nmap_id_up_base(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tunsigned idx;\n\tu32 first, last;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].lower_first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last)\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}\n```","last":84,"child":0,"next":86},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":114,"CreatedAt":"2023-08-29T08:42:42.846Z","UpdatedAt":"2023-08-29T08:43:37.944Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/include/linux/mnt_idmapping.h#L187\n\n```c\nstatic inline bool vfsgid_has_mapping(struct user_namespace *userns,\n\t\t\t\t      vfsgid_t vfsgid)\n{\n\treturn from_kgid(userns, AS_KGIDT(vfsgid)) != (gid_t)-1;\n}\n```","last":113,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":95,"CreatedAt":"2023-08-26T08:00:15.049Z","UpdatedAt":"2023-08-26T08:00:15.049Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/ssst0n3/linux/blob/v6.4/kernel/user_namespace.c#L271-L286\n\n```c\n/**\n * map_id_range_down_max - Find idmap via binary search in ordered idmap array.\n * Can only be called if number of mappings exceeds UID_GID_MAP_MAX_BASE_EXTENTS.\n */\nstatic struct uid_gid_extent *\nmap_id_range_down_max(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = false;\n\tkey.count = count;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->forward, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}\n```","last":94,"child":0,"next":0},{"ID":86,"CreatedAt":"2023-08-25T06:53:39.787Z","UpdatedAt":"2023-08-25T09:09:43.575Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"在 extents 数量大于5时，遍历的性能较差，使用二分法搜索 id 所在的idmapping。\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/user_namespace.c#L363\n\n```c\n/**\n * map_id_up_max - Find idmap via binary search in ordered idmap array.\n * Can only be called if number of mappings exceeds UID_GID_MAP_MAX_BASE_EXTENTS.\n */\nstatic struct uid_gid_extent *\nmap_id_up_max(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = true;\n\tkey.count = 1;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->reverse, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}\n```","last":85,"child":88,"next":0},{"ID":88,"CreatedAt":"2023-08-25T09:25:14.157Z","UpdatedAt":"2023-08-25T09:40:13.159Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"cmp_map_id 函数 将被传递给 bsearch 函数，用于判断 id 是否在 idmapping e 中。\n\nid2, key->count 在本场景不涉及。因此，判断方法就是朴素的 `lower_fist <= id <= lower_fist + count -1`\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/user_namespace.c#L245\n\n```c\n/**\n * cmp_map_id - Function to be passed to bsearch() to find the requested\n * idmapping. Expects struct idmap_key to be passed via @k.\n */\nstatic int cmp_map_id(const void *k, const void *e)\n{\n\tu32 first, last, id2;\n\tconst struct idmap_key *key = k;\n\tconst struct uid_gid_extent *el = e;\n\n\tid2 = key->id + key->count - 1;\n\n\t/* handle map_id_{down,up}() */\n\tif (key->map_up)\n\t\tfirst = el->lower_first;\n\telse\n\t\tfirst = el->first;\n\n\tlast = first + el->count - 1;\n\n\tif (key->id >= first && key->id <= last &&\n\t    (id2 >= first && id2 <= last))\n\t\treturn 0;\n\n\tif (key->id < first || id2 < first)\n\t\treturn -1;\n\n\treturn 1;\n}\n```","parent":86,"child":0,"next":0},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""},{"ID":-1,"markdown":""}]],"toc":{"headings":[{"nodeName":"H2","innerText":"1. define CAP_CHOWN 0","id":"1-define-cap_chown-0"},{"nodeName":"H2","innerText":"2. chown_ok()","id":"2-chown_ok"},{"nodeName":"H3","innerText":"2.0 uid, ns","id":"20-uid-ns"},{"nodeName":"H3","innerText":"2.1 vfsuid == fsuid == ia_vfsuid","id":"21-vfsuid--fsuid--ia_vfsuid"},{"nodeName":"H3","innerText":"2.2. current_userns capable","id":"22-current_userns-capable"},{"nodeName":"H4","innerText":"* ns_capable","id":"-ns_capable"},{"nodeName":"H3","innerText":"2.3 fs_userns capable","id":"23-fs_userns-capable"},{"nodeName":"H2","innerText":"3. chgrp_ok()","id":"3-chgrp_ok"},{"nodeName":"H2","innerText":"4. ocfs2_vfs_reflink","id":"4-ocfs2_vfs_reflink"}],"title":{"nodeName":"H1","innerText":"Linux Kernel CAP_CHOWN 源码分析","id":"linux-kernel-cap_chown-源码分析"}}}