{"matrix":[[],[{"ID":125,"CreatedAt":"2023-09-06T07:45:08.217Z","UpdatedAt":"2023-09-06T07:47:29.516Z","DeletedAt":null,"title":"Linux Kernel CAP_DAC_OVERRIDE 源码分析","function_declare":"","git_url":"","note":"","code":"","markdown":"# Linux Kernel CAP_DAC_OVERRIDE 源码分析\n\n* version: v0.1.0\n* author: ssst0n3\n* code-version: v6.4","child":0,"next":126},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":126,"CreatedAt":"2023-09-06T07:47:51.02Z","UpdatedAt":"2023-09-06T08:26:31.483Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"搜索关键字 `CAP_DAC_OVERRIDE` ，除去测试代码、注释等引用，源码中有2处用到 `CAP_DAC_OVERRIDE` ","last":125,"child":127,"next":0},{"ID":127,"CreatedAt":"2023-09-06T07:55:03.816Z","UpdatedAt":"2023-09-08T06:52:43.531Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 1. define CAP_DAC_OVERRIDE     1\n\n覆盖所有DAC访问权限，包括ACL执行访问权限。但不包括由CAP_LINUX_IMMUTABLE包含的DAC访问权限(FS_APPEND_FL,FS_IMMUTABLE_FL)。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/capability.h#L119\n\n```c\n/* Override all DAC access, including ACL execute access if\n   [_POSIX_ACL] is defined. Excluding DAC access covered by\n   CAP_LINUX_IMMUTABLE. */\n\n#define CAP_DAC_OVERRIDE     1\n```","parent":126,"child":0,"next":128},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":128,"CreatedAt":"2023-09-06T08:28:56.803Z","UpdatedAt":"2023-09-07T05:29:37.282Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 2. generic_permission()\n\ngeneric_permission() 用来检查文件的访问权限。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L399\n\n```c\n/**\n * generic_permission -  check for access rights on a Posix-like filesystem\n * @idmap:\tidmap of the mount the inode was found from\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC,\n *\t\t%MAY_NOT_BLOCK ...)\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n *\n * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk\n * request cannot be satisfied (eg. requires blocking or too much complexity).\n * It would then be called again in ref-walk mode.\n *\n * If the inode has been found through an idmapped mount the idmap of\n * the vfsmount must be passed through @idmap. This function will then take\n * care to map the inode according to @idmap before checking permissions.\n * On non-idmapped mounts or if permission checking is to be performed on the\n * raw inode simply passs @nop_mnt_idmap.\n */\nint generic_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t       int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(idmap, inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL(generic_permission);\n```","last":127,"child":131,"next":0},{"ID":131,"CreatedAt":"2023-09-06T08:52:10.288Z","UpdatedAt":"2023-09-08T09:52:13.797Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.0 概念\n\n* UGO: 文件基本权限\n* ACL: acl定义的权限是UGO文件权限位所指定的权限的超集\n* DAC/MAC\n* CAP\n\n优先级： CAP > UGO(user) > ACL > UGO(group,other) ","parent":128,"child":0,"next":130},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":130,"CreatedAt":"2023-09-06T08:51:12.368Z","UpdatedAt":"2023-09-08T09:52:43.597Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.1 acl权限检查\n\n并非一上来就检查cap，而是优先检查acl和DAC。检查未通过（EACCES），还可以继续校验cap。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L407\n\n```c\nint generic_permission(struct mnt_idmap *idmap, struct inode *inode,\n               int mask)\n{\n    int ret;\n\n    /*\n     * Do the basic permission checks.\n     */\n    ret = acl_permission_check(idmap, inode, mask);\n    if (ret != -EACCES)\n        return ret;\n    ...\n}\n```","last":131,"child":134,"next":129},{"ID":134,"CreatedAt":"2023-09-06T09:00:27.929Z","UpdatedAt":"2023-09-08T09:53:44.308Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"* 先校验 UGO中的user权限，直接返回结果\n* 如果有ACL且有group权限，校验ACL\n* 校验 UGO(group, other)\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L338\n\n```c\n/**\n * acl_permission_check - perform basic UNIX permission checking\n * @idmap:\tidmap of the mount the inode was found from\n * @inode:\tinode to check permissions on\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)\n *\n * This function performs the basic UNIX permission checking. Since this\n * function may retrieve POSIX acls it needs to know whether it is called from a\n * blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit.\n *\n * If the inode has been found through an idmapped mount the idmap of\n * the vfsmount must be passed through @idmap. This function will then take\n * care to map the inode according to @idmap before checking permissions.\n * On non-idmapped mounts or if permission checking is to be performed on the\n * raw inode simply passs @nop_mnt_idmap.\n */\nstatic int acl_permission_check(struct mnt_idmap *idmap,\n\t\t\t\tstruct inode *inode, int mask)\n{\n\tunsigned int mode = inode->i_mode;\n\tvfsuid_t vfsuid;\n\n\t/* Are we the owner? If so, ACL's don't matter */\n\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\tif (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) {\n\t\tmask &= 7;\n\t\tmode >>= 6;\n\t\treturn (mask & ~mode) ? -EACCES : 0;\n\t}\n\n\t/* Do we have ACL's? */\n\tif (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n\t\tint error = check_acl(idmap, inode, mask);\n\t\tif (error != -EAGAIN)\n\t\t\treturn error;\n\t}\n\n\t/* Only RWX matters for group/other mode bits */\n\tmask &= 7;\n\n\t/*\n\t * Are the group permissions different from\n\t * the other permissions in the bits we care\n\t * about? Need to check group ownership if so.\n\t */\n\tif (mask & (mode ^ (mode >> 3))) {\n\t\tvfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n\t\tif (vfsgid_in_group_p(vfsgid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/* Bits in 'mode' clear that we require? */\n\treturn (mask & ~mode) ? -EACCES : 0;\n}\n```","parent":130,"child":140,"next":0},{"ID":140,"CreatedAt":"2023-09-06T09:55:43.869Z","UpdatedAt":"2023-09-07T05:43:02.318Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"> 涉及到vfsuid部分本文不详细展开，可简单认为是文件的实际kuid。\n\n如果当前用户是文件的 owner（当前 fsuid 是 vfsuid），则可无需校验ACL，只校验DAC即可，即文件是否赋予了owner意向操作所需的访问权限(rwx)。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L341-L350\n\n```c\nstatic int acl_permission_check(struct mnt_idmap *idmap,\n                struct inode *inode, int mask)\n{\n    unsigned int mode = inode->i_mode;\n    vfsuid_t vfsuid;\n\n    /* Are we the owner? If so, ACL's don't matter */\n    vfsuid = i_uid_into_vfsuid(idmap, inode);\n    if (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) {\n        mask &= 7;\n        mode >>= 6;\n        return (mask & ~mode) ? -EACCES : 0;\n    }\n    ...\n}\n```","parent":134,"child":142,"next":143},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":142,"CreatedAt":"2023-09-07T03:48:50.866Z","UpdatedAt":"2023-09-07T05:44:46.652Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"inode->i_mode\n\ni_mode字段使用了位掩码（bitmask）来表示多个属性，包括文件类型（如普通文件、目录、符号链接等）以及访问权限（读、写、执行等）。具体来说，i_mode字段的低12位用于表示权限，高4位用于表示文件类型。\n\n因此 `mode >> 6` 意味着丢弃 group, other 的访问权限， 和 `mask & 7` 比较，即只比较 owner 的访问权限啊。\n\n`mask & ~mode` 对mode取反再按位与的含义是，有一项权限不满足都不能通过权限检查。\n\n例如意向操作 mask 的读写执行均需要，即 `0b111`, 而文件仅赋予了owner 读和执行权限即`0b011`，则校验不通过：\n\n`mask & ~mode = 0b111 & 0b100 = 0b100`\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/stat.h#L7-L44\n\n```c\n#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)\n\n#define S_IFMT  00170000\n#define S_IFSOCK 0140000\n#define S_IFLNK\t 0120000\n#define S_IFREG  0100000\n#define S_IFBLK  0060000\n#define S_IFDIR  0040000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_ISUID  0004000\n#define S_ISGID  0002000\n#define S_ISVTX  0001000\n\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n#define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n\n#define S_IRWXU 00700\n#define S_IRUSR 00400\n#define S_IWUSR 00200\n#define S_IXUSR 00100\n\n#define S_IRWXG 00070\n#define S_IRGRP 00040\n#define S_IWGRP 00020\n#define S_IXGRP 00010\n\n#define S_IRWXO 00007\n#define S_IROTH 00004\n#define S_IWOTH 00002\n#define S_IXOTH 00001\n\n#endif\n```","parent":140,"child":0,"next":141},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":129,"CreatedAt":"2023-09-06T08:33:23.089Z","UpdatedAt":"2023-09-07T05:30:09.773Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.2 文件夹\n\n如果目标是文件夹，仅拥有 `CAP_DAC_READ_SEARCH`或`CAP_DAC_OVERRIDE` 可以无视权限规则。\n\n调用者预期非写入行为，使用 `CAP_DAC_READ_SEARCH` 控制特权，如无该cap，再继续判断`CAP_DAC_OVERRIDE`。但非本文关注重点，在分析`CAP_DAC_READ_SEARCH`时再重点关注，本文略。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L411-L421\n\n```c\nint generic_permission(struct mnt_idmap *idmap, struct inode *inode,\n               int mask)\n{\n    ...\n    if (S_ISDIR(inode->i_mode)) {\n        /* DACs are overridable for directories */\n        if (!(mask & MAY_WRITE))\n            if (capable_wrt_inode_uidgid(idmap, inode,\n                             CAP_DAC_READ_SEARCH))\n                return 0;\n        if (capable_wrt_inode_uidgid(idmap, inode,\n                         CAP_DAC_OVERRIDE))\n            return 0;\n        return -EACCES;\n    }\n    ...\n}\n```","last":130,"child":135,"next":137},{"ID":135,"CreatedAt":"2023-09-06T09:05:36.25Z","UpdatedAt":"2023-09-07T05:30:14.707Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"#### capable_wrt_inode_uidgid CAP_DAC_OVERRIDE\n\n本函数在 CAP_CHOWN 时分析过，判断任务在当前 user namespace 中拥有cap，且inode 中记录的kuid 是否在当前 user namespace 中有mapping\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/capability.c#L491\n\n```c\n/**\n * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped\n * @inode: The inode in question\n * @cap: The capability in question\n *\n * Return true if the current task has the given capability targeted at\n * its own user namespace and that the given inode's uid and gid are\n * mapped into the current user namespace.\n */\nbool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,\n\t\t\t      const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) &&\n\t       privileged_wrt_inode_uidgid(ns, idmap, inode);\n}\nEXPORT_SYMBOL(capable_wrt_inode_uidgid);\n```","parent":129,"child":0,"next":0},{"ID":143,"CreatedAt":"2023-09-07T05:48:11.272Z","UpdatedAt":"2023-09-07T05:50:13.621Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"如果文件设置了ACL规则，且group拥有rwx任一权限，则需要校验ACL\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L352-L357\n\n```c\nstatic int acl_permission_check(struct mnt_idmap *idmap,\n                struct inode *inode, int mask)\n{\n    ...\n    /* Do we have ACL's? */\n    if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n        int error = check_acl(idmap, inode, mask);\n        if (error != -EAGAIN)\n            return error;\n    }\n    ...\n}\n```","last":140,"child":133,"next":161},{"ID":133,"CreatedAt":"2023-09-06T08:57:32.285Z","UpdatedAt":"2023-09-07T06:38:26.132Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"获取acl，调用 `posix_acl_permission()` 校验acl。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L293\n\n```c\n/**\n * check_acl - perform ACL permission checking\n * @idmap:\tidmap of the mount the inode was found from\n * @inode:\tinode to check permissions on\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)\n *\n * This function performs the ACL permission checking. Since this function\n * retrieve POSIX acls it needs to know whether it is called from a blocking or\n * non-blocking context and thus cares about the MAY_NOT_BLOCK bit.\n *\n * If the inode has been found through an idmapped mount the idmap of\n * the vfsmount must be passed through @idmap. This function will then take\n * care to map the inode according to @idmap before checking permissions.\n * On non-idmapped mounts or if permission checking is to be performed on the\n * raw inode simply passs @nop_mnt_idmap.\n */\nstatic int check_acl(struct mnt_idmap *idmap,\n\t\t     struct inode *inode, int mask)\n{\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl *acl;\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tacl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);\n\t        if (!acl)\n\t                return -EAGAIN;\n\t\t/* no ->get_inode_acl() calls in RCU mode... */\n\t\tif (is_uncached_acl(acl))\n\t\t\treturn -ECHILD;\n\t        return posix_acl_permission(idmap, inode, acl, mask);\n\t}\n\n\tacl = get_inode_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl) {\n\t        int error = posix_acl_permission(idmap, inode, acl, mask);\n\t        posix_acl_release(acl);\n\t        return error;\n\t}\n#endif\n\n\treturn -EAGAIN;\n}\n\n```","parent":143,"child":144,"next":0},{"ID":144,"CreatedAt":"2023-09-07T06:20:42.254Z","UpdatedAt":"2023-09-07T06:37:19.861Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"获取acl，两种方式区别在与，非堵塞场景使用rcu模式读取。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L66\n\n```c\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl = rcu_dereference(*acl_by_type(inode, type));\n\n\tif (acl == ACL_DONT_CACHE) {\n\t\tstruct posix_acl *ret;\n\n\t\tret = inode->i_op->get_inode_acl(inode, type, LOOKUP_RCU);\n\t\tif (!IS_ERR(ret))\n\t\t\tacl = ret;\n\t}\n\n\treturn acl;\n}\nEXPORT_SYMBOL(get_cached_acl_rcu);\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L183\n\n```c\nstruct posix_acl *get_inode_acl(struct inode *inode, int type)\n{\n\treturn __get_acl(&nop_mnt_idmap, NULL, inode, type);\n}\nEXPORT_SYMBOL(get_inode_acl);\n```","parent":133,"child":147,"next":145},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":147,"CreatedAt":"2023-09-07T06:33:55.117Z","UpdatedAt":"2023-09-07T06:36:37.848Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L35\n\n```c\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}\n```","parent":144,"child":0,"next":146},{"ID":141,"CreatedAt":"2023-09-07T03:40:20.663Z","UpdatedAt":"2023-09-07T05:30:22.271Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"likely 是提供[给编译器的优化提示](https://kernelnewbies.org/FAQ/LikelyUnlikely)，略。\n\nvfsuid_eq_kuid 检查 vfsuid 与 fsuid 是否相等。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/mnt_idmapping.h#L79\n\n```c\nstatic inline bool vfsuid_eq_kuid(vfsuid_t vfsuid, kuid_t kuid)\n{\n\treturn vfsuid_valid(vfsuid) && __vfsuid_val(vfsuid) == __kuid_val(kuid);\n}\n```","last":142,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":137,"CreatedAt":"2023-09-06T09:23:21.784Z","UpdatedAt":"2023-09-07T05:30:28.222Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 2.3 非文件夹\n\n* `CAP_DAC_READ_SEARCH`可绕过 读权限\n* `CAP_DAC_OVERRIDE`可绕过 读写权限\n* 文件本身设置了任意的执行权限，`CAP_DAC_OVERRIDE`可绕过 执行权限\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L436-L441\n\n```c\nint generic_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t       int mask)\n{\n    ...\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\n```","last":129,"child":138,"next":0},{"ID":138,"CreatedAt":"2023-09-06T09:44:19.199Z","UpdatedAt":"2023-09-07T05:30:35.519Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"UGO(user, group, other) 标识执行位\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/stat.h#L13\n\n```c\n#define S_IXUGO\t\t(S_IXUSR|S_IXGRP|S_IXOTH)\n```\n\nuser, group, other 的执行权限位\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/stat.h#L32-L42\n\n```c\n#define S_IXUSR 00100\n...\n#define S_IXGRP 00010\n...\n#define S_IXOTH 00001\n```","parent":137,"child":0,"next":139},{"ID":161,"CreatedAt":"2023-09-08T06:34:18.124Z","UpdatedAt":"2023-09-08T06:34:18.124Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`mask & (mode ^ (mode >> 3))` 用于判断，所需权限中， 赋予group 和 other 的权限是否存在不同。\n\n* 如果group, other 存在不同，且当前任务的用户组或附加组中存在文件所属用户组，则只判断组权限\n* 否则只需要判断other即可。\n\n```c\nstatic int acl_permission_check(struct mnt_idmap *idmap,\n                struct inode *inode, int mask)\n{\n    ...\n    /* Only RWX matters for group/other mode bits */\n    mask &= 7;\n\n    /*\n     * Are the group permissions different from\n     * the other permissions in the bits we care\n     * about? Need to check group ownership if so.\n     */\n    if (mask & (mode ^ (mode >> 3))) {\n        vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n        if (vfsgid_in_group_p(vfsgid))\n            mode >>= 3;\n    }\n\n    /* Bits in 'mode' clear that we require? */\n    return (mask & ~mode) ? -EACCES : 0;\n}\n```","last":143,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":145,"CreatedAt":"2023-09-07T06:22:47.244Z","UpdatedAt":"2023-09-08T03:09:52.297Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"仅检查 RWX。遍历每个ACL条目，根据不同类型有不同的校验方式。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\n/*\n * Return 0 if current is granted want access to the inode\n * by the acl. Returns -E... otherwise.\n */\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    const struct posix_acl_entry *pa, *pe, *mask_obj;\n    struct user_namespace *fs_userns = i_user_ns(inode);\n    int found = 0;\n    vfsuid_t vfsuid;\n    vfsgid_t vfsgid;\n\n    want &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        case ACL_USER_OBJ:\n            /* (May have been checked already) */\n            vfsuid = i_uid_into_vfsuid(idmap, inode);\n            if (vfsuid_eq_kuid(vfsuid, current_fsuid()))\n                goto check_perm;\n            break;\n        case ACL_USER:\n            vfsuid = make_vfsuid(idmap, fs_userns,\n                         pa->e_uid);\n            if (vfsuid_eq_kuid(vfsuid, current_fsuid()))\n                goto mask;\n            break;\n        case ACL_GROUP_OBJ:\n            vfsgid = i_gid_into_vfsgid(idmap, inode);\n            if (vfsgid_in_group_p(vfsgid)) {\n                found = 1;\n                if ((pa->e_perm & want) == want)\n                    goto mask;\n            }\n            break;\n        case ACL_GROUP:\n            vfsgid = make_vfsgid(idmap, fs_userns,\n                         pa->e_gid);\n            if (vfsgid_in_group_p(vfsgid)) {\n                found = 1;\n                if ((pa->e_perm & want) == want)\n                    goto mask;\n            }\n            break;\n        case ACL_MASK:\n            break;\n        case ACL_OTHER:\n            if (found)\n                return -EACCES;\n            else\n                goto check_perm;\n            default:\n                return -EIO;\n        }\n    }\n    return -EIO;\n\nmask:\n    for (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n        if (mask_obj->e_tag == ACL_MASK) {\n            if ((pa->e_perm & mask_obj->e_perm & want) == want)\n                return 0;\n            return -EACCES;\n        }\n    }\n\ncheck_perm:\n    if ((pa->e_perm & want) == want)\n        return 0;\n    return -EACCES;\n}\n```","last":144,"child":155,"next":0},{"ID":155,"CreatedAt":"2023-09-07T08:00:44.683Z","UpdatedAt":"2023-09-08T03:11:03.58Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`FOREACH_ACL_ENTRY()` 遍历ACL规则，pa 指向当前规则。\n\n`pa->e_tag` 标志着该条规则是什么类型。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/posix_acl.h#L20-L37\n\n```c\nstruct posix_acl_entry {\n\tshort\t\t\te_tag;\n\tunsigned short\t\te_perm;\n\tunion {\n\t\tkuid_t\t\te_uid;\n\t\tkgid_t\t\te_gid;\n\t};\n};\n\nstruct posix_acl {\n\trefcount_t\t\ta_refcount;\n\tstruct rcu_head\t\ta_rcu;\n\tunsigned int\t\ta_count;\n\tstruct posix_acl_entry\ta_entries[];\n};\n\n#define FOREACH_ACL_ENTRY(pa, acl, pe) \\\n\tfor(pa=(acl)->a_entries, pe=pa+(acl)->a_count; pa<pe; pa++)\n```","parent":145,"child":157,"next":148},{"ID":157,"CreatedAt":"2023-09-07T09:35:25.042Z","UpdatedAt":"2023-09-08T04:33:27.694Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`e_tag` 用来标识ACL规则的类型, 具体有以下类型 <sup>[man5/acl.5](https://man7.org/linux/man-pages/man5/acl.5.html)</sup>:\n\n* ACL_USER_OBJ: 文件所有者的访问权限\n* ACL_USER: 由ACL条目的限定符标识的用户的访问权限\n* ACL_GROUP_OBJ: 文件组的访问权限\n* ACL_GROUP: 由ACL条目的限定符标识的组的访问权限\n* ACL_MASK: 表示ACL_USER、ACL_GROUP_OBJ或ACL_GROUP类型的表项所能授予的最大访问权限\n* ACL_OTHER: 表示与ACL中任何其他表项不匹配的进程的访问权限\n\n当进行访问检查时，会对ACL_USER_OBJ和ACL_USER条目与effective user ID进行测试。effective group ID以及所有附加组ID会与ACL_GROUP_OBJ和ACL_GROUP条目进行测试。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/posix_acl.h#L27-L33\n\n```c\n/* e_tag entry in struct posix_acl_entry */\n#define ACL_USER_OBJ\t\t(0x01)\n#define ACL_USER\t\t(0x02)\n#define ACL_GROUP_OBJ\t\t(0x04)\n#define ACL_GROUP\t\t(0x08)\n#define ACL_MASK\t\t(0x10)\n#define ACL_OTHER\t\t(0x20)\n```","parent":155,"child":0,"next":0},{"ID":146,"CreatedAt":"2023-09-07T06:32:47.348Z","UpdatedAt":"2023-09-07T06:34:04.921Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"RCU是一种同步机制，在Linux内核2.5的开发过程中被添加到Linux内核中，针对read-most的情况进行了优化。<sup>[kernel doc](https://www.kernel.org/doc/html/next/RCU/whatisRCU.html)</sup>\n\n本文不再继续展开。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/rcupdate.h#L682\n\n```c\n/**\n * rcu_dereference() - fetch RCU-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * This is a simple wrapper around rcu_dereference_check().\n */\n#define rcu_dereference(p) rcu_dereference_check(p, 0)\n```","last":147,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":139,"CreatedAt":"2023-09-06T09:52:55.86Z","UpdatedAt":"2023-09-06T09:53:18.407Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"例如，docker环境内，即使拥有 `CAP_DAC_OVERRIDE`, 也不能执行无执行权限的文件。\n\n```shell\n$ docker run -ti ubuntu bash\nroot@525b987a9357:/# cat /proc/self/status |grep -i capeff\nCapEff:\t00000000a80425fb\nroot@525b987a9357:/# ls -alh /etc/passwd\n-rw-r--r-- 1 root root 922 Mar  8 02:05 /etc/passwd\nroot@525b987a9357:/# /etc/passwd\nbash: /etc/passwd: Permission denied\n```","last":138,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":148,"CreatedAt":"2023-09-07T07:42:19.327Z","UpdatedAt":"2023-09-08T03:44:32.365Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`ACL_USER_OBJ` ：文件所有者的访问权限， 例如`user::rw-`\n\n如果当前任务的fsuid 是文件owner，跳转至 `check_perm` , check_perm 比较 ACL规则中的 e_perm 是否包含待执行操作的权限。\n\n(这似乎就是基本权限UGO中的U (实际上ACL是基本权限的超集，基本权限是包含在其中的。) )\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    ...\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        case ACL_USER_OBJ:\n            /* (May have been checked already) */\n            vfsuid = i_uid_into_vfsuid(idmap, inode);\n            if (vfsuid_eq_kuid(vfsuid, current_fsuid()))\n                goto check_perm;\n            break;\n        ...\n        }\n    }\n    return -EIO;\n...\ncheck_perm:\n    if ((pa->e_perm & want) == want)\n        return 0;\n    return -EACCES;\n}\n```","last":155,"child":0,"next":149},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":149,"CreatedAt":"2023-09-07T07:44:54.885Z","UpdatedAt":"2023-09-08T06:26:12.394Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`ACL_USER` : 由ACL条目的限定符标识的用户的访问权限, 例如 \n\n```\nuser:lisa:rw-\nmask::r--\n```\n\n作一个映射获得vfsuid, 与当前任务的fsuid比较，符合则跳转至`mask` ；否则继续遍历下一条规则。\n\n遍历后续的第一个`ACL_MASK`规则(设计上，包含ACL_USER或ACL_GROUP标记类型的ACL必须只包含一个ACL_MASK标记类型的表项<sup>[man5/acl.5](https://man7.org/linux/man-pages/man5/acl.5.html)</sup>)。如果 `ACL_USER`, `ACL_MASK`, 待访问权限 三者相匹配，则允许访问。即 `ACL_USER` 定义的权限不能超过 `ACL_MASK`。\n\n如果没有`ACL_MASK` 会怎么样？那就只需要 `ACL_USER` 和 待访问权限相匹配即可。这似乎与manual相矛盾。可能在设置ACL时或其他地方已经做了限制，留待后续分析。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    ...\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        ...\n        case ACL_USER:\n            vfsuid = make_vfsuid(idmap, fs_userns,\n                         pa->e_uid);\n            if (vfsuid_eq_kuid(vfsuid, current_fsuid()))\n                goto mask;\n            break;\n        ...\n        }\n    }\n    return -EIO;\n\nmask:\n    for (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n        if (mask_obj->e_tag == ACL_MASK) {\n            if ((pa->e_perm & mask_obj->e_perm & want) == want)\n                return 0;\n            return -EACCES;\n        }\n    }\n\ncheck_perm:\n    if ((pa->e_perm & want) == want)\n        return 0;\n    return -EACCES;\n}\n```","last":148,"child":0,"next":150},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":150,"CreatedAt":"2023-09-07T07:46:53.194Z","UpdatedAt":"2023-09-08T06:25:38.395Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`ACL_GROUP_OBJ` : 文件组的访问权限\n\n文件的用户组，是否和当前任务的用户组或附加组匹配。\n\n* 如果`ACL_GROUP_OBJ` 包含目标访问行为所需权限，则再校验 `ACL_MASK`。\n* 如果`ACL_GROUP_OBJ` 不包含所需权限，则可继续遍历下一条ACL规则。(用户可能存在于多个组中，多个组可能都存在acl规则，需遍历完。)\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    ...\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        ...\n        case ACL_GROUP_OBJ:\n            vfsgid = i_gid_into_vfsgid(idmap, inode);\n            if (vfsgid_in_group_p(vfsgid)) {\n                found = 1;\n                if ((pa->e_perm & want) == want)\n                    goto mask;\n            }\n            break;\n        ...\n        }\n    }\n    return -EIO;\n\nmask:\n    for (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n        if (mask_obj->e_tag == ACL_MASK) {\n            if ((pa->e_perm & mask_obj->e_perm & want) == want)\n                return 0;\n            return -EACCES;\n        }\n    }\n\n...\n}\n```","last":149,"child":158,"next":151},{"ID":158,"CreatedAt":"2023-09-08T05:50:45.677Z","UpdatedAt":"2023-09-08T05:50:45.677Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/mnt_idmapping.c#L209-L228\n\n```c\n#ifdef CONFIG_MULTIUSER\n/**\n * vfsgid_in_group_p() - check whether a vfsuid matches the caller's groups\n * @vfsgid: the mnt gid to match\n *\n * This function can be used to determine whether @vfsuid matches any of the\n * caller's groups.\n *\n * Return: 1 if vfsuid matches caller's groups, 0 if not.\n */\nint vfsgid_in_group_p(vfsgid_t vfsgid)\n{\n\treturn in_group_p(AS_KGIDT(vfsgid));\n}\n#else\nint vfsgid_in_group_p(vfsgid_t vfsgid)\n{\n\treturn 1;\n}\n#endif\n```","parent":150,"child":159,"next":0},{"ID":159,"CreatedAt":"2023-09-08T05:51:51.098Z","UpdatedAt":"2023-09-08T06:01:27.77Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"比较当前任务的fsgid是否是目标用户组，或当前任务的附加组(Supplemental Group)中是否存在目标组。\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/groups.c#L227\n\n```c\n/*\n * Check whether we're fsgid/egid or in the supplemental group..\n */\nint in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}\n```","parent":158,"child":160,"next":0},{"ID":160,"CreatedAt":"2023-09-08T05:52:56.544Z","UpdatedAt":"2023-09-08T05:52:56.544Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/kernel/groups.c#L92\n\n```c\n/* a simple bsearch */\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n```","parent":159,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":151,"CreatedAt":"2023-09-07T07:47:23.22Z","UpdatedAt":"2023-09-08T06:06:40.308Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`ACL_GROUP`: 由ACL条目的限定符标识的组的访问权限\n\n与 `ACL_GROUP_OBJ` 类似\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    ...\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        ...\n        case ACL_GROUP:\n            vfsgid = make_vfsgid(idmap, fs_userns,\n                         pa->e_gid);\n            if (vfsgid_in_group_p(vfsgid)) {\n                found = 1;\n                if ((pa->e_perm & want) == want)\n                    goto mask;\n            }\n            break;\n        ...\n        }\n    }\n    return -EIO;\n\nmask:\n    for (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n        if (mask_obj->e_tag == ACL_MASK) {\n            if ((pa->e_perm & mask_obj->e_perm & want) == want)\n                return 0;\n            return -EACCES;\n        }\n    }\n...\n}\n```","last":150,"child":0,"next":152},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":152,"CreatedAt":"2023-09-07T07:47:30.47Z","UpdatedAt":"2023-09-08T06:08:48.67Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`ACL_MASK` ：表示ACL_USER、ACL_GROUP_OBJ或ACL_GROUP类型的表项所能授予的最大访问权限。\n\n本身非鉴权逻辑，继续下一条ACL。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    ...\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        ...\n        case ACL_MASK:\n            break;\n        ...\n        }\n    }\n    return -EIO;\n...\n}\n```","last":151,"child":0,"next":153},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":153,"CreatedAt":"2023-09-07T07:47:39.557Z","UpdatedAt":"2023-09-08T06:28:03.803Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`ACL_OTHER` 表示与ACL中任何其他表项不匹配的进程的访问权限。\n\n如果之前已经匹配到了 `ACL_GROUP_OBJ` 或 `ACL_GROUP` ， 但所需权限未在其中定义，则`ACL_OTHER`也不予通过。\n\n其他情况判断`ACL_OTHER` 中是否定义了所需权限。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    ...\n    int found = 0;\n    ...\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        ...\n        case ACL_GROUP_OBJ:\n            ...\n            if (...) {\n                found = 1;\n                if (...)\n                    goto mask;\n            }\n            break;\n        case ACL_GROUP:\n            ...\n            if (...) {\n                found = 1;\n                if (...)\n                    goto mask;\n            }\n            break;\n        case ACL_OTHER:\n            if (found)\n                return -EACCES;\n            else\n                goto check_perm;\n        ...\n        }\n    }\n    return -EIO;\n...\ncheck_perm:\n    if ((pa->e_perm & want) == want)\n        return 0;\n    return -EACCES;\n}\n```","last":152,"child":0,"next":154},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":154,"CreatedAt":"2023-09-07T07:51:18.3Z","UpdatedAt":"2023-09-07T07:51:55.568Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/posix_acl.c#L376\n\n```c\nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n             const struct posix_acl *acl, int want)\n{\n    ...\n    FOREACH_ACL_ENTRY(pa, acl, pe) {\n        switch(pa->e_tag) {\n        ...\n        default:\n            return -EIO;\n        }\n    }\n...\n```","last":153,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}]],"toc":{"headings":[{"nodeName":"H2","innerText":"1. define CAP_DAC_OVERRIDE     1","id":"1-define-cap_dac_override-----1"},{"nodeName":"H2","innerText":"2. generic_permission()","id":"2-generic_permission"},{"nodeName":"H3","innerText":"2.0 概念","id":"20-概念"},{"nodeName":"H3","innerText":"2.1 acl权限检查","id":"21-acl权限检查"},{"nodeName":"H3","innerText":"2.2 文件夹","id":"22-文件夹"},{"nodeName":"H4","innerText":"capable_wrt_inode_uidgid CAP_DAC_OVERRIDE","id":"capable_wrt_inode_uidgid-cap_dac_override"},{"nodeName":"H3","innerText":"2.3 非文件夹","id":"23-非文件夹"}],"title":{"nodeName":"H1","innerText":"Linux Kernel CAP_DAC_OVERRIDE 源码分析","id":"linux-kernel-cap_dac_override-源码分析"}}}