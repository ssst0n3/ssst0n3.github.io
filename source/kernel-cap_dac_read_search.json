{"matrix":[[],[{"ID":162,"CreatedAt":"2023-09-11T02:17:20.636Z","UpdatedAt":"2023-09-11T08:21:34.801Z","DeletedAt":null,"title":"Linux Kernel CAP_DAC_READ_SEARCH 源码分析","function_declare":"","git_url":"","note":"","code":"","markdown":"# Linux Kernel CAP_DAC_READ_SEARCH 源码分析\n\n* version: v0.1.0\n* author: ssst0n3,zhangqian\n* code-version: v6.4","child":0,"next":163},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":163,"CreatedAt":"2023-09-11T08:10:12.933Z","UpdatedAt":"2023-09-12T06:33:01.26Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"主要有5处用到\n\n* 1. 基础权限检查：generic_permission\n* 2. open_by_handle_at (syscall)\n* 3. link\n  * 3.1 linkat (syscall)\n  * 3.2 link (syscall)\n  * 3.3 io_linkat\n* 4. overlayfs\n* 5. btrfs\n","last":162,"child":164,"next":0},{"ID":164,"CreatedAt":"2023-09-11T08:10:21.542Z","UpdatedAt":"2023-09-11T08:38:44.67Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 0. define CAP_DAC_READ_SEARCH  2\n\n```c\n/* Overrides all DAC restrictions regarding read and search on files\n   and directories, including ACL restrictions if [_POSIX_ACL] is\n   defined. Excluding DAC access covered by CAP_LINUX_IMMUTABLE. */\n\n#define CAP_DAC_READ_SEARCH  2\n```","parent":163,"child":0,"next":179},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":179,"CreatedAt":"2023-09-12T02:15:36.27Z","UpdatedAt":"2023-09-12T06:30:53.303Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 1. 基础权限检查：generic_permission\n\ngeneric_permission() 用来检查文件的访问权限。详细流程已在 CAP_DAC_CHOWN 分析过。本文重点关注涉及 CAP_DAC_READ_SEARCH 部分。\n\n1. 调用 acl_permission_check 检查ACL权限，如果ACL权限不满足要求，还可以校验CAP。\n2. 拥有 CAP_DAC_READ_SEARCH 可对文件夹执行非写入操作\n3. 拥有 CAP_DAC_READ_SEARCH 可对非文件夹执行读操作\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L399\n\n```c\nint generic_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t       int mask)\n{\n\t...\n\tret = acl_permission_check(idmap, inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\t...\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t...\n\treturn -EACCES;\n}\n```","last":164,"child":0,"next":180},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":180,"CreatedAt":"2023-09-12T02:16:32.608Z","UpdatedAt":"2023-09-12T06:30:42.432Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 2. open_by_handle_at(syscall)\n\n(author: zhangqian)\n\n```c\n/**\n * sys_open_by_handle_at: Open the file handle\n * @mountdirfd: directory file descriptor\n * @handle: file handle to be opened\n * @flags: open flags.\n *\n * @mountdirfd indicate the directory file descriptor\n * of the mount point. file handle is decoded relative\n * to the vfsmount pointed by the @mountdirfd. @flags\n * value is same as the open(2) flags.\n */\nSYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\tstruct file_handle __user *, handle,\n\t\tint, flags)\n{\n\tlong ret;\n\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\tret = do_handle_open(mountdirfd, handle, flags);\n\treturn ret;\n}\n```","last":179,"child":197,"next":181},{"ID":197,"CreatedAt":"2023-09-12T06:29:54.279Z","UpdatedAt":"2023-09-12T06:29:54.279Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"\n\n```c\nstatic long do_handle_open(int mountdirfd, struct file_handle __user *ufh,\n\t\t\t   int open_flag)\n{\n\tlong retval = 0;\n\tstruct path path;\n\tstruct file *file;\n\tint fd;\n\n\tretval = handle_to_path(mountdirfd, ufh, &path);\n\tif (retval)\n\t\treturn retval;\n\n\tfd = get_unused_fd_flags(open_flag);\n\tif (fd < 0) {\n\t\tpath_put(&path);\n\t\treturn fd;\n\t}\n\tfile = file_open_root(&path, \"\", open_flag, 0);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\tretval =  PTR_ERR(file);\n\t} else {\n\t\tretval = fd;\n\t\tfsnotify_open(file);\n\t\tfd_install(fd, file);\n\t}\n\tpath_put(&path);\n\treturn retval;\n}\n```","parent":180,"child":198,"next":0},{"ID":198,"CreatedAt":"2023-09-12T06:30:03.217Z","UpdatedAt":"2023-09-12T06:30:03.217Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"```c\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * With handle we don't look at the execute bit on the\n\t * directory. Ideally we would like CAP_DAC_SEARCH.\n\t * But we don't have that\n\t */\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}\n\n```","parent":197,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":181,"CreatedAt":"2023-09-12T02:16:48.92Z","UpdatedAt":"2023-09-12T02:22:16.792Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 3. link","last":180,"child":184,"next":182},{"ID":184,"CreatedAt":"2023-09-12T02:44:38.725Z","UpdatedAt":"2023-09-12T06:41:46.695Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 3.1 linkat (syscall)\n\nlinkat是一个系统调用，它用于创建硬链接。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4695\n\n```c\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\treturn do_linkat(olddfd, getname_uflags(oldname, flags),\n\t\tnewdfd, getname(newname), flags);\n}\n```\n\n例如，以下代码展示了使用linkat创建一个硬链接。\n\n```c\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    int olddirfd = AT_FDCWD; // 使用当前目录的文件描述符\n    const char *oldpath = \"file.txt\";\n    int newdirfd = AT_FDCWD; // 使用当前目录的文件描述符\n    const char *newpath = \"link.txt\";\n    int flags = 0;\n\n    int result = linkat(olddirfd, oldpath, newdirfd, newpath, flags);\n    if (result == 0) {\n        printf(\"Link created successfully.\\n\");\n    } else {\n        perror(\"Link creation failed\");\n        return 1;\n    }\n\n    return 0;\n}\n```","parent":181,"child":187,"next":185},{"ID":187,"CreatedAt":"2023-09-12T02:49:11.977Z","UpdatedAt":"2023-09-12T02:49:11.977Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/syscalls.h#L221\n\n```c\n#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)\n...\n#define SYSCALL_DEFINEx(x, sname, ...)\t\\\n\tSYSCALL_METADATA(sname, x, __VA_ARGS__)\t\\\n\t__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)\n```","parent":184,"child":0,"next":193},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":182,"CreatedAt":"2023-09-12T02:17:00.904Z","UpdatedAt":"2023-09-12T02:17:00.904Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 4. overlayfs","last":181,"child":0,"next":183},{"ID":185,"CreatedAt":"2023-09-12T02:44:52.002Z","UpdatedAt":"2023-09-12T06:32:11.123Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 3.2 link (syscall)\n\n```c\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);\n}\n```","last":184,"child":0,"next":186},{"ID":193,"CreatedAt":"2023-09-12T03:57:23.355Z","UpdatedAt":"2023-09-12T06:38:19.927Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将用户传入的文件名转换为filename结构体。\n\nuflags 标志中只取 `AT_EMPTY_PATH`。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L208\n\n```c\nstruct filename *\ngetname_uflags(const char __user *filename, int uflags)\n{\n\tint flags = (uflags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;\n\n\treturn getname_flags(filename, flags, NULL);\n}\n```","last":187,"child":194,"next":188},{"ID":194,"CreatedAt":"2023-09-12T03:58:03.404Z","UpdatedAt":"2023-09-12T07:07:11.247Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"* `audit_reusename()`： audit 会记录访问的文件名。如果当前的audit 上下文中出现过该文件名，则返回审计上下文中记录的filename结构体。相当于借用 audit 作为缓存使用。\n* `__getname()`: 获取一个缓存的filename结构体\n\n\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L130\n\n```c\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (unlikely(len == EMBEDDED_NAME_MAX)) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tkname = (char *)result;\n\n\t\t/*\n\t\t * size is chosen that way we to guarantee that\n\t\t * result->iname[0] is within the same object and that\n\t\t * kname can't be equal to result->iname, no matter what.\n\t\t */\n\t\tresult = kzalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!result)) {\n\t\t\t__putname(kname);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tresult->name = kname;\n\t\tlen = strncpy_from_user(kname, filename, PATH_MAX);\n\t\tif (unlikely(len < 0)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(len);\n\t\t}\n\t\tif (unlikely(len == PATH_MAX)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t}\n\n\tresult->refcnt = 1;\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\tif (!(flags & LOOKUP_EMPTY)) {\n\t\t\tputname(result);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n}\n```","parent":193,"child":203,"next":0},{"ID":0,"markdown":""},{"ID":203,"CreatedAt":"2023-09-12T07:10:11.008Z","UpdatedAt":"2023-09-12T08:03:25.264Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`audit_reusename()`： audit 会记录访问的文件名。如果当前的audit 上下文中出现过该文件名，则返回审计上下文中记录的filename结构体。相当于借用 audit 作为缓存使用。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L136-L138\n\n```c\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n    ...\n    result = audit_reusename(filename);\n    if (result)\n        return result;\n        ...\n}","parent":194,"child":195,"next":205},{"ID":0,"markdown":""},{"ID":195,"CreatedAt":"2023-09-12T06:13:55.75Z","UpdatedAt":"2023-09-12T06:16:11.768Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"filename 结构体\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L2308\n\n```c\nstruct filename {\n\tconst char\t\t*name;\t/* pointer to actual string */\n\tconst __user char\t*uptr;\t/* original userland pointer */\n\tint\t\t\trefcnt;\n\tstruct audit_names\t*aname;\n\tconst char\t\tiname[];\n};\n```","parent":203,"child":0,"next":196},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":183,"CreatedAt":"2023-09-12T02:17:13.404Z","UpdatedAt":"2023-09-12T02:17:13.404Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 5. btrfs","last":182,"child":0,"next":0},{"ID":186,"CreatedAt":"2023-09-12T02:48:41.528Z","UpdatedAt":"2023-09-12T06:27:04.974Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 3.3 io_linkat\n\n```c\nint io_linkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_link *lnk = io_kiocb_to_cmd(req, struct io_link);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_linkat(lnk->old_dfd, lnk->oldpath, lnk->new_dfd,\n\t\t\t\tlnk->newpath, lnk->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n```","last":185,"child":0,"next":0},{"ID":188,"CreatedAt":"2023-09-12T02:49:23.804Z","UpdatedAt":"2023-09-12T06:54:32.049Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"#### do_linkat\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4623\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {\n\t\terror = -EINVAL;\n\t\tgoto out_putnames;\n\t}\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH && !capable(CAP_DAC_READ_SEARCH)) {\n\t\terror = -ENOENT;\n\t\tgoto out_putnames;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = filename_lookup(olddfd, old, how, &old_path, NULL);\n\tif (error)\n\t\tgoto out_putnames;\n\n\tnew_dentry = filename_create(newdfd, new, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out_putpath;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\tidmap = mnt_idmap(new_path.mnt);\n\terror = may_linkat(idmap, &old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,\n\t\t\t new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putpath:\n\tpath_put(&old_path);\nout_putnames:\n\tputname(old);\n\tputname(new);\n\n\treturn error;\n}\n```","last":193,"child":189,"next":0},{"ID":189,"CreatedAt":"2023-09-12T03:27:44.245Z","UpdatedAt":"2023-09-12T03:45:45.077Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"要求 flags 中只能设置 `AT_SYMLINK_FOLLOW`, `AT_EMPTY_PATH`，不能设置其他标志位。如果包含，则跳转至 `out_putnames`，并返回错误。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4633-L4636\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n          struct filename *new, int flags)\n{\n    ...\n    if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {\n        error = -EINVAL;\n        goto out_putnames;\n    }\n    ...\nout_putnames:\n    putname(old);\n    putname(new);\n\n    return error;\n}\n```","parent":188,"child":190,"next":0},{"ID":190,"CreatedAt":"2023-09-12T03:30:34.839Z","UpdatedAt":"2023-09-12T03:43:16.933Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"* `AT_SYMLINK_FOLLOW`: 用来控制是否解析软链接\n* `AT_EMPTY_PATH`: 当在linkat系统调用中，oldpath参数为一个空字符串时，如果指定了AT_EMPTY_PATH标志位，那么将创建一个新链接，这个链接的目标是表示当前目录的文件描述符newdfd所引用的目录。\n\n`flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)` 意为， flags中除`AT_SYMLINK_FOLLOW`,`AT_EMPTY_PATH` 以外的标志位。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/fcntl.h#L104\n\n```c\n#define AT_SYMLINK_FOLLOW\t0x400   /* Follow symbolic links.  */\n...\n#define AT_EMPTY_PATH\t\t0x1000\t/* Allow empty relative pathname */\n```","parent":189,"child":0,"next":191},{"ID":205,"CreatedAt":"2023-09-12T07:38:13.164Z","UpdatedAt":"2023-09-12T08:03:58.454Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将用户传入的文件名，复制到 `kname`\n\n```c\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\t...\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n    ...\n}","last":203,"child":206,"next":0},{"ID":206,"CreatedAt":"2023-09-12T07:38:37.845Z","UpdatedAt":"2023-09-12T07:41:05.841Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"获取一个cache的 filename 结构体。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L2388\n\n```c\n#define __getname() kmem_cache_alloc(names_cachep, GFP_KERNEL)\n```","parent":205,"child":0,"next":207},{"ID":196,"CreatedAt":"2023-09-12T06:23:45.687Z","UpdatedAt":"2023-09-12T06:23:45.687Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/audit.h#L359\n\n```c\n#ifdef CONFIG_AUDITSYSCALL\n...\nstatic inline struct filename *audit_reusename(const __user char *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn __audit_reusename(name);\n\treturn NULL;\n}\n...\n#else /* CONFIG_AUDITSYSCALL */\n...\nstatic inline struct filename *audit_reusename(const __user char *name)\n{\n\treturn NULL;\n}\n```","last":195,"child":199,"next":0},{"ID":199,"CreatedAt":"2023-09-12T06:39:46.115Z","UpdatedAt":"2023-09-12T06:57:45.429Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"audit 会记录访问的文件名。如果当前的audit 上下文中出现过该文件名，则返回审计上下文中记录的filename结构体，引用计数 ++ \n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/auditsc.c#L2202\n\n```c\n/**\n * __audit_reusename - fill out filename with info from existing entry\n * @uptr: userland ptr to pathname\n *\n * Search the audit_names list for the current audit context. If there is an\n * existing entry with a matching \"uptr\" then return the filename\n * associated with that audit_name. If not, return NULL.\n */\nstruct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n```","parent":196,"child":200,"next":0},{"ID":200,"CreatedAt":"2023-09-12T06:48:10.186Z","UpdatedAt":"2023-09-12T06:50:06.951Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"获取当前进程的audit上下文\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/audit.h#L313\n\n```c\n#ifdef CONFIG_AUDITSYSCALL\n...\nstatic inline struct audit_context *audit_context(void)\n{\n\treturn current->audit_context;\n}\n...\n#else /* CONFIG_AUDITSYSCALL */\n...\nstatic inline struct audit_context *audit_context(void)\n{\n\treturn NULL;\n}\n```","parent":199,"child":0,"next":201},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":191,"CreatedAt":"2023-09-12T03:46:22.004Z","UpdatedAt":"2023-09-12T06:37:22.406Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"用于处理 struct filename 结构的资源释放。\n\n前面调用系统调用时，将用户传入的文件名转为了filename结构体\n\n`getname_uflags(oldname, flags)`, `getname(newname), flags)`\n\n这里在系统调用结束时，释放结构体。\n\n释放时，如果引用计数 <= 0, 则报错；引用计数 -- 仍 > 0, 则返回不释放。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L259\n\n```c\nvoid putname(struct filename *name)\n{\n\tif (IS_ERR(name))\n\t\treturn;\n\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}\nEXPORT_SYMBOL(putname);\n```","last":190,"child":192,"next":0},{"ID":192,"CreatedAt":"2023-09-12T03:48:40.925Z","UpdatedAt":"2023-09-12T03:51:06.828Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L2389\n\n```c\n#define __putname(name)\tkmem_cache_free(names_cachep, (void *)(name))\n```","parent":191,"child":0,"next":0},{"ID":207,"CreatedAt":"2023-09-12T07:49:33.933Z","UpdatedAt":"2023-09-12T07:57:56.65Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"从用户空间复制字符串\n\nhttps://github.com/torvalds/linux/blob/v6.4/lib/strncpy_from_user.c#L113\n\n```c\n/**\n * strncpy_from_user: - Copy a NUL terminated string from userspace.\n * @dst:   Destination address, in kernel space.  This buffer must be at\n *         least @count bytes long.\n * @src:   Source address, in user space.\n * @count: Maximum number of bytes to copy, including the trailing NUL.\n *\n * Copies a NUL-terminated string from userspace to kernel space.\n *\n * On success, returns the length of the string (not including the trailing\n * NUL).\n *\n * If access to userspace fails, returns -EFAULT (some data may have been\n * copied).\n *\n * If @count is smaller than the length of the string, copies @count bytes\n * and returns @count.\n */\nlong strncpy_from_user(char *dst, const char __user *src, long count)\n{\n\tunsigned long max_addr, src_addr;\n\n\tmight_fault();\n\tif (should_fail_usercopy())\n\t\treturn -EFAULT;\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\n\tmax_addr = TASK_SIZE_MAX;\n\tsrc_addr = (unsigned long)untagged_addr(src);\n\tif (likely(src_addr < max_addr)) {\n\t\tunsigned long max = max_addr - src_addr;\n\t\tlong retval;\n\n\t\t/*\n\t\t * Truncate 'max' to the user-specified limit, so that\n\t\t * we only have one limit we need to check in the loop\n\t\t */\n\t\tif (max > count)\n\t\t\tmax = count;\n\n\t\tkasan_check_write(dst, count);\n\t\tcheck_object_size(dst, count, false);\n\t\tif (user_read_access_begin(src, max)) {\n\t\t\tretval = do_strncpy_from_user(dst, src, count, max);\n\t\t\tuser_read_access_end();\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn -EFAULT;\n}\nEXPORT_SYMBOL(strncpy_from_user);\n```","last":206,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":201,"CreatedAt":"2023-09-12T06:51:48.438Z","UpdatedAt":"2023-09-12T06:54:05.415Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"审计系统维护了一个用于存储审计相关信息的数据结构，其中包括审计上下文和与之关联的文件名信息。\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/audit.h#L128\n\n```c\n/* The per-task audit context. */\nstruct audit_context {\n\t...\n\t/*\n\t * The names_list is the list of all audit_names collected during this\n\t * syscall.  The first AUDIT_NAMES entries in the names_list will\n\t * actually be from the preallocated_names array for performance\n\t * reasons.  Except during allocation they should never be referenced\n\t * through the preallocated_names array and should only be found/used\n\t * by running the names_list.\n\t */\n\tstruct audit_names  preallocated_names[AUDIT_NAMES];\n\tint\t\t    name_count; /* total records in names_list */\n\tstruct list_head    names_list;\t/* struct audit_names->list anchor */\n\t...\n};\n```","last":200,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""}]],"toc":{"headings":[{"nodeName":"H2","innerText":"0. define CAP_DAC_READ_SEARCH  2","id":"0-define-cap_dac_read_search--2"},{"nodeName":"H2","innerText":"1. 基础权限检查：generic_permission","id":"1-基础权限检查generic_permission"},{"nodeName":"H2","innerText":"2. open_by_handle_at(syscall)","id":"2-open_by_handle_atsyscall"},{"nodeName":"H2","innerText":"3. link","id":"3-link"},{"nodeName":"H3","innerText":"3.1 linkat (syscall)","id":"31-linkat-syscall"},{"nodeName":"H4","innerText":"do_linkat","id":"do_linkat"},{"nodeName":"H3","innerText":"3.2 link (syscall)","id":"32-link-syscall"},{"nodeName":"H3","innerText":"3.3 io_linkat","id":"33-io_linkat"},{"nodeName":"H2","innerText":"4. overlayfs","id":"4-overlayfs"},{"nodeName":"H2","innerText":"5. btrfs","id":"5-btrfs"}],"title":{"nodeName":"H1","innerText":"Linux Kernel CAP_DAC_READ_SEARCH 源码分析","id":"linux-kernel-cap_dac_read_search-源码分析"}}}