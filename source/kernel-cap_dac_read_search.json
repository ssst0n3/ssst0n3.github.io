{"matrix":[[],[{"ID":162,"CreatedAt":"2023-09-11T02:17:20.636Z","UpdatedAt":"2023-09-11T08:21:34.801Z","DeletedAt":null,"title":"Linux Kernel CAP_DAC_READ_SEARCH 源码分析","function_declare":"","git_url":"","note":"","code":"","markdown":"# Linux Kernel CAP_DAC_READ_SEARCH 源码分析\n\n* version: v0.1.0\n* author: ssst0n3,zhangqian\n* code-version: v6.4","collapsed":false,"child":0,"next":163}],[{"ID":163,"CreatedAt":"2023-09-11T08:10:12.933Z","UpdatedAt":"2024-07-30T09:14:19.276Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"主要有5处用到\n\n* 1.基础权限检查：generic_permission: 覆盖部分DAC\n* 2.open_by_handle_at (syscall): 根据inode打开指定文件系统下的文件\n* 3.link: 在路径为空仅有fd的情况下创建硬链接\n  * 3.1 linkat (syscall)\n  * 3.2 link (syscall)\n  * 3.3 io_linkat (io_uring)\n* 4.overlayfs\n* 5.btrfs: BTRFS_IOC_INO_PATHS ioctl, 实现inode到path的查询\n\n其中 CAP_DAC_READ_SEARCH 中的 `READ` 是指generic_permission中对覆盖DAC的权限；`SEARCH`主要指根据inode获取path或dentry结构体的权限。","collapsed":false,"last":162,"child":164,"next":0},{"ID":164,"CreatedAt":"2023-09-11T08:10:21.542Z","UpdatedAt":"2023-09-11T08:38:44.67Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 0. define CAP_DAC_READ_SEARCH  2\n\n```c\n/* Overrides all DAC restrictions regarding read and search on files\n   and directories, including ACL restrictions if [_POSIX_ACL] is\n   defined. Excluding DAC access covered by CAP_LINUX_IMMUTABLE. */\n\n#define CAP_DAC_READ_SEARCH  2\n```","collapsed":false,"parent":163,"child":0,"next":179}],[{"ID":0,"markdown":""},{"ID":179,"CreatedAt":"2023-09-12T02:15:36.27Z","UpdatedAt":"2023-09-12T06:30:53.303Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 1. 基础权限检查：generic_permission\n\ngeneric_permission() 用来检查文件的访问权限。详细流程已在 CAP_DAC_CHOWN 分析过。本文重点关注涉及 CAP_DAC_READ_SEARCH 部分。\n\n1. 调用 acl_permission_check 检查ACL权限，如果ACL权限不满足要求，还可以校验CAP。\n2. 拥有 CAP_DAC_READ_SEARCH 可对文件夹执行非写入操作\n3. 拥有 CAP_DAC_READ_SEARCH 可对非文件夹执行读操作\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L399\n\n```c\nint generic_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t       int mask)\n{\n\t...\n\tret = acl_permission_check(idmap, inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\t...\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t...\n\treturn -EACCES;\n}\n```","collapsed":false,"last":164,"child":0,"next":180}],[{"ID":0,"markdown":""},{"ID":180,"CreatedAt":"2023-09-12T02:16:32.608Z","UpdatedAt":"2024-07-29T03:19:44.7Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 2. open_by_handle_at(syscall)\n\n参数：\n* mountdirfd: 目标文件系统下的任意文件，指示将要在哪个文件系统中搜索和打开文件。这个变量名似乎并不合适，因为实际实现时不要求该参数为文件夹\n* handle: 要打开的文件的file handle\n* flags: 打开文件的flags, 同open时要设置的flags\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L256\n\n```c\n/**\n * sys_open_by_handle_at: Open the file handle\n * @mountdirfd: directory file descriptor\n * @handle: file handle to be opened\n * @flags: open flags.\n *\n * @mountdirfd indicate the directory file descriptor\n * of the mount point. file handle is decoded relative\n * to the vfsmount pointed by the @mountdirfd. @flags\n * value is same as the open(2) flags.\n */\nSYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\tstruct file_handle __user *, handle,\n\t\tint, flags)\n{\n\tlong ret;\n\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\tret = do_handle_open(mountdirfd, handle, flags);\n\treturn ret;\n}\n```","collapsed":false,"last":179,"child":197,"next":181},{"ID":197,"CreatedAt":"2023-09-12T06:29:54.279Z","UpdatedAt":"2024-07-30T08:02:40.58Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将 fd 和 handle 转为 path, 其中 path->mnt 是 fd的挂载点， path->dentry 是根据 handle 的inode 生成或获取的 dentry。这个操作需要CAP_DAC_READ_SEARCH。\n\n再打开path返回fd。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L215\n\n```c\nstatic long do_handle_open(int mountdirfd, struct file_handle __user *ufh,\n\t\t\t   int open_flag)\n{\n\tlong retval = 0;\n\tstruct path path;\n\tstruct file *file;\n\tint fd;\n\n\tretval = handle_to_path(mountdirfd, ufh, &path);\n\tif (retval)\n\t\treturn retval;\n\n\tfd = get_unused_fd_flags(open_flag);\n\tif (fd < 0) {\n\t\tpath_put(&path);\n\t\treturn fd;\n\t}\n\tfile = file_open_root(&path, \"\", open_flag, 0);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\tretval =  PTR_ERR(file);\n\t} else {\n\t\tretval = fd;\n\t\tfsnotify_open(file);\n\t\tfd_install(fd, file);\n\t}\n\tpath_put(&path);\n\treturn retval;\n}\n```","collapsed":false,"parent":180,"child":198,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":198,"CreatedAt":"2023-09-12T06:30:03.217Z","UpdatedAt":"2024-07-30T07:43:35.846Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"handle_to_path 是对 do_handle_to_path 的封装，在具体业务实现前执行权限检查和内存管理：\n1. 检查是否在init_user_ns拥有CAP_DAC_READ_SEARCH\n2. 从用户空间复制文件句柄到内核\n3. 调用 do_handle_to_path 生成path, 包含挂载点和dentry。其中path->mnt是fd的挂载点，path->dentry是根据handle的inode获取或生成的dentry\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L167\n\n```c\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * With handle we don't look at the execute bit on the\n\t * directory. Ideally we would like CAP_DAC_SEARCH.\n\t * But we don't have that\n\t */\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}\n\n```","collapsed":false,"parent":197,"child":283,"next":301},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":283,"CreatedAt":"2024-07-29T02:16:29.218Z","UpdatedAt":"2024-07-29T02:29:08.924Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"要求在 init_user_ns 拥有CAP_DAC_READ_SEARCH\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L179\n\n```c\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n    int retval = 0;\n    ...\n    /*\n    * With handle we don't look at the execute bit on the\n    * directory. Ideally we would like CAP_DAC_SEARCH.\n    * But we don't have that\n    */\n    if (!capable(CAP_DAC_READ_SEARCH)) {\n    \tretval = -EPERM;\n    \tgoto out_err;\n    }\n    ...\nout_err:\n    return retval;\n}\n\n```","collapsed":false,"parent":198,"child":284,"next":285},{"ID":284,"CreatedAt":"2024-07-29T02:18:44.771Z","UpdatedAt":"2024-07-29T02:18:44.771Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/kernel/capability.c#L434\n\n```c\n/**\n * capable - Determine if the current task has a superior capability in effect\n * @cap: The capability to be tested for\n *\n * Return true if the current task has the given superior capability currently\n * available for use, false if not.\n *\n * This sets PF_SUPERPRIV on the task if the capability is available on the\n * assumption that it's about to be used.\n */\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}\n```","collapsed":false,"parent":283,"child":0,"next":0}],[{"ID":0,"markdown":""},{"ID":181,"CreatedAt":"2023-09-12T02:16:48.92Z","UpdatedAt":"2023-09-12T02:22:16.792Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 3. link","collapsed":false,"last":180,"child":184,"next":182},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":184,"CreatedAt":"2023-09-12T02:44:38.725Z","UpdatedAt":"2024-07-30T08:13:33.086Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 3.1 linkat (syscall)\n\nlinkat是一个系统调用，它用于创建硬链接。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4695\n\n```c\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\treturn do_linkat(olddfd, getname_uflags(oldname, flags),\n\t\tnewdfd, getname(newname), flags);\n}\n```\n\n例如，以下代码展示了使用linkat创建一个硬链接。\n\n```c\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    int olddirfd = AT_FDCWD; // 使用当前目录的文件描述符\n    const char *oldpath = \"file.txt\";\n    int newdirfd = AT_FDCWD; // 使用当前目录的文件描述符\n    const char *newpath = \"link.txt\";\n    int flags = 0;\n\n    int result = linkat(olddirfd, oldpath, newdirfd, newpath, flags);\n    if (result == 0) {\n        printf(\"Link created successfully.\\n\");\n    } else {\n        perror(\"Link creation failed\");\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n其中使用 AT_EMPTY_PATH 标志可以不指定oldpath。这要求当前进程在 init_user_ns 拥有 CAP_DAC_READ_SEARCH， 否则就结束函数。\n\n为什么需要 CAP_DAC_READ_SEARCH 呢？ 主要是考虑用户只拥有fd而不知道路径的场景。AT_EMPTY_PATH标志允许一个进程对一个已经打开的fd进行操作，而不需要指定文件的路径，这个文件可能是进程原本没有权限通过路径访问的文件。","collapsed":false,"parent":181,"child":187,"next":185},{"ID":187,"CreatedAt":"2023-09-12T02:49:11.977Z","UpdatedAt":"2023-09-12T02:49:11.977Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/syscalls.h#L221\n\n```c\n#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)\n...\n#define SYSCALL_DEFINEx(x, sname, ...)\t\\\n\tSYSCALL_METADATA(sname, x, __VA_ARGS__)\t\\\n\t__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)\n```","collapsed":false,"parent":184,"child":0,"next":245},{"ID":301,"CreatedAt":"2024-07-30T07:51:47.43Z","UpdatedAt":"2024-07-30T07:51:47.43Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/open.c#L1328\n\n```c\nstruct file *file_open_root(const struct path *root,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tstruct open_how how = build_open_how(flags, mode);\n\tint err = build_open_flags(&how, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(root, filename, &op);\n}\n```","collapsed":false,"last":198,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":285,"CreatedAt":"2024-07-29T02:26:01.285Z","UpdatedAt":"2024-07-29T02:50:03.213Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将用户空间的文件句柄复制到内核\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L183-L205\n\n```c\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\t...\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\t...\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}\n```","collapsed":false,"last":283,"child":0,"next":287}],[{"ID":0,"markdown":""},{"ID":182,"CreatedAt":"2023-09-12T02:17:00.904Z","UpdatedAt":"2023-09-12T02:17:00.904Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 4. overlayfs","collapsed":false,"last":181,"child":337,"next":183},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":337,"CreatedAt":"2024-07-31T09:09:51.514Z","UpdatedAt":"2024-07-31T09:09:51.514Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 4.1 ovl_decode_real_fh\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L154\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ofs->config.uuid ? !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t\t\t      !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":182,"child":307,"next":338},{"ID":307,"CreatedAt":"2024-07-30T09:13:34.453Z","UpdatedAt":"2024-07-31T09:10:00.705Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"#### 4.1.1 fh_to_dentry\n\n根据file handle 生成 dentry\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L873\n\n```c\nconst struct export_operations ovl_export_operations = {\n\t...\n\t.fh_to_dentry\t= ovl_fh_to_dentry,\n\t...\n};\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L822-L824\n\n```c\nstatic struct dentry *ovl_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\t...\n\tfh = ovl_fid_to_fh(fid, len, fh_type);\n\t...\n\tdentry = (flags & OVL_FH_FLAG_PATH_UPPER) ?\n\t\t ovl_upper_fh_to_d(sb, fh) :\n\t\t ovl_lower_fh_to_d(sb, fh);\n\t...\n}\n```","collapsed":false,"parent":337,"child":308,"next":315},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":308,"CreatedAt":"2024-07-30T09:15:28.747Z","UpdatedAt":"2024-07-30T09:15:28.747Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L690\n\n```c\nstatic struct dentry *ovl_upper_fh_to_d(struct super_block *sb,\n\t\t\t\t\tstruct ovl_fh *fh)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\tstruct dentry *dentry;\n\tstruct dentry *upper;\n\n\tif (!ovl_upper_mnt(ofs))\n\t\treturn ERR_PTR(-EACCES);\n\n\tupper = ovl_decode_real_fh(ofs, fh, ovl_upper_mnt(ofs), true);\n\tif (IS_ERR_OR_NULL(upper))\n\t\treturn upper;\n\n\tdentry = ovl_get_dentry(sb, upper, NULL, NULL);\n\tdput(upper);\n\n\treturn dentry;\n}\n```","collapsed":false,"parent":307,"child":310,"next":309},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":310,"CreatedAt":"2024-07-30T09:18:09.697Z","UpdatedAt":"2024-07-30T09:18:09.697Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L154\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ovl_origin_uuid(ofs) ?\n\t    !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t    !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":308,"child":0,"next":328},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":185,"CreatedAt":"2023-09-12T02:44:52.002Z","UpdatedAt":"2023-09-12T06:32:11.123Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 3.2 link (syscall)\n\n```c\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);\n}\n```","collapsed":false,"last":184,"child":0,"next":186},{"ID":245,"CreatedAt":"2023-10-07T07:12:33.079Z","UpdatedAt":"2023-10-09T09:28:52.777Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"文件名转 filename 结构体， 这两个 filename 结构体会在 do_linkat 函数结束前检查引用计数并被释放\n\n```c\nSYSCALL_DEFINE5(linkat, ..., const char __user *, oldname,\n        ..., const char __user *, newname, int, flags)\n{\n    return do_linkat(..., getname_uflags(oldname, flags),\n        ..., getname(newname), ...);\n}\n```","collapsed":false,"last":187,"child":248,"next":188},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":248,"CreatedAt":"2023-10-09T09:09:02.426Z","UpdatedAt":"2023-10-09T09:15:52.324Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"filename 结构体\n\n* name 是指向文件名的指针，文件名长度较短时指向 iname，长至4096时，指向一段4096的内存。\n* uptr 指向 用户空间的原始文件名\n* refcnt 是 filename结构体的引用计数，用来指示能否释放filename结构体\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L2308\n\n```c\nstruct filename {\n\tconst char\t\t*name;\t/* pointer to actual string */\n\tconst __user char\t*uptr;\t/* original userland pointer */\n\tint\t\t\trefcnt;\n\tstruct audit_names\t*aname;\n\tconst char\t\tiname[];\n};\n```","collapsed":false,"parent":245,"child":0,"next":193},{"ID":287,"CreatedAt":"2024-07-29T02:51:54.005Z","UpdatedAt":"2024-07-29T02:57:43.542Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"调用 do_handle_to_path 实现具体业务\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L207\n\n```c\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\t...\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}\n```","collapsed":false,"last":285,"child":288,"next":0},{"ID":288,"CreatedAt":"2024-07-29T02:52:33.854Z","UpdatedAt":"2024-07-30T07:36:33.176Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"根据参数 fd 获取挂载点，根据参数 handle 获取 dentry, 设置path->mnt, path->dentry\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L139C1-L165C2\n\n```c\nstatic int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n\tint retval = 0;\n\tint handle_dwords;\n\n\tpath->mnt = get_vfsmount_from_fd(mountdirfd);\n\tif (IS_ERR(path->mnt)) {\n\t\tretval = PTR_ERR(path->mnt);\n\t\tgoto out_err;\n\t}\n\t/* change the handle size to multiple of sizeof(u32) */\n\thandle_dwords = handle->handle_bytes >> 2;\n\tpath->dentry = exportfs_decode_fh(path->mnt,\n\t\t\t\t\t  (struct fid *)handle->f_handle,\n\t\t\t\t\t  handle_dwords, handle->handle_type,\n\t\t\t\t\t  vfs_dentry_acceptable, NULL);\n\tif (IS_ERR(path->dentry)) {\n\t\tretval = PTR_ERR(path->dentry);\n\t\tgoto out_mnt;\n\t}\n\treturn 0;\nout_mnt:\n\tmntput(path->mnt);\nout_err:\n\treturn retval;\n}\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L134\n\n```c\nstatic int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}\n```","collapsed":false,"parent":287,"child":291,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":291,"CreatedAt":"2024-07-29T03:45:23.339Z","UpdatedAt":"2024-07-30T07:34:44.941Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"根据 已有fd 获取挂载点， 设置 path->mnt\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L145\n\n```c\nstatic int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n    int retval = 0;\n    ...\n    path->mnt = get_vfsmount_from_fd(mountdirfd);\n    if (IS_ERR(path->mnt)) {\n    \tretval = PTR_ERR(path->mnt);\n    \tgoto out_err;\n    }\n    ...\n    return 0;\n...\nout_err:\n    return retval;\n}\n```","collapsed":false,"parent":288,"child":289,"next":292},{"ID":289,"CreatedAt":"2024-07-29T02:59:24.993Z","UpdatedAt":"2024-07-29T03:16:54.301Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"根据fd获得fd所属文件系统的挂载点\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L115\n\n```c\nstatic struct vfsmount *get_vfsmount_from_fd(int fd)\n{\n\tstruct vfsmount *mnt;\n\n\tif (fd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tspin_lock(&fs->lock);\n\t\tmnt = mntget(fs->pwd.mnt);\n\t\tspin_unlock(&fs->lock);\n\t} else {\n\t\tstruct fd f = fdget(fd);\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\t\tmnt = mntget(f.file->f_path.mnt);\n\t\tfdput(f);\n\t}\n\treturn mnt;\n}\n```","collapsed":false,"parent":291,"child":0,"next":0}],[{"ID":0,"markdown":""},{"ID":183,"CreatedAt":"2023-09-12T02:17:13.404Z","UpdatedAt":"2024-07-30T08:32:44.961Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"## 5. btrfs\n\nBTRFS_IOC_INO_PATHS ioctl 是 Btrfs 文件系统中的一个特殊命令，它用于将 inode 号转换为对应的文件路径。结合上文的分析，从inode到path，这是一个危险操作，需要CAP_DAC_READ_SEARCH.\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/btrfs/ioctl.c#L4599\n\n```c\nlong btrfs_ioctl(struct file *file, unsigned int\n\t\tcmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\t...\n\tcase BTRFS_IOC_INO_PATHS:\n\t\treturn btrfs_ioctl_ino_to_path(root, argp);\n\t...\n\t}\n}\n```","collapsed":false,"last":182,"child":302,"next":0},{"ID":302,"CreatedAt":"2024-07-30T08:43:19.607Z","UpdatedAt":"2024-07-30T08:43:19.607Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/btrfs/ioctl.c#L3308\n\n```c\nstatic long btrfs_ioctl_ino_to_path(struct btrfs_root *root, void __user *arg)\n{\n\tint ret = 0;\n\tint i;\n\tu64 rel_ptr;\n\tint size;\n\tstruct btrfs_ioctl_ino_path_args *ipa = NULL;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_path *path;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn -EPERM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tipa = memdup_user(arg, sizeof(*ipa));\n\tif (IS_ERR(ipa)) {\n\t\tret = PTR_ERR(ipa);\n\t\tipa = NULL;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, ipa->size, 4096);\n\tipath = init_ipath(size, root, path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto out;\n\t}\n\n\tret = paths_from_inode(ipa->inum, ipath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i) {\n\t\trel_ptr = ipath->fspath->val[i] -\n\t\t\t  (u64)(unsigned long)ipath->fspath->val;\n\t\tipath->fspath->val[i] = rel_ptr;\n\t}\n\n\tbtrfs_free_path(path);\n\tpath = NULL;\n\tret = copy_to_user((void __user *)(unsigned long)ipa->fspath,\n\t\t\t   ipath->fspath, size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tfree_ipath(ipath);\n\tkfree(ipa);\n\n\treturn ret;\n}\n```","collapsed":false,"parent":183,"child":304,"next":0},{"ID":304,"CreatedAt":"2024-07-30T08:55:28.273Z","UpdatedAt":"2024-07-30T08:55:28.273Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/kernel/capability.c#L434\n\n```c\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}\n```","collapsed":false,"parent":302,"child":0,"next":303},{"ID":338,"CreatedAt":"2024-07-31T09:11:15.188Z","UpdatedAt":"2024-07-31T09:11:15.188Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 4.2 ovl_can_decode_fh\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/util.c#L52\n\n```c\n/*\n * Check if underlying fs supports file handles and try to determine encoding\n * type, in order to deduce maximum inode number used by fs.\n *\n * Return 0 if file handles are not supported.\n * Return 1 (FILEID_INO32_GEN) if fs uses the default 32bit inode encoding.\n * Return -1 if fs uses a non default encoding with unknown inode size.\n */\nint ovl_can_decode_fh(struct super_block *sb)\n{\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn 0;\n\n\tif (!sb->s_export_op || !sb->s_export_op->fh_to_dentry)\n\t\treturn 0;\n\n\treturn sb->s_export_op->encode_fh ? -1 : FILEID_INO32_GEN;\n}\n\n```","collapsed":false,"last":337,"child":0,"next":0},{"ID":315,"CreatedAt":"2024-07-31T03:12:16.639Z","UpdatedAt":"2024-07-31T09:10:06.319Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"#### 4.1.2 ovl_lookup\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/dir.c#L1299\n\n```c\nconst struct inode_operations ovl_dir_inode_operations = {\n\t.lookup\t\t= ovl_lookup,\n\t...\n}\n```","collapsed":false,"last":307,"child":316,"next":320},{"ID":316,"CreatedAt":"2024-07-31T03:13:18.585Z","UpdatedAt":"2024-07-31T03:13:18.585Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L830\n\n```c\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags)\n{\n\tstruct ovl_entry *oe;\n\tconst struct cred *old_cred;\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *poe = dentry->d_parent->d_fsdata;\n\tstruct ovl_entry *roe = dentry->d_sb->s_root->d_fsdata;\n\tstruct ovl_path *stack = NULL, *origin_path = NULL;\n\tstruct dentry *upperdir, *upperdentry = NULL;\n\tstruct dentry *origin = NULL;\n\tstruct dentry *index = NULL;\n\tunsigned int ctr = 0;\n\tstruct inode *inode = NULL;\n\tbool upperopaque = false;\n\tchar *upperredirect = NULL;\n\tstruct dentry *this;\n\tunsigned int i;\n\tint err;\n\tbool uppermetacopy = false;\n\tstruct ovl_lookup_data d = {\n\t\t.sb = dentry->d_sb,\n\t\t.name = dentry->d_name,\n\t\t.is_dir = false,\n\t\t.opaque = false,\n\t\t.stop = false,\n\t\t.last = ofs->config.redirect_follow ? false : !poe->numlower,\n\t\t.redirect = NULL,\n\t\t.metacopy = false,\n\t};\n\n\tif (dentry->d_name.len > ofs->namelen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tupperdir = ovl_dentry_upper(dentry->d_parent);\n\tif (upperdir) {\n\t\td.mnt = ovl_upper_mnt(ofs);\n\t\terr = ovl_lookup_layer(upperdir, &d, &upperdentry, true);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (upperdentry && upperdentry->d_flags & DCACHE_OP_REAL) {\n\t\t\tdput(upperdentry);\n\t\t\terr = -EREMOTE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (upperdentry && !d.is_dir) {\n\t\t\t/*\n\t\t\t * Lookup copy up origin by decoding origin file handle.\n\t\t\t * We may get a disconnected dentry, which is fine,\n\t\t\t * because we only need to hold the origin inode in\n\t\t\t * cache and use its inode number.  We may even get a\n\t\t\t * connected dentry, that is not under any of the lower\n\t\t\t * layers root.  That is also fine for using it's inode\n\t\t\t * number - it's the same as if we held a reference\n\t\t\t * to a dentry in lower layer that was moved under us.\n\t\t\t */\n\t\t\terr = ovl_check_origin(ofs, upperdentry, &origin_path);\n\t\t\tif (err)\n\t\t\t\tgoto out_put_upper;\n\n\t\t\tif (d.metacopy)\n\t\t\t\tuppermetacopy = true;\n\t\t}\n\n\t\tif (d.redirect) {\n\t\t\terr = -ENOMEM;\n\t\t\tupperredirect = kstrdup(d.redirect, GFP_KERNEL);\n\t\t\tif (!upperredirect)\n\t\t\t\tgoto out_put_upper;\n\t\t\tif (d.redirect[0] == '/')\n\t\t\t\tpoe = roe;\n\t\t}\n\t\tupperopaque = d.opaque;\n\t}\n\n\tif (!d.stop && poe->numlower) {\n\t\terr = -ENOMEM;\n\t\tstack = kcalloc(ofs->numlayer - 1, sizeof(struct ovl_path),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!stack)\n\t\t\tgoto out_put_upper;\n\t}\n\n\tfor (i = 0; !d.stop && i < poe->numlower; i++) {\n\t\tstruct ovl_path lower = poe->lowerstack[i];\n\n\t\tif (!ofs->config.redirect_follow)\n\t\t\td.last = i == poe->numlower - 1;\n\t\telse\n\t\t\td.last = lower.layer->idx == roe->numlower;\n\n\t\td.mnt = lower.layer->mnt;\n\t\terr = ovl_lookup_layer(lower.dentry, &d, &this, false);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (!this)\n\t\t\tcontinue;\n\n\t\tif ((uppermetacopy || d.metacopy) && !ofs->config.metacopy) {\n\t\t\tdput(this);\n\t\t\terr = -EPERM;\n\t\t\tpr_warn_ratelimited(\"refusing to follow metacopy origin for (%pd2)\\n\", dentry);\n\t\t\tgoto out_put;\n\t\t}\n\n\t\t/*\n\t\t * If no origin fh is stored in upper of a merge dir, store fh\n\t\t * of lower dir and set upper parent \"impure\".\n\t\t */\n\t\tif (upperdentry && !ctr && !ofs->noxattr && d.is_dir) {\n\t\t\terr = ovl_fix_origin(ofs, dentry, this, upperdentry);\n\t\t\tif (err) {\n\t\t\t\tdput(this);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * When \"verify_lower\" feature is enabled, do not merge with a\n\t\t * lower dir that does not match a stored origin xattr. In any\n\t\t * case, only verified origin is used for index lookup.\n\t\t *\n\t\t * For non-dir dentry, if index=on, then ensure origin\n\t\t * matches the dentry found using path based lookup,\n\t\t * otherwise error out.\n\t\t */\n\t\tif (upperdentry && !ctr &&\n\t\t    ((d.is_dir && ovl_verify_lower(dentry->d_sb)) ||\n\t\t     (!d.is_dir && ofs->config.index && origin_path))) {\n\t\t\terr = ovl_verify_origin(ofs, upperdentry, this, false);\n\t\t\tif (err) {\n\t\t\t\tdput(this);\n\t\t\t\tif (d.is_dir)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\torigin = this;\n\t\t}\n\n\t\tif (d.metacopy && ctr) {\n\t\t\t/*\n\t\t\t * Do not store intermediate metacopy dentries in\n\t\t\t * lower chain, except top most lower metacopy dentry.\n\t\t\t * Continue the loop so that if there is an absolute\n\t\t\t * redirect on this dentry, poe can be reset to roe.\n\t\t\t */\n\t\t\tdput(this);\n\t\t\tthis = NULL;\n\t\t} else {\n\t\t\tstack[ctr].dentry = this;\n\t\t\tstack[ctr].layer = lower.layer;\n\t\t\tctr++;\n\t\t}\n\n\t\t/*\n\t\t * Following redirects can have security consequences: it's like\n\t\t * a symlink into the lower layer without the permission checks.\n\t\t * This is only a problem if the upper layer is untrusted (e.g\n\t\t * comes from an USB drive).  This can allow a non-readable file\n\t\t * or directory to become readable.\n\t\t *\n\t\t * Only following redirects when redirects are enabled disables\n\t\t * this attack vector when not necessary.\n\t\t */\n\t\terr = -EPERM;\n\t\tif (d.redirect && !ofs->config.redirect_follow) {\n\t\t\tpr_warn_ratelimited(\"refusing to follow redirect for (%pd2)\\n\",\n\t\t\t\t\t    dentry);\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tif (d.stop)\n\t\t\tbreak;\n\n\t\tif (d.redirect && d.redirect[0] == '/' && poe != roe) {\n\t\t\tpoe = roe;\n\t\t\t/* Find the current layer on the root dentry */\n\t\t\ti = lower.layer->idx - 1;\n\t\t}\n\t}\n\n\t/*\n\t * For regular non-metacopy upper dentries, there is no lower\n\t * path based lookup, hence ctr will be zero. If a dentry is found\n\t * using ORIGIN xattr on upper, install it in stack.\n\t *\n\t * For metacopy dentry, path based lookup will find lower dentries.\n\t * Just make sure a corresponding data dentry has been found.\n\t */\n\tif (d.metacopy || (uppermetacopy && !ctr)) {\n\t\tpr_warn_ratelimited(\"metacopy with no lower data found - abort lookup (%pd2)\\n\",\n\t\t\t\t    dentry);\n\t\terr = -EIO;\n\t\tgoto out_put;\n\t} else if (!d.is_dir && upperdentry && !ctr && origin_path) {\n\t\tif (WARN_ON(stack != NULL)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_put;\n\t\t}\n\t\tstack = origin_path;\n\t\tctr = 1;\n\t\torigin = origin_path->dentry;\n\t\torigin_path = NULL;\n\t}\n\n\t/*\n\t * Always lookup index if there is no-upperdentry.\n\t *\n\t * For the case of upperdentry, we have set origin by now if it\n\t * needed to be set. There are basically three cases.\n\t *\n\t * For directories, lookup index by lower inode and verify it matches\n\t * upper inode. We only trust dir index if we verified that lower dir\n\t * matches origin, otherwise dir index entries may be inconsistent\n\t * and we ignore them.\n\t *\n\t * For regular upper, we already set origin if upper had ORIGIN\n\t * xattr. There is no verification though as there is no path\n\t * based dentry lookup in lower in this case.\n\t *\n\t * For metacopy upper, we set a verified origin already if index\n\t * is enabled and if upper had an ORIGIN xattr.\n\t *\n\t */\n\tif (!upperdentry && ctr)\n\t\torigin = stack[0].dentry;\n\n\tif (origin && ovl_indexdir(dentry->d_sb) &&\n\t    (!d.is_dir || ovl_index_all(dentry->d_sb))) {\n\t\tindex = ovl_lookup_index(ofs, upperdentry, origin, true);\n\t\tif (IS_ERR(index)) {\n\t\t\terr = PTR_ERR(index);\n\t\t\tindex = NULL;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\toe = ovl_alloc_entry(ctr);\n\terr = -ENOMEM;\n\tif (!oe)\n\t\tgoto out_put;\n\n\tmemcpy(oe->lowerstack, stack, sizeof(struct ovl_path) * ctr);\n\tdentry->d_fsdata = oe;\n\n\tif (upperopaque)\n\t\tovl_dentry_set_opaque(dentry);\n\n\tif (upperdentry)\n\t\tovl_dentry_set_upper_alias(dentry);\n\telse if (index) {\n\t\tstruct path upperpath = {\n\t\t\t.dentry = upperdentry = dget(index),\n\t\t\t.mnt = ovl_upper_mnt(ofs),\n\t\t};\n\n\t\t/*\n\t\t * It's safe to assign upperredirect here: the previous\n\t\t * assignment of happens only if upperdentry is non-NULL, and\n\t\t * this one only if upperdentry is NULL.\n\t\t */\n\t\tupperredirect = ovl_get_redirect_xattr(ofs, &upperpath, 0);\n\t\tif (IS_ERR(upperredirect)) {\n\t\t\terr = PTR_ERR(upperredirect);\n\t\t\tupperredirect = NULL;\n\t\t\tgoto out_free_oe;\n\t\t}\n\t\terr = ovl_check_metacopy_xattr(ofs, &upperpath);\n\t\tif (err < 0)\n\t\t\tgoto out_free_oe;\n\t\tuppermetacopy = err;\n\t}\n\n\tif (upperdentry || ctr) {\n\t\tstruct ovl_inode_params oip = {\n\t\t\t.upperdentry = upperdentry,\n\t\t\t.lowerpath = stack,\n\t\t\t.index = index,\n\t\t\t.numlower = ctr,\n\t\t\t.redirect = upperredirect,\n\t\t\t.lowerdata = (ctr > 1 && !d.is_dir) ?\n\t\t\t\t      stack[ctr - 1].dentry : NULL,\n\t\t};\n\n\t\tinode = ovl_get_inode(dentry->d_sb, &oip);\n\t\terr = PTR_ERR(inode);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto out_free_oe;\n\t\tif (upperdentry && !uppermetacopy)\n\t\t\tovl_set_flag(OVL_UPPERDATA, inode);\n\t}\n\n\tovl_dentry_update_reval(dentry, upperdentry,\n\t\t\tDCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE);\n\n\trevert_creds(old_cred);\n\tif (origin_path) {\n\t\tdput(origin_path->dentry);\n\t\tkfree(origin_path);\n\t}\n\tdput(index);\n\tkfree(stack);\n\tkfree(d.redirect);\n\treturn d_splice_alias(inode, dentry);\n\nout_free_oe:\n\tdentry->d_fsdata = NULL;\n\tkfree(oe);\nout_put:\n\tdput(index);\n\tfor (i = 0; i < ctr; i++)\n\t\tdput(stack[i].dentry);\n\tkfree(stack);\nout_put_upper:\n\tif (origin_path) {\n\t\tdput(origin_path->dentry);\n\t\tkfree(origin_path);\n\t}\n\tdput(upperdentry);\n\tkfree(upperredirect);\nout:\n\tkfree(d.redirect);\n\trevert_creds(old_cred);\n\treturn ERR_PTR(err);\n}\n```","collapsed":false,"parent":315,"child":317,"next":0},{"ID":0,"markdown":""},{"ID":317,"CreatedAt":"2024-07-31T03:17:23.106Z","UpdatedAt":"2024-07-31T03:17:23.106Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L404\n\n```c\nstatic int ovl_check_origin(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t\t    struct ovl_path **stackp)\n{\n\tstruct ovl_fh *fh = ovl_get_fh(ofs, upperdentry, OVL_XATTR_ORIGIN);\n\tint err;\n\n\tif (IS_ERR_OR_NULL(fh))\n\t\treturn PTR_ERR(fh);\n\n\terr = ovl_check_origin_fh(ofs, fh, false, upperdentry, stackp);\n\tkfree(fh);\n\n\tif (err) {\n\t\tif (err == -ESTALE)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n```","collapsed":false,"parent":316,"child":318,"next":323},{"ID":318,"CreatedAt":"2024-07-31T03:18:16.8Z","UpdatedAt":"2024-07-31T03:18:16.8Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L353\n\n```c\nint ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,\n\t\t\tstruct dentry *upperdentry, struct ovl_path **stackp)\n{\n\tstruct dentry *origin = NULL;\n\tint i;\n\n\tfor (i = 1; i < ofs->numlayer; i++) {\n\t\t/*\n\t\t * If lower fs uuid is not unique among lower fs we cannot match\n\t\t * fh->uuid to layer.\n\t\t */\n\t\tif (ofs->layers[i].fsid &&\n\t\t    ofs->layers[i].fs->bad_uuid)\n\t\t\tcontinue;\n\n\t\torigin = ovl_decode_real_fh(ofs, fh, ofs->layers[i].mnt,\n\t\t\t\t\t    connected);\n\t\tif (origin)\n\t\t\tbreak;\n\t}\n\n\tif (!origin)\n\t\treturn -ESTALE;\n\telse if (IS_ERR(origin))\n\t\treturn PTR_ERR(origin);\n\n\tif (upperdentry && !ovl_is_whiteout(upperdentry) &&\n\t    inode_wrong_type(d_inode(upperdentry), d_inode(origin)->i_mode))\n\t\tgoto invalid;\n\n\tif (!*stackp)\n\t\t*stackp = kmalloc(sizeof(struct ovl_path), GFP_KERNEL);\n\tif (!*stackp) {\n\t\tdput(origin);\n\t\treturn -ENOMEM;\n\t}\n\t**stackp = (struct ovl_path){\n\t\t.dentry = origin,\n\t\t.layer = &ofs->layers[i]\n\t};\n\n\treturn 0;\n\ninvalid:\n\tpr_warn_ratelimited(\"invalid origin (%pd2, ftype=%x, origin ftype=%x).\\n\",\n\t\t\t    upperdentry, d_inode(upperdentry)->i_mode & S_IFMT,\n\t\t\t    d_inode(origin)->i_mode & S_IFMT);\n\tdput(origin);\n\treturn -ESTALE;\n}\n```","collapsed":false,"parent":317,"child":319,"next":0},{"ID":319,"CreatedAt":"2024-07-31T03:19:29.916Z","UpdatedAt":"2024-07-31T03:19:29.916Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L154\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ofs->config.uuid ? !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t\t\t      !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":318,"child":0,"next":0},{"ID":309,"CreatedAt":"2024-07-30T09:16:14.037Z","UpdatedAt":"2024-07-30T09:16:14.037Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L700\n\n```c\nstatic struct dentry *ovl_lower_fh_to_d(struct super_block *sb,\n\t\t\t\t\tstruct ovl_fh *fh)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\tstruct ovl_path origin = { };\n\tstruct ovl_path *stack = &origin;\n\tstruct dentry *dentry = NULL;\n\tstruct dentry *index = NULL;\n\tstruct inode *inode;\n\tint err;\n\n\t/* First lookup overlay inode in inode cache by origin fh */\n\terr = ovl_check_origin_fh(ofs, fh, false, NULL, &stack);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (!d_is_dir(origin.dentry) ||\n\t    !(origin.dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tinode = ovl_lookup_inode(sb, origin.dentry, false);\n\t\terr = PTR_ERR(inode);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto out_err;\n\t\tif (inode) {\n\t\t\tdentry = d_find_any_alias(inode);\n\t\t\tiput(inode);\n\t\t\tif (dentry)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Then lookup indexed upper/whiteout by origin fh */\n\tif (ofs->indexdir) {\n\t\tindex = ovl_get_index_fh(ofs, fh);\n\t\terr = PTR_ERR(index);\n\t\tif (IS_ERR(index)) {\n\t\t\tindex = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t/* Then try to get a connected upper dir by index */\n\tif (index && d_is_dir(index)) {\n\t\tstruct dentry *upper = ovl_index_upper(ofs, index, true);\n\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR_OR_NULL(upper))\n\t\t\tgoto out_err;\n\n\t\tdentry = ovl_get_dentry(sb, upper, NULL, NULL);\n\t\tdput(upper);\n\t\tgoto out;\n\t}\n\n\t/* Find origin.dentry again with ovl_acceptable() layer check */\n\tif (d_is_dir(origin.dentry)) {\n\t\tdput(origin.dentry);\n\t\torigin.dentry = NULL;\n\t\terr = ovl_check_origin_fh(ofs, fh, true, NULL, &stack);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\tif (index) {\n\t\terr = ovl_verify_origin(ofs, index, origin.dentry, false);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\t/* Get a connected non-upper dir or disconnected non-dir */\n\tdentry = ovl_get_dentry(sb, NULL, &origin, index);\n\nout:\n\tdput(origin.dentry);\n\tdput(index);\n\treturn dentry;\n\nout_err:\n\tdentry = ERR_PTR(err);\n\tgoto out;\n}\n\n```","collapsed":false,"last":308,"child":311,"next":0},{"ID":311,"CreatedAt":"2024-07-30T09:24:00.434Z","UpdatedAt":"2024-07-30T09:24:00.434Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L353\n\n```c\nint ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,\n\t\t\tstruct dentry *upperdentry, struct ovl_path **stackp)\n{\n\tstruct dentry *origin = NULL;\n\tint i;\n\n\tfor (i = 1; i < ofs->numlayer; i++) {\n\t\t/*\n\t\t * If lower fs uuid is not unique among lower fs we cannot match\n\t\t * fh->uuid to layer.\n\t\t */\n\t\tif (ofs->layers[i].fsid &&\n\t\t    ofs->layers[i].fs->bad_uuid)\n\t\t\tcontinue;\n\n\t\torigin = ovl_decode_real_fh(ofs, fh, ofs->layers[i].mnt,\n\t\t\t\t\t    connected);\n\t\tif (origin)\n\t\t\tbreak;\n\t}\n\n\tif (!origin)\n\t\treturn -ESTALE;\n\telse if (IS_ERR(origin))\n\t\treturn PTR_ERR(origin);\n\n\tif (upperdentry && !ovl_is_whiteout(upperdentry) &&\n\t    inode_wrong_type(d_inode(upperdentry), d_inode(origin)->i_mode))\n\t\tgoto invalid;\n\n\tif (!*stackp)\n\t\t*stackp = kmalloc(sizeof(struct ovl_path), GFP_KERNEL);\n\tif (!*stackp) {\n\t\tdput(origin);\n\t\treturn -ENOMEM;\n\t}\n\t**stackp = (struct ovl_path){\n\t\t.dentry = origin,\n\t\t.layer = &ofs->layers[i]\n\t};\n\n\treturn 0;\n\ninvalid:\n\tpr_warn_ratelimited(\"invalid origin (%pd2, ftype=%x, origin ftype=%x).\\n\",\n\t\t\t    upperdentry, d_inode(upperdentry)->i_mode & S_IFMT,\n\t\t\t    d_inode(origin)->i_mode & S_IFMT);\n\tdput(origin);\n\treturn -ESTALE;\n}\n```","collapsed":false,"parent":309,"child":312,"next":313},{"ID":312,"CreatedAt":"2024-07-30T09:24:18.918Z","UpdatedAt":"2024-07-30T09:24:18.918Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L154\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ovl_origin_uuid(ofs) ?\n\t    !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t    !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":311,"child":0,"next":0},{"ID":328,"CreatedAt":"2024-07-31T08:48:02.791Z","UpdatedAt":"2024-07-31T08:48:02.791Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L653\n\n```c\n/*\n * Get an overlay dentry from upper/lower real dentries and index.\n */\nstatic struct dentry *ovl_get_dentry(struct super_block *sb,\n\t\t\t\t     struct dentry *upper,\n\t\t\t\t     struct ovl_path *lowerpath,\n\t\t\t\t     struct dentry *index)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\tconst struct ovl_layer *layer = upper ? &ofs->layers[0] : lowerpath->layer;\n\tstruct dentry *real = upper ?: (index ?: lowerpath->dentry);\n\n\t/*\n\t * Obtain a disconnected overlay dentry from a non-dir real dentry\n\t * and index.\n\t */\n\tif (!d_is_dir(real))\n\t\treturn ovl_obtain_alias(sb, upper, lowerpath, index);\n\n\t/* Removed empty directory? */\n\tif ((real->d_flags & DCACHE_DISCONNECTED) || d_unhashed(real))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * If real dentry is connected and hashed, get a connected overlay\n\t * dentry whose real dentry is @real.\n\t */\n\treturn ovl_lookup_real(sb, real, layer);\n}\n```","collapsed":false,"last":310,"child":329,"next":0},{"ID":329,"CreatedAt":"2024-07-31T08:50:07Z","UpdatedAt":"2024-07-31T08:50:07Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L551\n\n```c\n/*\n * Lookup a connected overlay dentry whose real dentry is @real.\n * If @real is on upper layer, we lookup a child overlay dentry with the same\n * path the real dentry. Otherwise, we need to consult index for lookup.\n */\nstatic struct dentry *ovl_lookup_real(struct super_block *sb,\n\t\t\t\t      struct dentry *real,\n\t\t\t\t      const struct ovl_layer *layer)\n{\n\tstruct dentry *connected;\n\tint err = 0;\n\n\tconnected = ovl_lookup_real_ancestor(sb, real, layer);\n\tif (IS_ERR(connected))\n\t\treturn connected;\n\n\twhile (!err) {\n\t\tstruct dentry *next, *this;\n\t\tstruct dentry *parent = NULL;\n\t\tstruct dentry *real_connected = ovl_dentry_real_at(connected,\n\t\t\t\t\t\t\t\t   layer->idx);\n\n\t\tif (real_connected == real)\n\t\t\tbreak;\n\n\t\t/* Find the topmost dentry not yet connected */\n\t\tnext = dget(real);\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\tif (parent == real_connected)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If real has been moved out of 'real_connected',\n\t\t\t * we will not find 'real_connected' and hit the layer\n\t\t\t * root. In that case, we need to restart connecting.\n\t\t\t * This game can go on forever in the worst case. We\n\t\t\t * may want to consider taking s_vfs_rename_mutex if\n\t\t\t * this happens more than once.\n\t\t\t */\n\t\t\tif (parent == layer->mnt->mnt_root) {\n\t\t\t\tdput(connected);\n\t\t\t\tconnected = dget(sb->s_root);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If real file has been moved out of the layer root\n\t\t\t * directory, we will eventully hit the real fs root.\n\t\t\t * This cannot happen by legit overlay rename, so we\n\t\t\t * return error in that case.\n\t\t\t */\n\t\t\tif (parent == next) {\n\t\t\t\terr = -EXDEV;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tif (!err) {\n\t\t\tthis = ovl_lookup_real_one(connected, next, layer);\n\t\t\tif (IS_ERR(this))\n\t\t\t\terr = PTR_ERR(this);\n\n\t\t\t/*\n\t\t\t * Lookup of child in overlay can fail when racing with\n\t\t\t * overlay rename of child away from 'connected' parent.\n\t\t\t * In this case, we need to restart the lookup from the\n\t\t\t * top, because we cannot trust that 'real_connected' is\n\t\t\t * still an ancestor of 'real'. There is a good chance\n\t\t\t * that the renamed overlay ancestor is now in cache, so\n\t\t\t * ovl_lookup_real_ancestor() will find it and we can\n\t\t\t * continue to connect exactly from where lookup failed.\n\t\t\t */\n\t\t\tif (err == -ECHILD) {\n\t\t\t\tthis = ovl_lookup_real_ancestor(sb, real,\n\t\t\t\t\t\t\t\tlayer);\n\t\t\t\terr = PTR_ERR_OR_ZERO(this);\n\t\t\t}\n\t\t\tif (!err) {\n\t\t\t\tdput(connected);\n\t\t\t\tconnected = this;\n\t\t\t}\n\t\t}\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\tif (err)\n\t\tgoto fail;\n\n\treturn connected;\n\nfail:\n\tpr_warn_ratelimited(\"failed to lookup by real (%pd2, layer=%d, connected=%pd2, err=%i)\\n\",\n\t\t\t    real, layer->idx, connected, err);\n\tdput(connected);\n\treturn ERR_PTR(err);\n}\n```","collapsed":false,"parent":328,"child":330,"next":0},{"ID":330,"CreatedAt":"2024-07-31T08:50:49.147Z","UpdatedAt":"2024-07-31T08:50:49.147Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L498\n\n```c\n/*\n * Lookup an indexed or hashed overlay dentry, whose real dentry is an\n * ancestor of @real.\n */\nstatic struct dentry *ovl_lookup_real_ancestor(struct super_block *sb,\n\t\t\t\t\t       struct dentry *real,\n\t\t\t\t\t       const struct ovl_layer *layer)\n{\n\tstruct dentry *next, *parent = NULL;\n\tstruct dentry *ancestor = ERR_PTR(-EIO);\n\n\tif (real == layer->mnt->mnt_root)\n\t\treturn dget(sb->s_root);\n\n\t/* Find the topmost indexed or hashed ancestor */\n\tnext = dget(real);\n\tfor (;;) {\n\t\tparent = dget_parent(next);\n\n\t\t/*\n\t\t * Lookup a matching overlay dentry in inode/dentry\n\t\t * cache or in index by real inode.\n\t\t */\n\t\tancestor = ovl_lookup_real_inode(sb, next, layer);\n\t\tif (ancestor)\n\t\t\tbreak;\n\n\t\tif (parent == layer->mnt->mnt_root) {\n\t\t\tancestor = dget(sb->s_root);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If @real has been moved out of the layer root directory,\n\t\t * we will eventully hit the real fs root. This cannot happen\n\t\t * by legit overlay rename, so we return error in that case.\n\t\t */\n\t\tif (parent == next) {\n\t\t\tancestor = ERR_PTR(-EXDEV);\n\t\t\tbreak;\n\t\t}\n\n\t\tdput(next);\n\t\tnext = parent;\n\t}\n\n\tdput(parent);\n\tdput(next);\n\n\treturn ancestor;\n}\n```","collapsed":false,"parent":329,"child":331,"next":0},{"ID":331,"CreatedAt":"2024-07-31T08:51:42.763Z","UpdatedAt":"2024-07-31T08:51:42.763Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/export.c#L433\n\n```c\n/*\n * Lookup an indexed or hashed overlay dentry by real inode.\n */\nstatic struct dentry *ovl_lookup_real_inode(struct super_block *sb,\n\t\t\t\t\t    struct dentry *real,\n\t\t\t\t\t    const struct ovl_layer *layer)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\tstruct dentry *index = NULL;\n\tstruct dentry *this = NULL;\n\tstruct inode *inode;\n\n\t/*\n\t * Decoding upper dir from index is expensive, so first try to lookup\n\t * overlay dentry in inode/dcache.\n\t */\n\tinode = ovl_lookup_inode(sb, real, !layer->idx);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (inode) {\n\t\tthis = d_find_any_alias(inode);\n\t\tiput(inode);\n\t}\n\n\t/*\n\t * For decoded lower dir file handle, lookup index by origin to check\n\t * if lower dir was copied up and and/or removed.\n\t */\n\tif (!this && layer->idx && ofs->indexdir && !WARN_ON(!d_is_dir(real))) {\n\t\tindex = ovl_lookup_index(ofs, NULL, real, false);\n\t\tif (IS_ERR(index))\n\t\t\treturn index;\n\t}\n\n\t/* Get connected upper overlay dir from index */\n\tif (index) {\n\t\tstruct dentry *upper = ovl_index_upper(ofs, index, true);\n\n\t\tdput(index);\n\t\tif (IS_ERR_OR_NULL(upper))\n\t\t\treturn upper;\n\n\t\t/*\n\t\t * ovl_lookup_real() in lower layer may call recursively once to\n\t\t * ovl_lookup_real() in upper layer. The first level call walks\n\t\t * back lower parents to the topmost indexed parent. The second\n\t\t * recursive call walks back from indexed upper to the topmost\n\t\t * connected/hashed upper parent (or up to root).\n\t\t */\n\t\tthis = ovl_lookup_real(sb, upper, &ofs->layers[0]);\n\t\tdput(upper);\n\t}\n\n\tif (IS_ERR_OR_NULL(this))\n\t\treturn this;\n\n\tif (ovl_dentry_real_at(this, layer->idx) != real) {\n\t\tdput(this);\n\t\tthis = ERR_PTR(-EIO);\n\t}\n\n\treturn this;\n}\n```","collapsed":false,"parent":330,"child":332,"next":0},{"ID":332,"CreatedAt":"2024-07-31T08:52:45.137Z","UpdatedAt":"2024-07-31T08:52:45.137Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/master/fs/overlayfs/namei.c#L570\n\n```c\n/* Get upper dentry from index */\nstruct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index,\n\t\t\t       bool connected)\n{\n\tstruct ovl_fh *fh;\n\tstruct dentry *upper;\n\n\tif (!d_is_dir(index))\n\t\treturn dget(index);\n\n\tfh = ovl_get_fh(ofs, index, OVL_XATTR_UPPER);\n\tif (IS_ERR_OR_NULL(fh))\n\t\treturn ERR_CAST(fh);\n\n\tupper = ovl_decode_real_fh(ofs, fh, ovl_upper_mnt(ofs), connected);\n\tkfree(fh);\n\n\tif (IS_ERR_OR_NULL(upper))\n\t\treturn upper ?: ERR_PTR(-ESTALE);\n\n\tif (!d_is_dir(upper)) {\n\t\tpr_warn_ratelimited(\"invalid index upper (%pd2, upper=%pd2).\\n\",\n\t\t\t\t    index, upper);\n\t\tdput(upper);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn upper;\n}\n\n```","collapsed":false,"parent":331,"child":333,"next":0},{"ID":333,"CreatedAt":"2024-07-31T08:53:37.749Z","UpdatedAt":"2024-07-31T08:53:37.749Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/master/fs/overlayfs/namei.c#L161\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ofs->config.uuid ? !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t\t\t      !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":332,"child":0,"next":0},{"ID":186,"CreatedAt":"2023-09-12T02:48:41.528Z","UpdatedAt":"2023-10-07T07:01:09.971Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"### 3.3 io_linkat(io_uring)\n\n```c\nint io_linkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_link *lnk = io_kiocb_to_cmd(req, struct io_link);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_linkat(lnk->old_dfd, lnk->oldpath, lnk->new_dfd,\n\t\t\t\tlnk->newpath, lnk->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n```","collapsed":false,"last":185,"child":0,"next":0},{"ID":188,"CreatedAt":"2023-09-12T02:49:23.804Z","UpdatedAt":"2023-10-07T07:19:19.769Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"#### do_linkat\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4623\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {\n\t\terror = -EINVAL;\n\t\tgoto out_putnames;\n\t}\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH && !capable(CAP_DAC_READ_SEARCH)) {\n\t\terror = -ENOENT;\n\t\tgoto out_putnames;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = filename_lookup(olddfd, old, how, &old_path, NULL);\n\tif (error)\n\t\tgoto out_putnames;\n\n\tnew_dentry = filename_create(newdfd, new, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out_putpath;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\tidmap = mnt_idmap(new_path.mnt);\n\terror = may_linkat(idmap, &old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,\n\t\t\t new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putpath:\n\tpath_put(&old_path);\nout_putnames:\n\tputname(old);\n\tputname(new);\n\n\treturn error;\n}\n```","collapsed":false,"last":245,"child":250,"next":0},{"ID":250,"CreatedAt":"2023-10-09T09:45:32.448Z","UpdatedAt":"2024-07-30T08:04:12.26Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"内存管理\n\n整个函数只有一个return语句。\n\n* 返回前必须经过 `goto out_putnames` 释放 filename 结构体; \n* 涉及path的，返回或 `goto retry` 前 `goto out_putpath` 释放 old_path\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n          struct filename *new, int flags)\n{\n    ...\n    int error;\n    if (...) {\n        ...\n        goto out_putnames;\n    }\n    if (...) {\n        ...\n        goto out_putnames;\n    }\n\nretry:\n    ...\n    if (...)\n        goto out_putnames;\n    ...\n    if (...)\n        goto out_putpath;\n    ...\n    if (...)\n        goto out_dput;\n    ...\n    if (...)\n        goto out_dput;\n    ...\n    if (...)\n        goto out_dput;\n    ...\nout_dput:\n    ...\n    if (...) {\n        ...\n        if (...) {\n            path_put(&old_path);\n            goto retry;\n        }\n    }\n    if (...) {\n        path_put(&old_path);\n        ...\n        goto retry;\n    }\nout_putpath:\n    path_put(&old_path);\nout_putnames:\n    putname(old);\n    putname(new);\n\n    return error;\n}\n```","collapsed":false,"parent":188,"child":251,"next":261},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":251,"CreatedAt":"2023-10-11T06:47:12.64Z","UpdatedAt":"2023-10-11T06:50:10.699Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`putname()` 用于处理 struct filename 结构体的资源释放。\n\n前面调用系统调用时，将用户传入的文件名转为了filename结构体; 这里在系统调用结束时，释放结构体。\n\n释放时校验了引用计数，释放前 `refcnt--`\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L259\n\n```c\nvoid putname(struct filename *name)\n{\n\tif (IS_ERR(name))\n\t\treturn;\n\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}\nEXPORT_SYMBOL(putname);\n```","collapsed":false,"parent":250,"child":252,"next":253},{"ID":252,"CreatedAt":"2023-10-11T06:50:03.647Z","UpdatedAt":"2023-10-11T06:50:03.647Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L2389\n\n```c\n#define __putname(name)\tkmem_cache_free(names_cachep, (void *)(name))\n```","collapsed":false,"parent":251,"child":0,"next":0},{"ID":193,"CreatedAt":"2023-09-12T03:57:23.355Z","UpdatedAt":"2023-10-07T07:31:03.545Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将用户传入的原始文件的文件名转换为filename结构体，涉及flags。\n\n```c\ngetname_uflags(oldname, flags)\n```\n\nuflags 标志中只取 `AT_EMPTY_PATH`。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L208\n\n```c\nstruct filename *\ngetname_uflags(const char __user *filename, int uflags)\n{\n\tint flags = (uflags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;\n\n\treturn getname_flags(filename, flags, NULL);\n}\n```","collapsed":false,"last":248,"child":194,"next":244},{"ID":194,"CreatedAt":"2023-09-12T03:58:03.404Z","UpdatedAt":"2023-09-13T03:29:47.857Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"从audit中获取缓存的filename结构体， 或将用户输入的文件名，复制到新创建的filename结构体。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L130\n\n```c\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (unlikely(len == EMBEDDED_NAME_MAX)) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tkname = (char *)result;\n\n\t\t/*\n\t\t * size is chosen that way we to guarantee that\n\t\t * result->iname[0] is within the same object and that\n\t\t * kname can't be equal to result->iname, no matter what.\n\t\t */\n\t\tresult = kzalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!result)) {\n\t\t\t__putname(kname);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tresult->name = kname;\n\t\tlen = strncpy_from_user(kname, filename, PATH_MAX);\n\t\tif (unlikely(len < 0)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(len);\n\t\t}\n\t\tif (unlikely(len == PATH_MAX)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t}\n\n\tresult->refcnt = 1;\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\tif (!(flags & LOOKUP_EMPTY)) {\n\t\t\tputname(result);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n}\n```","collapsed":false,"parent":193,"child":203,"next":0},{"ID":203,"CreatedAt":"2023-09-12T07:10:11.008Z","UpdatedAt":"2023-09-12T08:03:25.264Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`audit_reusename()`： audit 会记录访问的文件名。如果当前的audit 上下文中出现过该文件名，则返回审计上下文中记录的filename结构体。相当于借用 audit 作为缓存使用。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L136-L138\n\n```c\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n    ...\n    result = audit_reusename(filename);\n    if (result)\n        return result;\n        ...\n}","collapsed":false,"parent":194,"child":196,"next":205},{"ID":196,"CreatedAt":"2023-09-12T06:23:45.687Z","UpdatedAt":"2023-09-12T06:23:45.687Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/audit.h#L359\n\n```c\n#ifdef CONFIG_AUDITSYSCALL\n...\nstatic inline struct filename *audit_reusename(const __user char *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn __audit_reusename(name);\n\treturn NULL;\n}\n...\n#else /* CONFIG_AUDITSYSCALL */\n...\nstatic inline struct filename *audit_reusename(const __user char *name)\n{\n\treturn NULL;\n}\n```","collapsed":false,"parent":203,"child":199,"next":0},{"ID":199,"CreatedAt":"2023-09-12T06:39:46.115Z","UpdatedAt":"2023-09-12T06:57:45.429Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"audit 会记录访问的文件名。如果当前的audit 上下文中出现过该文件名，则返回审计上下文中记录的filename结构体，引用计数 ++ \n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/auditsc.c#L2202\n\n```c\n/**\n * __audit_reusename - fill out filename with info from existing entry\n * @uptr: userland ptr to pathname\n *\n * Search the audit_names list for the current audit context. If there is an\n * existing entry with a matching \"uptr\" then return the filename\n * associated with that audit_name. If not, return NULL.\n */\nstruct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n```","collapsed":false,"parent":196,"child":200,"next":0},{"ID":200,"CreatedAt":"2023-09-12T06:48:10.186Z","UpdatedAt":"2023-09-12T06:50:06.951Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"获取当前进程的audit上下文\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/audit.h#L313\n\n```c\n#ifdef CONFIG_AUDITSYSCALL\n...\nstatic inline struct audit_context *audit_context(void)\n{\n\treturn current->audit_context;\n}\n...\n#else /* CONFIG_AUDITSYSCALL */\n...\nstatic inline struct audit_context *audit_context(void)\n{\n\treturn NULL;\n}\n```","collapsed":false,"parent":199,"child":0,"next":201},{"ID":292,"CreatedAt":"2024-07-29T03:45:52.825Z","UpdatedAt":"2024-07-30T07:34:06.167Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"根据文件句柄获得dentry, 设置 path->dentry\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L150-L160\n\n```c\nstatic int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n    ...\n    int handle_dwords;\n    ...\n    /* change the handle size to multiple of sizeof(u32) */\n    handle_dwords = handle->handle_bytes >> 2;\n    path->dentry = exportfs_decode_fh(path->mnt,\n    \t\t\t\t  (struct fid *)handle->f_handle,\n    \t\t\t\t  handle_dwords, handle->handle_type,\n    \t\t\t\t  vfs_dentry_acceptable, NULL);\n    if (IS_ERR(path->dentry)) {\n    \tretval = PTR_ERR(path->dentry);\n    \tgoto out_mnt;\n\t}\n\treturn 0;\nout_mnt:\n    mntput(path->mnt);\nout_err:\n    return retval;\n}\n```","collapsed":false,"last":291,"child":293,"next":0},{"ID":293,"CreatedAt":"2024-07-29T03:47:50.168Z","UpdatedAt":"2024-07-29T03:47:50.168Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/fhandle.c#L134\n\n```c\nstatic int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}\n```","collapsed":false,"parent":292,"child":0,"next":294}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":303,"CreatedAt":"2024-07-30T08:53:54.504Z","UpdatedAt":"2024-07-30T09:00:28.658Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"查找inode的所有引用，保存到ipath结构体\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/btrfs/backref.c#L2749\n\n```c\n/*\n * this dumps all file system paths to the inode into the ipath struct, provided\n * is has been created large enough. each path is zero-terminated and accessed\n * from ipath->fspath->val[i].\n * when it returns, there are ipath->fspath->elem_cnt number of paths available\n * in ipath->fspath->val[]. when the allocated space wasn't sufficient, the\n * number of missed paths is recorded in ipath->fspath->elem_missed, otherwise,\n * it's zero. ipath->fspath->bytes_missing holds the number of bytes that would\n * have been needed to return all paths.\n */\nint paths_from_inode(u64 inum, struct inode_fs_paths *ipath)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, ipath);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, ipath);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}\n```","collapsed":false,"last":304,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":320,"CreatedAt":"2024-07-31T03:26:27.811Z","UpdatedAt":"2024-07-31T09:10:21.81Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"#### 4.1.3 ovl_verify_index\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L524\n\n```c\n/*\n * Verify that an index entry name matches the origin file handle stored in\n * OVL_XATTR_ORIGIN and that origin file handle can be decoded to lower path.\n * Return 0 on match, -ESTALE on mismatch or stale origin, < 0 on error.\n */\nint ovl_verify_index(struct ovl_fs *ofs, struct dentry *index)\n{\n\tstruct ovl_fh *fh = NULL;\n\tsize_t len;\n\tstruct ovl_path origin = { };\n\tstruct ovl_path *stack = &origin;\n\tstruct dentry *upper = NULL;\n\tint err;\n\n\tif (!d_inode(index))\n\t\treturn 0;\n\n\terr = -EINVAL;\n\tif (index->d_name.len < sizeof(struct ovl_fb)*2)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tlen = index->d_name.len / 2;\n\tfh = kzalloc(len + OVL_FH_WIRE_OFFSET, GFP_KERNEL);\n\tif (!fh)\n\t\tgoto fail;\n\n\terr = -EINVAL;\n\tif (hex2bin(fh->buf, index->d_name.name, len))\n\t\tgoto fail;\n\n\terr = ovl_check_fb_len(&fh->fb, len);\n\tif (err)\n\t\tgoto fail;\n\n\t/*\n\t * Whiteout index entries are used as an indication that an exported\n\t * overlay file handle should be treated as stale (i.e. after unlink\n\t * of the overlay inode). These entries contain no origin xattr.\n\t */\n\tif (ovl_is_whiteout(index))\n\t\tgoto out;\n\n\t/*\n\t * Verifying directory index entries are not stale is expensive, so\n\t * only verify stale dir index if NFS export is enabled.\n\t */\n\tif (d_is_dir(index) && !ofs->config.nfs_export)\n\t\tgoto out;\n\n\t/*\n\t * Directory index entries should have 'upper' xattr pointing to the\n\t * real upper dir. Non-dir index entries are hardlinks to the upper\n\t * real inode. For non-dir index, we can read the copy up origin xattr\n\t * directly from the index dentry, but for dir index we first need to\n\t * decode the upper directory.\n\t */\n\tupper = ovl_index_upper(ofs, index, false);\n\tif (IS_ERR_OR_NULL(upper)) {\n\t\terr = PTR_ERR(upper);\n\t\t/*\n\t\t * Directory index entries with no 'upper' xattr need to be\n\t\t * removed. When dir index entry has a stale 'upper' xattr,\n\t\t * we assume that upper dir was removed and we treat the dir\n\t\t * index as orphan entry that needs to be whited out.\n\t\t */\n\t\tif (err == -ESTALE)\n\t\t\tgoto orphan;\n\t\telse if (!err)\n\t\t\terr = -ESTALE;\n\t\tgoto fail;\n\t}\n\n\terr = ovl_verify_fh(ofs, upper, OVL_XATTR_ORIGIN, fh);\n\tdput(upper);\n\tif (err)\n\t\tgoto fail;\n\n\t/* Check if non-dir index is orphan and don't warn before cleaning it */\n\tif (!d_is_dir(index) && d_inode(index)->i_nlink == 1) {\n\t\terr = ovl_check_origin_fh(ofs, fh, false, index, &stack);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tif (ovl_get_nlink(ofs, origin.dentry, index, 0) == 0)\n\t\t\tgoto orphan;\n\t}\n\nout:\n\tdput(origin.dentry);\n\tkfree(fh);\n\treturn err;\n\nfail:\n\tpr_warn_ratelimited(\"failed to verify index (%pd2, ftype=%x, err=%i)\\n\",\n\t\t\t    index, d_inode(index)->i_mode & S_IFMT, err);\n\tgoto out;\n\norphan:\n\tpr_warn_ratelimited(\"orphan index entry (%pd2, ftype=%x, nlink=%u)\\n\",\n\t\t\t    index, d_inode(index)->i_mode & S_IFMT,\n\t\t\t    d_inode(index)->i_nlink);\n\terr = -ENOENT;\n\tgoto out;\n}\n```","collapsed":false,"last":315,"child":321,"next":0},{"ID":321,"CreatedAt":"2024-07-31T03:27:14.103Z","UpdatedAt":"2024-07-31T03:27:14.103Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L490\n\n```c\n/* Get upper dentry from index */\nstruct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index,\n\t\t\t       bool connected)\n{\n\tstruct ovl_fh *fh;\n\tstruct dentry *upper;\n\n\tif (!d_is_dir(index))\n\t\treturn dget(index);\n\n\tfh = ovl_get_fh(ofs, index, OVL_XATTR_UPPER);\n\tif (IS_ERR_OR_NULL(fh))\n\t\treturn ERR_CAST(fh);\n\n\tupper = ovl_decode_real_fh(ofs, fh, ovl_upper_mnt(ofs), connected);\n\tkfree(fh);\n\n\tif (IS_ERR_OR_NULL(upper))\n\t\treturn upper ?: ERR_PTR(-ESTALE);\n\n\tif (!d_is_dir(upper)) {\n\t\tpr_warn_ratelimited(\"invalid index upper (%pd2, upper=%pd2).\\n\",\n\t\t\t\t    index, upper);\n\t\tdput(upper);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn upper;\n}\n```","collapsed":false,"parent":320,"child":322,"next":326},{"ID":322,"CreatedAt":"2024-07-31T03:27:46.93Z","UpdatedAt":"2024-07-31T03:27:46.93Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L154\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ofs->config.uuid ? !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t\t\t      !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":321,"child":0,"next":0},{"ID":323,"CreatedAt":"2024-07-31T03:46:51.901Z","UpdatedAt":"2024-07-31T03:46:51.901Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L701\n\n```c\nstruct dentry *ovl_lookup_index(struct ovl_fs *ofs, struct dentry *upper,\n\t\t\t\tstruct dentry *origin, bool verify)\n{\n\tstruct dentry *index;\n\tstruct inode *inode;\n\tstruct qstr name;\n\tbool is_dir = d_is_dir(origin);\n\tint err;\n\n\terr = ovl_get_index_name(ofs, origin, &name);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tindex = lookup_one_positive_unlocked(ovl_upper_mnt_idmap(ofs), name.name,\n\t\t\t\t\t     ofs->indexdir, name.len);\n\tif (IS_ERR(index)) {\n\t\terr = PTR_ERR(index);\n\t\tif (err == -ENOENT) {\n\t\t\tindex = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_warn_ratelimited(\"failed inode index lookup (ino=%lu, key=%.*s, err=%i);\\n\"\n\t\t\t\t    \"overlayfs: mount with '-o index=off' to disable inodes index.\\n\",\n\t\t\t\t    d_inode(origin)->i_ino, name.len, name.name,\n\t\t\t\t    err);\n\t\tgoto out;\n\t}\n\n\tinode = d_inode(index);\n\tif (ovl_is_whiteout(index) && !verify) {\n\t\t/*\n\t\t * When index lookup is called with !verify for decoding an\n\t\t * overlay file handle, a whiteout index implies that decode\n\t\t * should treat file handle as stale and no need to print a\n\t\t * warning about it.\n\t\t */\n\t\tdput(index);\n\t\tindex = ERR_PTR(-ESTALE);\n\t\tgoto out;\n\t} else if (ovl_dentry_weird(index) || ovl_is_whiteout(index) ||\n\t\t   inode_wrong_type(inode, d_inode(origin)->i_mode)) {\n\t\t/*\n\t\t * Index should always be of the same file type as origin\n\t\t * except for the case of a whiteout index. A whiteout\n\t\t * index should only exist if all lower aliases have been\n\t\t * unlinked, which means that finding a lower origin on lookup\n\t\t * whose index is a whiteout should be treated as an error.\n\t\t */\n\t\tpr_warn_ratelimited(\"bad index found (index=%pd2, ftype=%x, origin ftype=%x).\\n\",\n\t\t\t\t    index, d_inode(index)->i_mode & S_IFMT,\n\t\t\t\t    d_inode(origin)->i_mode & S_IFMT);\n\t\tgoto fail;\n\t} else if (is_dir && verify) {\n\t\tif (!upper) {\n\t\t\tpr_warn_ratelimited(\"suspected uncovered redirected dir found (origin=%pd2, index=%pd2).\\n\",\n\t\t\t\t\t    origin, index);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* Verify that dir index 'upper' xattr points to upper dir */\n\t\terr = ovl_verify_upper(ofs, index, upper, false);\n\t\tif (err) {\n\t\t\tif (err == -ESTALE) {\n\t\t\t\tpr_warn_ratelimited(\"suspected multiply redirected dir found (upper=%pd2, origin=%pd2, index=%pd2).\\n\",\n\t\t\t\t\t\t    upper, origin, index);\n\t\t\t}\n\t\t\tgoto fail;\n\t\t}\n\t} else if (upper && d_inode(upper) != inode) {\n\t\tgoto out_dput;\n\t}\nout:\n\tkfree(name.name);\n\treturn index;\n\nout_dput:\n\tdput(index);\n\tindex = NULL;\n\tgoto out;\n\nfail:\n\tdput(index);\n\tindex = ERR_PTR(-EIO);\n\tgoto out;\n}\n```","collapsed":false,"last":317,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":313,"CreatedAt":"2024-07-30T09:35:29.94Z","UpdatedAt":"2024-07-30T09:35:29.94Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L672\n\n```c\n/* Lookup index by file handle for NFS export */\nstruct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh)\n{\n\tstruct dentry *index;\n\tstruct qstr name;\n\tint err;\n\n\terr = ovl_get_index_name_fh(fh, &name);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tindex = lookup_positive_unlocked(name.name, ofs->indexdir, name.len);\n\tkfree(name.name);\n\tif (IS_ERR(index)) {\n\t\tif (PTR_ERR(index) == -ENOENT)\n\t\t\tindex = NULL;\n\t\treturn index;\n\t}\n\n\tif (ovl_is_whiteout(index))\n\t\terr = -ESTALE;\n\telse if (ovl_dentry_weird(index))\n\t\terr = -EIO;\n\telse\n\t\treturn index;\n\n\tdput(index);\n\treturn ERR_PTR(err);\n}\n```","collapsed":false,"last":311,"child":0,"next":324},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":261,"CreatedAt":"2023-10-11T09:49:44.437Z","UpdatedAt":"2023-10-11T09:49:44.437Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"解析标志\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4633-L4648\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {\n\t\terror = -EINVAL;\n\t\tgoto out_putnames;\n\t}\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH && !capable(CAP_DAC_READ_SEARCH)) {\n\t\terror = -ENOENT;\n\t\tgoto out_putnames;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\n    ...\n}\n```","collapsed":false,"last":250,"child":189,"next":262},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":189,"CreatedAt":"2023-09-12T03:27:44.245Z","UpdatedAt":"2023-10-11T07:44:15.04Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"要求 flags 中只能设置 `AT_SYMLINK_FOLLOW`, `AT_EMPTY_PATH`，不能设置其他标志位。如果包含，则跳转至 `out_putnames`，并返回错误。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4633-L4636\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n          struct filename *new, int flags)\n{\n    ...\n    if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {\n        error = -EINVAL;\n        goto out_putnames;\n    }\n    ...\n}\n```","collapsed":false,"parent":261,"child":190,"next":213},{"ID":0,"markdown":""},{"ID":190,"CreatedAt":"2023-09-12T03:30:34.839Z","UpdatedAt":"2023-10-11T08:44:10.729Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"* `AT_SYMLINK_FOLLOW`: 用来控制是否解析软链接\n* `AT_EMPTY_PATH`: 当在linkat系统调用中，oldpath参数为一个空字符串时，如果指定了AT_EMPTY_PATH标志位，则创建一个指向olddirfd引用的文件的链接，调用者必须具有CAP_DAC_READ_SEARCH权限才能使用此标志。\n\n`flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)` 意为， flags中除`AT_SYMLINK_FOLLOW`,`AT_EMPTY_PATH` 以外的标志位。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/fcntl.h#L104\n\n```c\n#define AT_SYMLINK_FOLLOW\t0x400   /* Follow symbolic links.  */\n...\n#define AT_EMPTY_PATH\t\t0x1000\t/* Allow empty relative pathname */\n```","collapsed":false,"parent":189,"child":0,"next":191},{"ID":253,"CreatedAt":"2023-10-11T06:55:15.437Z","UpdatedAt":"2023-10-11T06:57:24.859Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"path_put 释放 path 结构体。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L559\n\n```c\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n```","collapsed":false,"last":251,"child":254,"next":0},{"ID":254,"CreatedAt":"2023-10-11T06:56:10.12Z","UpdatedAt":"2023-10-11T06:58:06.428Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/path.h#L8-L11\n\n```c\nstruct path {\n\tstruct vfsmount *mnt;\n\tstruct dentry *dentry;\n} __randomize_layout;\n```","collapsed":false,"parent":253,"child":0,"next":255},{"ID":244,"CreatedAt":"2023-10-07T07:10:48.724Z","UpdatedAt":"2023-10-07T07:31:25.167Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将新文件即链接文件的文件名转换为filename结构体，不涉及 flags，其余与前一函数相同。\n\n```c\ngetname(newname)\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L216\n\n```c\nstruct filename *\ngetname(const char __user * filename)\n{\n\treturn getname_flags(filename, 0, NULL);\n}\n```","collapsed":false,"last":193,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":205,"CreatedAt":"2023-09-12T07:38:13.164Z","UpdatedAt":"2023-09-13T08:35:56.48Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将用户传入的文件名，复制到 `result->iname`，name指向iname。\n\n限制了iname的长度，最多复制 `EMBEDDED_NAME_MAX` 长度。即，整个filename长度为 `PATH_MAX` (4096)\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L151\n\n```c\n#define EMBEDDED_NAME_MAX (PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\t...\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n    ...\n}","collapsed":false,"last":203,"child":209,"next":210},{"ID":0,"markdown":""},{"ID":209,"CreatedAt":"2023-09-12T08:41:54.79Z","UpdatedAt":"2023-09-12T08:41:54.79Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/limits.h#L13\n\n```c\n#define PATH_MAX 4096\t/* # chars in a path name including nul */\n```","collapsed":false,"parent":205,"child":0,"next":206},{"ID":201,"CreatedAt":"2023-09-12T06:51:48.438Z","UpdatedAt":"2023-09-12T06:54:05.415Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"审计系统维护了一个用于存储审计相关信息的数据结构，其中包括审计上下文和与之关联的文件名信息。\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/audit.h#L128\n\n```c\n/* The per-task audit context. */\nstruct audit_context {\n\t...\n\t/*\n\t * The names_list is the list of all audit_names collected during this\n\t * syscall.  The first AUDIT_NAMES entries in the names_list will\n\t * actually be from the preallocated_names array for performance\n\t * reasons.  Except during allocation they should never be referenced\n\t * through the preallocated_names array and should only be found/used\n\t * by running the names_list.\n\t */\n\tstruct audit_names  preallocated_names[AUDIT_NAMES];\n\tint\t\t    name_count; /* total records in names_list */\n\tstruct list_head    names_list;\t/* struct audit_names->list anchor */\n\t...\n};\n```","collapsed":false,"last":200,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":294,"CreatedAt":"2024-07-29T03:48:08.676Z","UpdatedAt":"2024-07-29T03:48:08.676Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"将文件句柄转为 dentry\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/exportfs/expfs.c#L568\n\n```c\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\t\t\t  int fh_len, int fileid_type,\n\t\t\t\t  int (*acceptable)(void *, struct dentry *),\n\t\t\t\t  void *context)\n{\n\tstruct dentry *ret;\n\n\tret = exportfs_decode_fh_raw(mnt, fid, fh_len, fileid_type,\n\t\t\t\t     acceptable, context);\n\tif (IS_ERR_OR_NULL(ret)) {\n\t\tif (ret == ERR_PTR(-ENOMEM))\n\t\t\treturn ret;\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn ret;\n}\n```","collapsed":false,"last":293,"child":295,"next":0},{"ID":295,"CreatedAt":"2024-07-29T06:42:38.728Z","UpdatedAt":"2024-07-29T07:26:52.581Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"使用文件系统提供的fh_to_dentry方法获取dentry。\n\n* 文件系统可能没有提供s_export_op或fh_to_dentry方法，则返回ESTALE\n* 如果返回值是错误或NULL，直接返回\n* 如果无需验证(未提供acceptable函数)，直接返回\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/exportfs/expfs.c#L419-L446\n\n```c\nstruct dentry *\nexportfs_decode_fh_raw(struct vfsmount *mnt, struct fid *fid, int fh_len,\n\t\t       int fileid_type,\n\t\t       int (*acceptable)(void *, struct dentry *),\n\t\t       void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (IS_ERR_OR_NULL(result))\n\t\treturn result;\n\n\t/*\n\t * If no acceptance criteria was specified by caller, a disconnected\n\t * dentry is also accepatable. Callers may use this mode to query if\n\t * file handle is stale or to get a reference to an inode without\n\t * risking the high overhead caused by directory reconnect.\n\t */\n\tif (!acceptable)\n\t\treturn result;\n\t...\n}\n```","collapsed":false,"parent":294,"child":298,"next":297},{"ID":298,"CreatedAt":"2024-07-30T07:00:32.301Z","UpdatedAt":"2024-07-30T07:19:57.343Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"以ext4为例：\n\n通过 file handle 获取 inode, 再由inode 获取或创建 dentry\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/ext4/super.c#L1525-L1530\n\n```c\nstatic struct dentry *ext4_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext4_nfs_get_inode);\n}\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/libfs.c#L1055\n\n```c\n/**\n * generic_fh_to_dentry - generic helper for the fh_to_dentry export operation\n * @sb:\t\tfilesystem to do the file handle conversion on\n * @fid:\tfile handle to convert\n * @fh_len:\tlength of the file handle in bytes\n * @fh_type:\ttype of file handle\n * @get_inode:\tfilesystem callback to retrieve inode\n *\n * This function decodes @fid as long as it has one of the well-known\n * Linux filehandle types and calls @get_inode on it to retrieve the\n * inode for the object specified in the file handle.\n */\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}\n```","collapsed":false,"parent":295,"child":0,"next":296}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":326,"CreatedAt":"2024-07-31T04:01:01.137Z","UpdatedAt":"2024-07-31T04:01:01.137Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L353\n\n```c\nint ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,\n\t\t\tstruct dentry *upperdentry, struct ovl_path **stackp)\n{\n\tstruct dentry *origin = NULL;\n\tint i;\n\n\tfor (i = 1; i < ofs->numlayer; i++) {\n\t\t/*\n\t\t * If lower fs uuid is not unique among lower fs we cannot match\n\t\t * fh->uuid to layer.\n\t\t */\n\t\tif (ofs->layers[i].fsid &&\n\t\t    ofs->layers[i].fs->bad_uuid)\n\t\t\tcontinue;\n\n\t\torigin = ovl_decode_real_fh(ofs, fh, ofs->layers[i].mnt,\n\t\t\t\t\t    connected);\n\t\tif (origin)\n\t\t\tbreak;\n\t}\n\n\tif (!origin)\n\t\treturn -ESTALE;\n\telse if (IS_ERR(origin))\n\t\treturn PTR_ERR(origin);\n\n\tif (upperdentry && !ovl_is_whiteout(upperdentry) &&\n\t    inode_wrong_type(d_inode(upperdentry), d_inode(origin)->i_mode))\n\t\tgoto invalid;\n\n\tif (!*stackp)\n\t\t*stackp = kmalloc(sizeof(struct ovl_path), GFP_KERNEL);\n\tif (!*stackp) {\n\t\tdput(origin);\n\t\treturn -ENOMEM;\n\t}\n\t**stackp = (struct ovl_path){\n\t\t.dentry = origin,\n\t\t.layer = &ofs->layers[i]\n\t};\n\n\treturn 0;\n\ninvalid:\n\tpr_warn_ratelimited(\"invalid origin (%pd2, ftype=%x, origin ftype=%x).\\n\",\n\t\t\t    upperdentry, d_inode(upperdentry)->i_mode & S_IFMT,\n\t\t\t    d_inode(origin)->i_mode & S_IFMT);\n\tdput(origin);\n\treturn -ESTALE;\n}\n```","collapsed":false,"last":321,"child":327,"next":0},{"ID":327,"CreatedAt":"2024-07-31T04:01:49.183Z","UpdatedAt":"2024-07-31T04:01:49.183Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L154\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ofs->config.uuid ? !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t\t\t      !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":326,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":324,"CreatedAt":"2024-07-31T03:50:39.174Z","UpdatedAt":"2024-07-31T03:50:39.174Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L490\n\n```c\n/* Get upper dentry from index */\nstruct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index,\n\t\t\t       bool connected)\n{\n\tstruct ovl_fh *fh;\n\tstruct dentry *upper;\n\n\tif (!d_is_dir(index))\n\t\treturn dget(index);\n\n\tfh = ovl_get_fh(ofs, index, OVL_XATTR_UPPER);\n\tif (IS_ERR_OR_NULL(fh))\n\t\treturn ERR_CAST(fh);\n\n\tupper = ovl_decode_real_fh(ofs, fh, ovl_upper_mnt(ofs), connected);\n\tkfree(fh);\n\n\tif (IS_ERR_OR_NULL(upper))\n\t\treturn upper ?: ERR_PTR(-ESTALE);\n\n\tif (!d_is_dir(upper)) {\n\t\tpr_warn_ratelimited(\"invalid index upper (%pd2, upper=%pd2).\\n\",\n\t\t\t\t    index, upper);\n\t\tdput(upper);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn upper;\n}\n```","collapsed":false,"last":313,"child":325,"next":334},{"ID":325,"CreatedAt":"2024-07-31T03:53:03.962Z","UpdatedAt":"2024-07-31T03:53:03.962Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/namei.c#L154\n\n```c\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t/*\n\t * Make sure that the stored uuid matches the uuid of the lower\n\t * layer where file handle will be decoded.\n\t * In case of uuid=off option just make sure that stored uuid is null.\n\t */\n\tif (ofs->config.uuid ? !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t\t\t      !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t/*\n\t\t * Treat stale file handle to lower file as \"origin unknown\".\n\t\t * upper file handle could become stale when upper file is\n\t\t * unlinked and this information is needed to handle stale\n\t\t * index entries correctly.\n\t\t */\n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n```","collapsed":false,"parent":324,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":262,"CreatedAt":"2023-10-13T08:20:40.585Z","UpdatedAt":"2024-07-30T08:17:12.455Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"创建 path 结构体, old_path, new_path；创建链接\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4649-L4671\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\nretry:\n\terror = filename_lookup(olddfd, old, how, &old_path, NULL);\n\tif (error)\n\t\tgoto out_putnames;\n\n\tnew_dentry = filename_create(newdfd, new, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out_putpath;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\tidmap = mnt_idmap(new_path.mnt);\n\terror = may_linkat(idmap, &old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,\n\t\t\t new_dentry, &delegated_inode);\nout_dput:\n    ...\n}\n```","collapsed":false,"last":261,"child":216,"next":269},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":216,"CreatedAt":"2023-09-13T03:51:37.573Z","UpdatedAt":"2023-10-09T09:52:30.549Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"<span style=\"color:red\">TODO:</span> 没有释放 old_path ?\n\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4650-L4652\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\nretry:\n\terror = filename_lookup(olddfd, old, how, &old_path, NULL);\n\tif (error)\n\t\tgoto out_putnames;\n\t...\n}\n```","collapsed":false,"parent":262,"child":217,"next":263},{"ID":217,"CreatedAt":"2023-09-13T07:29:47.429Z","UpdatedAt":"2023-09-13T08:17:16.588Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"在 dfd 目录下，查找文件名 name ， 将完整路径信息传递给 `path *path`\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L2500\n\n```c\nint filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t    struct path *path, struct path *root)\n{\n\tint retval;\n\tstruct nameidata nd;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tset_nameidata(&nd, dfd, name, root);\n\tretval = path_lookupat(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(&nd, flags, path);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, path->dentry,\n\t\t\t    flags & LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0);\n\trestore_nameidata();\n\treturn retval;\n}\n```","collapsed":false,"parent":216,"child":221,"next":0},{"ID":221,"CreatedAt":"2023-09-13T08:03:33.163Z","UpdatedAt":"2023-09-13T08:05:57.832Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"设置当前进程的 nameidata 结构体。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L2507\n\n```c\nint filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t    struct path *path, struct path *root)\n{\n\t...\n\tstruct nameidata nd;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tset_nameidata(&nd, dfd, name, root);\n    ...\n}\n```","collapsed":false,"parent":217,"child":220,"next":222},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":220,"CreatedAt":"2023-09-13T07:38:19.289Z","UpdatedAt":"2023-09-13T07:53:18.936Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"在 Linux 内核中，nameidata 结构体用于在文件系统操作中跟踪和存储有关文件名解析的信息。每个进程都有一个与之关联的 nameidata 结构体，用于处理与文件名相关的操作，如打开文件、创建文件和路径名解析等。\n\nnameidata 结构体\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L566-L589\n\n```c\n#define EMBEDDED_LEVELS 2\nstruct nameidata {\n\tstruct path\tpath;\n\tstruct qstr\tlast;\n\tstruct path\troot;\n\tstruct inode\t*inode; /* path.dentry.d_inode */\n\tunsigned int\tflags, state;\n\tunsigned\tseq, next_seq, m_seq, r_seq;\n\tint\t\tlast_type;\n\tunsigned\tdepth;\n\tint\t\ttotal_link_count;\n\tstruct saved {\n\t\tstruct path link;\n\t\tstruct delayed_call done;\n\t\tconst char *name;\n\t\tunsigned seq;\n\t} *stack, internal[EMBEDDED_LEVELS];\n\tstruct filename\t*name;\n\tstruct nameidata *saved;\n\tunsigned\troot_seq;\n\tint\t\tdfd;\n\tvfsuid_t\tdir_vfsuid;\n\tumode_t\t\tdir_mode;\n} __randomize_layout;\n```","collapsed":false,"parent":221,"child":0,"next":218},{"ID":0,"markdown":""},{"ID":213,"CreatedAt":"2023-09-13T03:37:53.88Z","UpdatedAt":"2024-07-30T08:12:36.034Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"##### `CAP`, `AT_EMPTY_PATH`\n\n使用 `AT_EMPTY_PATH` 要求当前进程在 `init_user_ns` 拥有 `CAP_DAC_READ_SEARCH`， 否则就结束函数。\n\n为什么要求需要 `CAP_DAC_READ_SEARCH` 呢？ 主要是考虑用户只拥有fd而不知道路径的场景。AT_EMPTY_PATH标志允许一个进程对一个已经打开的fd进行操作，而不需要指定文件的路径，这个文件可能是进程原本没有权限通过路径访问的文件。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4642-L4645\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH && !capable(CAP_DAC_READ_SEARCH)) {\n\t\terror = -ENOENT;\n\t\tgoto out_putnames;\n\t}\n    ...\n}\n```","collapsed":false,"last":189,"child":214,"next":215},{"ID":214,"CreatedAt":"2023-09-13T03:44:48.663Z","UpdatedAt":"2023-09-13T03:44:48.663Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"capable 要求当前进程在 init_user_ns 中拥有cap\n\n```c\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}\n```","collapsed":false,"parent":213,"child":0,"next":259},{"ID":191,"CreatedAt":"2023-09-12T03:46:22.004Z","UpdatedAt":"2023-10-09T09:15:20.097Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"用于处理 struct filename 结构体的资源释放。\n\n前面调用系统调用时，将用户传入的文件名转为了filename结构体\n\n`getname_uflags(oldname, flags)`, `getname(newname), flags)`\n\n这里在系统调用结束时，释放结构体。\n\n释放时，如果引用计数 <= 0, 则报错；引用计数 -- 仍 > 0, 则返回不释放。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L259\n\n```c\nvoid putname(struct filename *name)\n{\n\tif (IS_ERR(name))\n\t\treturn;\n\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}\nEXPORT_SYMBOL(putname);\n```","collapsed":false,"last":190,"child":192,"next":0},{"ID":192,"CreatedAt":"2023-09-12T03:48:40.925Z","UpdatedAt":"2023-09-12T03:51:06.828Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L2389\n\n```c\n#define __putname(name)\tkmem_cache_free(names_cachep, (void *)(name))\n```","collapsed":false,"parent":191,"child":0,"next":0},{"ID":255,"CreatedAt":"2023-10-11T07:03:39.336Z","UpdatedAt":"2023-10-11T07:41:52.612Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"<span style=\"color:red\">TODO: dput</span>\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/dcache.c#L894\n\n```c\n/* \n * This is dput\n *\n * This is complicated by the fact that we do not want to put\n * dentries that are no longer on any hash chain on the unused\n * list: we'd much rather just get rid of them immediately.\n *\n * However, that implies that we have to traverse the dentry\n * tree upwards to the parents which might _also_ now be\n * scheduled for deletion (it may have been only waiting for\n * its last child to go away).\n *\n * This tail recursion is done by hand as we don't want to depend\n * on the compiler to always get this right (gcc generally doesn't).\n * Real recursion would eat up our stack space.\n */\n\n/*\n * dput - release a dentry\n * @dentry: dentry to release \n *\n * Release a dentry. This will drop the usage count and if appropriate\n * call the dentry unlink method as well as removing it from the queues and\n * releasing its resources. If the parent dentries were scheduled for release\n * they too may now get deleted.\n */\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}\nEXPORT_SYMBOL(dput);\n```","collapsed":false,"last":254,"child":256,"next":0},{"ID":256,"CreatedAt":"2023-10-11T07:34:43.247Z","UpdatedAt":"2023-10-11T07:36:45.441Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/dcache.c#L765\n\n```c\n/*\n * Try to do a lockless dput(), and return whether that was successful.\n *\n * If unsuccessful, we return false, having already taken the dentry lock.\n *\n * The caller needs to hold the RCU read lock, so that the dentry is\n * guaranteed to stay around even if the refcount goes down to zero!\n */\nstatic inline bool fast_dput(struct dentry *dentry)\n{\n\tint ret;\n\tunsigned int d_flags;\n\n\t/*\n\t * If we have a d_op->d_delete() operation, we sould not\n\t * let the dentry count go to zero, so use \"put_or_lock\".\n\t */\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE))\n\t\treturn lockref_put_or_lock(&dentry->d_lockref);\n\n\t/*\n\t * .. otherwise, we can try to just decrement the\n\t * lockref optimistically.\n\t */\n\tret = lockref_put_return(&dentry->d_lockref);\n\n\t/*\n\t * If the lockref_put_return() failed due to the lock being held\n\t * by somebody else, the fast path has failed. We will need to\n\t * get the lock, and then check the count again.\n\t */\n\tif (unlikely(ret < 0)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_lockref.count > 1) {\n\t\t\tdentry->d_lockref.count--;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we weren't the last ref, we're done.\n\t */\n\tif (ret)\n\t\treturn true;\n\n\t/*\n\t * Careful, careful. The reference count went down\n\t * to zero, but we don't hold the dentry lock, so\n\t * somebody else could get it again, and do another\n\t * dput(), and we need to not race with that.\n\t *\n\t * However, there is a very special and common case\n\t * where we don't care, because there is nothing to\n\t * do: the dentry is still hashed, it does not have\n\t * a 'delete' op, and it's referenced and already on\n\t * the LRU list.\n\t *\n\t * NOTE! Since we aren't locked, these values are\n\t * not \"stable\". However, it is sufficient that at\n\t * some point after we dropped the reference the\n\t * dentry was hashed and the flags had the proper\n\t * value. Other dentry users may have re-gotten\n\t * a reference to the dentry and change that, but\n\t * our work is done - we can leave the dentry\n\t * around with a zero refcount.\n\t *\n\t * Nevertheless, there are two cases that we should kill\n\t * the dentry anyway.\n\t * 1. free disconnected dentries as soon as their refcount\n\t *    reached zero.\n\t * 2. free dentries if they should not be cached.\n\t */\n\tsmp_rmb();\n\td_flags = READ_ONCE(dentry->d_flags);\n\td_flags &= DCACHE_REFERENCED | DCACHE_LRU_LIST |\n\t\t\tDCACHE_DISCONNECTED | DCACHE_DONTCACHE;\n\n\t/* Nothing to do? Dropping the reference was all we needed? */\n\tif (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) && !d_unhashed(dentry))\n\t\treturn true;\n\n\t/*\n\t * Not the fast normal case? Get the lock. We've already decremented\n\t * the refcount, but we'll need to re-check the situation after\n\t * getting the lock.\n\t */\n\tspin_lock(&dentry->d_lock);\n\n\t/*\n\t * Did somebody else grab a reference to it in the meantime, and\n\t * we're no longer the last user after all? Alternatively, somebody\n\t * else could have killed it and marked it dead. Either way, we\n\t * don't need to do anything else.\n\t */\n\tif (dentry->d_lockref.count) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn true;\n\t}\n\n\t/*\n\t * Re-get the reference we optimistically dropped. We hold the\n\t * lock, and we just tested that it was zero, so we can just\n\t * set it to 1.\n\t */\n\tdentry->d_lockref.count = 1;\n\treturn false;\n}\n```","collapsed":false,"parent":255,"child":0,"next":257},{"ID":0,"markdown":""},{"ID":210,"CreatedAt":"2023-09-12T08:51:11.705Z","UpdatedAt":"2023-09-12T09:26:41.021Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"如果文件名长度超过了最大限制，则新分配一块内存作为filename结构，将原先的结构体作为filename->iname, 再复制一次。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L163\n\n```c\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\t...\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (unlikely(len == EMBEDDED_NAME_MAX)) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tkname = (char *)result;\n\n\t\t/*\n\t\t * size is chosen that way we to guarantee that\n\t\t * result->iname[0] is within the same object and that\n\t\t * kname can't be equal to result->iname, no matter what.\n\t\t */\n\t\tresult = kzalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!result)) {\n\t\t\t__putname(kname);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tresult->name = kname;\n\t\tlen = strncpy_from_user(kname, filename, PATH_MAX);\n\t\tif (unlikely(len < 0)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(len);\n\t\t}\n\t\tif (unlikely(len == PATH_MAX)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t}\n    ...\n}","collapsed":false,"last":205,"child":0,"next":211},{"ID":0,"markdown":""},{"ID":206,"CreatedAt":"2023-09-12T07:38:37.845Z","UpdatedAt":"2023-09-12T07:41:05.841Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"获取一个cache的 filename 结构体。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L2388\n\n```c\n#define __getname() kmem_cache_alloc(names_cachep, GFP_KERNEL)\n```","collapsed":false,"last":209,"child":0,"next":208},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":297,"CreatedAt":"2024-07-30T06:41:04.135Z","UpdatedAt":"2024-07-30T07:24:16.029Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"如果目标是目录，确保dentry连接到文件系统的根目录，并执行acceptable检查。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/exportfs/expfs.c#L448-L469\n\n```c\nstruct dentry *\nexportfs_decode_fh_raw(struct vfsmount *mnt, struct fid *fid, int fh_len,\n\t\t       int fileid_type,\n\t\t       int (*acceptable)(void *, struct dentry *),\n\t\t       void *context)\n{\n\t...\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t    ...\n\t}\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}\n```","collapsed":false,"last":295,"child":0,"next":299},{"ID":296,"CreatedAt":"2024-07-29T07:33:32.615Z","UpdatedAt":"2024-07-29T07:34:50.919Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"特别地，overlayfs 在设置了 config.nfs_export，会提供 s_export_op 方法。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/overlayfs/super.c#L2030-L2045\n\n```c\nstatic int ovl_fill_super(struct super_block *sb, void *data, int silent)\n{\n\t...\n\t/* Show index=off in /proc/mounts for forced r/o mount */\n\tif (!ofs->indexdir) {\n\t\tofs->config.index = false;\n\t\tif (ovl_upper_mnt(ofs) && ofs->config.nfs_export) {\n\t\t\tpr_warn(\"NFS export requires an index dir, falling back to nfs_export=off.\\n\");\n\t\t\tofs->config.nfs_export = false;\n\t\t}\n\t}\n\n\tif (ofs->config.metacopy && ofs->config.nfs_export) {\n\t\tpr_warn(\"NFS export is not supported with metadata only copy up, falling back to nfs_export=off.\\n\");\n\t\tofs->config.nfs_export = false;\n\t}\n\n\tif (ofs->config.nfs_export)\n\t\tsb->s_export_op = &ovl_export_operations;\n\t...\n}\n```\n\n而默认情况下，nfs_export=N 。这也是为什么 shocker 漏洞无法使用 overlayfs 挂载的rootfs作为reference。\n\n```\n$ cat /sys/module/overlay/parameters/nfs_export \nN\n```\n\n此外 nfs_export 还受 index, redirect_dir参数控制。尝试修改nfs_export启动容器，查看内核日志将发现：\n\n```\n# echo 1 > /sys/module/overlay/parameters/nfs_export \n# dmesg -w\n...\n[1645601.879722] overlayfs: disabling nfs_export due to index=off\n[1645601.935631] overlayfs: NFS export requires \"redirect_dir=nofollow\" on non-upper mount, falling back to nfs_export=off.\n...\n```","collapsed":false,"last":298,"child":0,"next":0}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":334,"CreatedAt":"2024-07-31T08:55:05.719Z","UpdatedAt":"2024-07-31T08:55:05.719Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/master/fs/overlayfs/export.c#L641\n\n```c\nstatic struct dentry *ovl_get_dentry(struct super_block *sb,\n\t\t\t\t     struct dentry *upper,\n\t\t\t\t     struct ovl_path *lowerpath,\n\t\t\t\t     struct dentry *index)\n```","collapsed":false,"last":324,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":269,"CreatedAt":"2023-10-13T10:04:46.743Z","UpdatedAt":"2023-10-16T08:40:38.166Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"out_dput\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4623\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\t...\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putpath:\n...\n}\n```","collapsed":false,"last":262,"child":270,"next":0},{"ID":270,"CreatedAt":"2023-10-16T08:47:43.174Z","UpdatedAt":"2023-10-16T08:49:29.343Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4673\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\t...\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\t...\n}\n```","collapsed":false,"parent":269,"child":276,"next":271},{"ID":276,"CreatedAt":"2023-10-17T03:34:50.865Z","UpdatedAt":"2023-10-17T06:52:15.454Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"在 `done_path_create` 函数中释放了 `new_dentry`, `new_path`\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L3932\n\n```c\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tinode_unlock(path->dentry->d_inode);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}\nEXPORT_SYMBOL(done_path_create);\n```","collapsed":false,"parent":270,"child":280,"next":0},{"ID":0,"markdown":""},{"ID":280,"CreatedAt":"2023-10-17T03:45:39.879Z","UpdatedAt":"2023-10-17T03:59:22.238Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"dput see [here](#card-111)\n\npath_put see [here](#card-253)","collapsed":false,"parent":276,"child":0,"next":279},{"ID":0,"markdown":""},{"ID":263,"CreatedAt":"2023-10-13T09:17:35.462Z","UpdatedAt":"2023-10-13T10:01:58.594Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4654-L4662\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\n\tnew_dentry = filename_create(newdfd, new, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out_putpath;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n    ...\n}\n```","collapsed":false,"last":216,"child":268,"next":265},{"ID":268,"CreatedAt":"2023-10-13T09:55:01.256Z","UpdatedAt":"2023-10-13T09:55:51.859Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L3853\n\n```c\nstatic struct dentry *filename_create(int dfd, struct filename *name,\n\t\t\t\t      struct path *path, unsigned int lookup_flags)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\tstruct qstr last;\n\tbool want_dir = lookup_flags & LOOKUP_DIRECTORY;\n\tunsigned int reval_flag = lookup_flags & LOOKUP_REVAL;\n\tunsigned int create_flags = LOOKUP_CREATE | LOOKUP_EXCL;\n\tint type;\n\tint err2;\n\tint error;\n\n\terror = filename_parentat(dfd, name, reval_flag, path, &last, &type);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (unlikely(type != LAST_NORM))\n\t\tgoto out;\n\n\t/* don't fail immediately if it's r/o, at least try to report other errors */\n\terr2 = mnt_want_write(path->mnt);\n\t/*\n\t * Do the final lookup.  Suppress 'create' if there is a trailing\n\t * '/', and a directory wasn't requested.\n\t */\n\tif (last.name[last.len] && !want_dir)\n\t\tcreate_flags = 0;\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = lookup_one_qstr_excl(&last, path->dentry,\n\t\t\t\t      reval_flag | create_flags);\n\tif (IS_ERR(dentry))\n\t\tgoto unlock;\n\n\terror = -EEXIST;\n\tif (d_is_positive(dentry))\n\t\tgoto fail;\n\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!create_flags)) {\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\tif (unlikely(err2)) {\n\t\terror = err2;\n\t\tgoto fail;\n\t}\n\treturn dentry;\nfail:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nunlock:\n\tinode_unlock(path->dentry->d_inode);\n\tif (!err2)\n\t\tmnt_drop_write(path->mnt);\nout:\n\tpath_put(path);\n\treturn dentry;\n}\n```","collapsed":false,"parent":263,"child":0,"next":0},{"ID":222,"CreatedAt":"2023-09-13T08:05:10.083Z","UpdatedAt":"2023-09-13T08:06:08.317Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L2508-L2512\n\n```c\nint filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t    struct path *path, struct path *root)\n{\n\tint retval;\n    ...\n\tretval = path_lookupat(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(&nd, flags, path);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);\n\n\t...\n\treturn retval;\n}\n```","collapsed":false,"last":221,"child":223,"next":0},{"ID":223,"CreatedAt":"2023-09-13T08:06:42.312Z","UpdatedAt":"2023-09-13T08:07:03.417Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L2467\n\n```c\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\tif (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {\n\t\terr = handle_lookup_down(nd);\n\t\tif (unlikely(err < 0))\n\t\t\ts = ERR_PTR(err);\n\t}\n\n\twhile (!(err = link_path_walk(s, nd)) &&\n\t       (s = lookup_last(nd)) != NULL)\n\t\t;\n\tif (!err && unlikely(nd->flags & LOOKUP_MOUNTPOINT)) {\n\t\terr = handle_lookup_down(nd);\n\t\tnd->state &= ~ND_JUMPED; // no d_weak_revalidate(), please...\n\t}\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY)\n\t\tif (!d_can_lookup(nd->path.dentry))\n\t\t\terr = -ENOTDIR;\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n```","collapsed":false,"parent":222,"child":224,"next":0},{"ID":224,"CreatedAt":"2023-09-13T08:19:07.261Z","UpdatedAt":"2023-09-13T09:54:42.691Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"???\n\n`*path_init()`必须与 `terminate_walk()` 成对使用。\n\nnd->name->name 就是filename结构体中的name，即文件名。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L2346\n\n```c\n/* must be paired with terminate_walk() */\nstatic const char *path_init(struct nameidata *nd, unsigned flags)\n{\n\tint error;\n\tconst char *s = nd->name->name;\n\n\t/* LOOKUP_CACHED requires RCU, ask caller to retry */\n\tif ((flags & (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tif (!*s)\n\t\tflags &= ~LOOKUP_RCU;\n\tif (flags & LOOKUP_RCU)\n\t\trcu_read_lock();\n\telse\n\t\tnd->seq = nd->next_seq = 0;\n\n\tnd->flags = flags;\n\tnd->state |= ND_JUMPED;\n\n\tnd->m_seq = __read_seqcount_begin(&mount_lock.seqcount);\n\tnd->r_seq = __read_seqcount_begin(&rename_lock.seqcount);\n\tsmp_rmb();\n\n\tif (nd->state & ND_ROOT_PRESET) {\n\t\tstruct dentry *root = nd->root.dentry;\n\t\tstruct inode *inode = root->d_inode;\n\t\tif (*s && unlikely(!d_can_lookup(root)))\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\tnd->path = nd->root;\n\t\tnd->inode = inode;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\tnd->root_seq = nd->seq;\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t}\n\t\treturn s;\n\t}\n\n\tnd->root.mnt = NULL;\n\n\t/* Absolute pathname -- fetch the root (LOOKUP_IN_ROOT uses nd->dfd). */\n\tif (*s == '/' && !(flags & LOOKUP_IN_ROOT)) {\n\t\terror = nd_jump_root(nd);\n\t\tif (unlikely(error))\n\t\t\treturn ERR_PTR(error);\n\t\treturn s;\n\t}\n\n\t/* Relative pathname -- get the starting-point it is relative to. */\n\tif (nd->dfd == AT_FDCWD) {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tstruct fs_struct *fs = current->fs;\n\t\t\tunsigned seq;\n\n\t\t\tdo {\n\t\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\t\tnd->path = fs->pwd;\n\t\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t\t} else {\n\t\t\tget_fs_pwd(current->fs, &nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t} else {\n\t\t/* Caller must check execute permissions on the starting path component */\n\t\tstruct fd f = fdget_raw(nd->dfd);\n\t\tstruct dentry *dentry;\n\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\n\t\tdentry = f.file->f_path.dentry;\n\n\t\tif (*s && unlikely(!d_can_lookup(dentry))) {\n\t\t\tfdput(f);\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\t}\n\n\t\tnd->path = f.file->f_path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\tfdput(f);\n\t}\n\n\t/* For scoped-lookups we need to set the root to the dirfd as well. */\n\tif (flags & LOOKUP_IS_SCOPED) {\n\t\tnd->root = nd->path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->root_seq = nd->seq;\n\t\t} else {\n\t\t\tpath_get(&nd->root);\n\t\t\tnd->state |= ND_ROOT_GRABBED;\n\t\t}\n\t}\n\treturn s;\n}\n```","collapsed":false,"parent":223,"child":0,"next":225},{"ID":218,"CreatedAt":"2023-09-13T07:32:36.194Z","UpdatedAt":"2023-09-13T07:57:44.793Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L609\n\n```c\nstatic inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name,\n\t\t\t  const struct path *root)\n{\n\t__set_nameidata(p, dfd, name);\n\tp->state = 0;\n\t...\n}\n```","collapsed":false,"last":220,"child":219,"next":0},{"ID":219,"CreatedAt":"2023-09-13T07:34:38.209Z","UpdatedAt":"2023-09-13T07:34:38.209Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L595\n\n```c\nstatic void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)\n{\n\tstruct nameidata *old = current->nameidata;\n\tp->stack = p->internal;\n\tp->depth = 0;\n\tp->dfd = dfd;\n\tp->name = name;\n\tp->path.mnt = NULL;\n\tp->path.dentry = NULL;\n\tp->total_link_count = old ? old->total_link_count : 0;\n\tp->saved = old;\n\tcurrent->nameidata = p;\n}\n```","collapsed":false,"parent":218,"child":0,"next":0},{"ID":215,"CreatedAt":"2023-09-13T03:50:14.192Z","UpdatedAt":"2023-09-13T03:52:33.346Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`AT_SYMLINK_FOLLOW` 指示是否解析原文件的软链接\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4647-L4648\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\t...\n\tint how = 0;\n\t...\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\n    ...\n}\n```\n","collapsed":false,"last":213,"child":0,"next":0},{"ID":259,"CreatedAt":"2023-10-11T09:41:19.971Z","UpdatedAt":"2023-10-13T08:11:30.157Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"empty.c\n\n```c\n#include \"/usr/include/linux/fcntl.h\"\n// #include \"fcntl.h\"\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    int fd = open(\"file.txt\", O_RDONLY, 0);\n    int result = linkat(fd, \"\", AT_FDCWD, \"link.txt\", AT_EMPTY_PATH);\n    if (result == 0) {\n        printf(\"链接创建成功。\\n\");\n    } else {\n        perror(\"链接创建失败\");\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n```\n$ gcc -o empty empty.c\n$ touch file.txt\n$ ./empty\n$ stat -c %i file.txt link.txt \n3463940\n3463940\n```","collapsed":false,"last":214,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":257,"CreatedAt":"2023-10-11T07:37:59.546Z","UpdatedAt":"2023-10-11T07:38:25.638Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/dcache.c#L663\n\n```c\nstatic inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\n\tif (unlikely(dentry->d_flags & DCACHE_DONTCACHE))\n\t\treturn false;\n\n\t/* retain; LRU fodder */\n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}\n```","collapsed":false,"last":256,"child":0,"next":258},{"ID":0,"markdown":""},{"ID":211,"CreatedAt":"2023-09-13T02:25:04.942Z","UpdatedAt":"2023-09-13T02:30:29.815Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"设置filename结构体其他成员\n* 引用计数 refcnt = 1\n* uptr 指向 用户空间的原始文件名\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L191-L205\n\n```c\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\t...\n\tresult->refcnt = 1;\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\t...\n\t\tif (!(flags & LOOKUP_EMPTY)) {\n\t\t\tputname(result);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n}\n```\n```","collapsed":false,"last":210,"child":212,"next":0},{"ID":212,"CreatedAt":"2023-09-13T02:30:14.208Z","UpdatedAt":"2023-09-13T03:28:47.135Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"记录 filename 到 audit\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/audit.h#L365\n\n```c\n#ifdef CONFIG_AUDITSYSCALL\n...\nstatic inline void audit_getname(struct filename *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_getname(name);\n}\n...\nelse\n...\nstatic inline void audit_getname(struct filename *name)\n{ }\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/kernel/auditsc.c#L2225\n\n```c\n/**\n * __audit_getname - add a name to the list\n * @name: name to add\n *\n * Add a name to the list of audit names for this context.\n * Called from fs/namei.c:getname().\n */\nvoid __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n}\n```","collapsed":false,"parent":211,"child":0,"next":0},{"ID":208,"CreatedAt":"2023-09-12T08:20:20.789Z","UpdatedAt":"2023-09-12T08:21:20.637Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"从用户空间复制字符串\n\nhttps://github.com/torvalds/linux/blob/v6.4/lib/strncpy_from_user.c#L113\n\n```c\n/**\n * strncpy_from_user: - Copy a NUL terminated string from userspace.\n * @dst:   Destination address, in kernel space.  This buffer must be at\n *         least @count bytes long.\n * @src:   Source address, in user space.\n * @count: Maximum number of bytes to copy, including the trailing NUL.\n *\n * Copies a NUL-terminated string from userspace to kernel space.\n *\n * On success, returns the length of the string (not including the trailing\n * NUL).\n *\n * If access to userspace fails, returns -EFAULT (some data may have been\n * copied).\n *\n * If @count is smaller than the length of the string, copies @count bytes\n * and returns @count.\n */\nlong strncpy_from_user(char *dst, const char __user *src, long count)\n{\n\tunsigned long max_addr, src_addr;\n\n\tmight_fault();\n\tif (should_fail_usercopy())\n\t\treturn -EFAULT;\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\n\tmax_addr = TASK_SIZE_MAX;\n\tsrc_addr = (unsigned long)untagged_addr(src);\n\tif (likely(src_addr < max_addr)) {\n\t\tunsigned long max = max_addr - src_addr;\n\t\tlong retval;\n\n\t\t/*\n\t\t * Truncate 'max' to the user-specified limit, so that\n\t\t * we only have one limit we need to check in the loop\n\t\t */\n\t\tif (max > count)\n\t\t\tmax = count;\n\n\t\tkasan_check_write(dst, count);\n\t\tcheck_object_size(dst, count, false);\n\t\tif (user_read_access_begin(src, max)) {\n\t\t\tretval = do_strncpy_from_user(dst, src, count, max);\n\t\t\tuser_read_access_end();\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn -EFAULT;\n}\nEXPORT_SYMBOL(strncpy_from_user);\n```","collapsed":false,"last":206,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":299,"CreatedAt":"2024-07-30T07:26:05.796Z","UpdatedAt":"2024-07-30T07:32:53.42Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"如果不是目录，原本会比较复杂，但因为上下文中的acceptable函数只有return 1，所以是直接返回dentry的。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/exportfs/expfs.c#L469-L560\n\n```c\nstruct dentry *\nexportfs_decode_fh_raw(struct vfsmount *mnt, struct fid *fid, int fh_len,\n\t\t       int fileid_type,\n\t\t       int (*acceptable)(void *, struct dentry *),\n\t\t       void *context)\n{\n\t...\n\tif (d_is_dir(result)) {\n\t    ...\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\t\t...\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}\n```","collapsed":false,"last":297,"child":300,"next":0},{"ID":300,"CreatedAt":"2024-07-30T07:29:32.132Z","UpdatedAt":"2024-07-30T07:31:17.023Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/exportfs/expfs.c#L43\n\n```c\n/*\n * Check if the dentry or any of it's aliases is acceptable.\n */\nstatic struct dentry *\nfind_acceptable_alias(struct dentry *result,\n\t\tint (*acceptable)(void *context, struct dentry *dentry),\n\t\tvoid *context)\n{\n\tstruct dentry *dentry, *toput = NULL;\n\tstruct inode *inode;\n\n\tif (acceptable(context, result))\n\t\treturn result;\n\t...\n}\n```","collapsed":false,"parent":299,"child":0,"next":0}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":271,"CreatedAt":"2023-10-16T08:48:44.715Z","UpdatedAt":"2023-10-16T08:49:47.301Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4674-L4680\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\t...\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\t...\n}\n```","collapsed":false,"last":270,"child":274,"next":272},{"ID":274,"CreatedAt":"2023-10-17T03:17:57.33Z","UpdatedAt":"2023-10-17T03:33:21.959Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"<span style=\"color:red\">TODO: 什么是deleg</span>\n\n> CONFIG_FILE_LOCKING是一个Linux内核配置选项，用于控制文件系统中的文件锁定机制。允许进程在访问文件时对其进行独占性操作，以防止其他进程同时修改或访问该文件。文件锁定在多进程环境中非常有用，可以用于保护共享资源的完整性和一致性。在常见的发行版中， `CONFIG_FILE_LOCKING` 通常是启用的\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/filelock.h#L390\n\n```c\n#ifdef CONFIG_FILE_LOCKING\n...\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tint ret;\n\n\tret = break_deleg(*delegated_inode, O_WRONLY);\n\tiput(*delegated_inode);\n\t*delegated_inode = NULL;\n\treturn ret;\n}\n...\n#else /* !CONFIG_FILE_LOCKING */\n...\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tBUG();\n\treturn 0;\n}\n...\n```","collapsed":false,"parent":271,"child":275,"next":0},{"ID":275,"CreatedAt":"2023-10-17T03:26:57.028Z","UpdatedAt":"2023-10-17T03:29:03.033Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/filelock.h#L364\n\n```c\n#ifdef CONFIG_FILE_LOCKING\n...\nstatic inline int break_deleg(struct inode *inode, unsigned int mode)\n{\n\t/*\n\t * Since this check is lockless, we must ensure that any refcounts\n\t * taken are done before checking i_flctx->flc_lease. Otherwise, we\n\t * could end up racing with tasks trying to set a new lease on this\n\t * file.\n\t */\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode, mode, FL_DELEG);\n\treturn 0;\n}\n```","collapsed":false,"parent":274,"child":0,"next":278},{"ID":279,"CreatedAt":"2023-10-17T03:45:26.197Z","UpdatedAt":"2023-10-17T03:58:39.974Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L778\n```c\nstatic inline void inode_unlock(struct inode *inode)\n{\n\tup_write(&inode->i_rwsem);\n}\n```","collapsed":false,"last":280,"child":282,"next":281},{"ID":282,"CreatedAt":"2023-10-17T06:56:34.086Z","UpdatedAt":"2023-10-17T06:56:34.086Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"```c\n/*\n * release a write lock\n */\nvoid up_write(struct rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\t__up_write(sem);\n}\nEXPORT_SYMBOL(up_write);\n```","collapsed":false,"parent":279,"child":0,"next":0},{"ID":265,"CreatedAt":"2023-10-13T09:20:21.966Z","UpdatedAt":"2023-10-13T09:20:34.026Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4649-L4671\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\n\tidmap = mnt_idmap(new_path.mnt);\n\terror = may_linkat(idmap, &old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n    ...\n}\n```","collapsed":false,"last":263,"child":0,"next":266},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":225,"CreatedAt":"2023-09-13T10:09:02.64Z","UpdatedAt":"2023-09-13T10:09:29.882Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L2458\n\n```c\nstatic int handle_lookup_down(struct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tdget(nd->path.dentry);\n\tnd->next_seq = nd->seq;\n\treturn PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd->path.dentry));\n}\n```","collapsed":false,"last":224,"child":0,"next":226},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":258,"CreatedAt":"2023-10-11T07:39:53.506Z","UpdatedAt":"2023-10-11T07:39:53.506Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/dcache.c#L711\n\n```c\n/*\n * Finish off a dentry we've decided to kill.\n * dentry->d_lock must be held, returns with it unlocked.\n * Returns dentry requiring refcount drop, or NULL if we're done.\n */\nstatic struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t/* negative that became positive */\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t/* we are keeping it, after all */\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}\n```","collapsed":false,"last":257,"child":0,"next":0}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":272,"CreatedAt":"2023-10-16T08:51:09.268Z","UpdatedAt":"2023-10-16T09:14:27.669Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"根据错误信息判断，是否发现了过时的文件信息，如果过时需要重试。设置 `LOOKUP_REVAL` 标志，告知下次查找时，需要强制更新文件信息。跳转至 retry 代码段。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4681-L4685\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\t...\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n    ...\n}\n```","collapsed":false,"last":271,"child":273,"next":0},{"ID":273,"CreatedAt":"2023-10-16T08:57:30.401Z","UpdatedAt":"2023-10-16T09:12:43Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"如果错误类型为 `-ESTALE` ， 且 flags 中没有设置 `LOOKUP_REVAL` ，则表示应该重试。\n\n* 错误类型 `-ESTALE` 意指发现了一些过时的信息，所以需要重试\n* 标志`LOOKUP_REVAL` 表示下一次查找需要强制重新验证文件系统状态\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/namei.h#L112\n\n```c\n/**\n * retry_estale - determine whether the caller should retry an operation\n * @error: the error that would currently be returned\n * @flags: flags being used for next lookup attempt\n *\n * Check to see if the error code was -ESTALE, and then determine whether\n * to retry the call based on whether \"flags\" already has LOOKUP_REVAL set.\n *\n * Returns true if the caller should try the operation again.\n */\nstatic inline bool\nretry_estale(const long error, const unsigned int flags)\n{\n\treturn error == -ESTALE && !(flags & LOOKUP_REVAL);\n}\n```","collapsed":false,"parent":272,"child":0,"next":0},{"ID":278,"CreatedAt":"2023-10-17T03:36:14.242Z","UpdatedAt":"2023-10-17T03:37:23.527Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/inode.c#L1759\n\n```c\n/**\n *\tiput\t- put an inode\n *\t@inode: inode to put\n *\n *\tPuts an inode, dropping its usage count. If the inode use count hits\n *\tzero, the inode is then freed and may also be destroyed.\n *\n *\tConsequently, iput() can sleep.\n */\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}\nEXPORT_SYMBOL(iput);\n```","collapsed":false,"last":275,"child":0,"next":0},{"ID":281,"CreatedAt":"2023-10-17T03:57:24.933Z","UpdatedAt":"2023-10-17T03:58:01.582Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namespace.c#L469\n\n```c\n/**\n * mnt_drop_write - give up write access to a mount\n * @mnt: the mount on which to give up write access\n *\n * Tells the low-level filesystem that we are done performing writes to it and\n * also allows filesystem to be frozen again.  Must be matched with\n * mnt_want_write() call above.\n */\nvoid mnt_drop_write(struct vfsmount *mnt)\n{\n\t__mnt_drop_write(mnt);\n\tsb_end_write(mnt->mnt_sb);\n}\nEXPORT_SYMBOL_GPL(mnt_drop_write);\n```","collapsed":false,"last":279,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":266,"CreatedAt":"2023-10-13T09:20:53.586Z","UpdatedAt":"2023-10-13T09:21:12.601Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4649-L4671\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n    ...\n}\n```","collapsed":false,"last":265,"child":0,"next":267},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":226,"CreatedAt":"2023-09-13T10:12:50.306Z","UpdatedAt":"2023-09-13T10:13:07.208Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L2243\n\n```c\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tint depth = 0; // depth <= nd->depth\n\tint err;\n\n\tnd->last_type = LAST_ROOT;\n\tnd->flags |= LOOKUP_PARENT;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name) {\n\t\tnd->dir_mode = 0; // short-circuit the 'hardening' idiocy\n\t\treturn 0;\n\t}\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tstruct mnt_idmap *idmap;\n\t\tconst char *link;\n\t\tu64 hash_len;\n\t\tint type;\n\n\t\tidmap = mnt_idmap(nd->path.mnt);\n\t\terr = may_lookup(idmap, nd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thash_len = hash_name(nd->path.dentry, name);\n\n\t\ttype = LAST_NORM;\n\t\tif (name[0] == '.') switch (hashlen_len(hash_len)) {\n\t\t\tcase 2:\n\t\t\t\tif (name[1] == '.') {\n\t\t\t\t\ttype = LAST_DOTDOT;\n\t\t\t\t\tnd->state |= ND_JUMPED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype = LAST_DOT;\n\t\t}\n\t\tif (likely(type == LAST_NORM)) {\n\t\t\tstruct dentry *parent = nd->path.dentry;\n\t\t\tnd->state &= ~ND_JUMPED;\n\t\t\tif (unlikely(parent->d_flags & DCACHE_OP_HASH)) {\n\t\t\t\tstruct qstr this = { { .hash_len = hash_len }, .name = name };\n\t\t\t\terr = parent->d_op->d_hash(parent, &this);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\thash_len = this.hash_len;\n\t\t\t\tname = this.name;\n\t\t\t}\n\t\t}\n\n\t\tnd->last.hash_len = hash_len;\n\t\tnd->last.name = name;\n\t\tnd->last_type = type;\n\n\t\tname += hashlen_len(hash_len);\n\t\tif (!*name)\n\t\t\tgoto OK;\n\t\t/*\n\t\t * If it wasn't NUL, we know it was '/'. Skip that\n\t\t * slash, and continue until no more slashes.\n\t\t */\n\t\tdo {\n\t\t\tname++;\n\t\t} while (unlikely(*name == '/'));\n\t\tif (unlikely(!*name)) {\nOK:\n\t\t\t/* pathname or trailing symlink, done */\n\t\t\tif (!depth) {\n\t\t\t\tnd->dir_vfsuid = i_uid_into_vfsuid(idmap, nd->inode);\n\t\t\t\tnd->dir_mode = nd->inode->i_mode;\n\t\t\t\tnd->flags &= ~LOOKUP_PARENT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* last component of nested symlink */\n\t\t\tname = nd->stack[--depth].name;\n\t\t\tlink = walk_component(nd, 0);\n\t\t} else {\n\t\t\t/* not the last component */\n\t\t\tlink = walk_component(nd, WALK_MORE);\n\t\t}\n\t\tif (unlikely(link)) {\n\t\t\tif (IS_ERR(link))\n\t\t\t\treturn PTR_ERR(link);\n\t\t\t/* a symlink to follow */\n\t\t\tnd->stack[depth++].name = name;\n\t\t\tname = link;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(!d_can_lookup(nd->path.dentry))) {\n\t\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\t\tif (!try_to_unlazy(nd))\n\t\t\t\t\treturn -ECHILD;\n\t\t\t}\n\t\t\treturn -ENOTDIR;\n\t\t}\n\t}\n}\n```","collapsed":false,"last":225,"child":227,"next":0},{"ID":227,"CreatedAt":"2023-09-14T05:46:55.204Z","UpdatedAt":"2023-09-14T05:49:02.225Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/namei.h#L18\n\n```c\n/*\n * Type of the last component on LOOKUP_PARENT\n */\nenum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT};\n...\n/* internal use only */\n#define LOOKUP_PARENT\t\t0x0010\n```","collapsed":false,"parent":226,"child":0,"next":228}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":267,"CreatedAt":"2023-10-13T09:21:26.244Z","UpdatedAt":"2023-10-13T09:27:54.889Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L4649-L4671\n\n```c\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n    ...\n\terror = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,\n\t\t\t new_dentry, &delegated_inode);\n    ...\n}\n```","collapsed":false,"last":266,"child":0,"next":0},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":228,"CreatedAt":"2023-09-14T05:54:56.857Z","UpdatedAt":"2023-09-14T08:30:56.69Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"调用 `inode_permission` 检查是否拥有对 inode 的执行权限。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L1712\n\n```c\nstatic inline int may_lookup(struct mnt_idmap *idmap,\n\t\t\t     struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tint err = inode_permission(idmap, nd->inode, MAY_EXEC|MAY_NOT_BLOCK);\n\t\tif (err != -ECHILD || !try_to_unlazy(nd))\n\t\t\treturn err;\n\t}\n\treturn inode_permission(idmap, nd->inode, MAY_EXEC);\n}\n```","collapsed":false,"last":227,"child":229,"next":0},{"ID":229,"CreatedAt":"2023-09-14T06:04:42.295Z","UpdatedAt":"2023-09-14T08:05:03.356Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"本文函数上下文中操作为 `MAY_EXEC`, 不涉及写操作。因此 `sb_permission()` 何 `if (unlikely(mask & MAY_WRITE))` 可忽略。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L503\n\n```c\n/**\n * inode_permission - Check for access rights to a given inode\n * @idmap:\tidmap of the mount the inode was found from\n * @inode:\tInode to check permission on\n * @mask:\tRight to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.  We use fs[ug]id for\n * this, letting us set arbitrary permissions for filesystem access without\n * changing the \"normal\" UIDs which are used for other things.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n */\nint inode_permission(struct mnt_idmap *idmap,\n\t\t     struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t...\n\t}\n\n\tretval = do_inode_permission(idmap, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}\nEXPORT_SYMBOL(inode_permission);\n```","collapsed":false,"parent":228,"child":235,"next":0},{"ID":235,"CreatedAt":"2023-09-14T08:08:09.147Z","UpdatedAt":"2023-09-14T08:08:09.147Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`sb_permission()` 在 super_block 级别检查权限, 禁止向只读文件系统的 常规文件、目录、链接 的写操作。本文的上下文中，操作行为 为 `MAY_EXEC`，不涉及写操作，可跳过。\n\n每个挂载的文件系统都有一个对应的 super_block 结构体。它存储了文件系统的整体信息，如文件系统的状态、属性和挂载点等。一个文件系统所有的inode都要连接到超级块上。\n\nhttps://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L479\n\n```c\n/**\n * sb_permission - Check superblock-level permissions\n * @sb: Superblock of inode to check permission on\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Separate out file-system wide checks from inode-specific permission checks.\n */\nstatic int sb_permission(struct super_block *sb, struct inode *inode, int mask)\n{\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/* Nobody gets write access to a read-only fs. */\n\t\tif (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n```","collapsed":false,"parent":229,"child":239,"next":240},{"ID":239,"CreatedAt":"2023-09-14T08:10:29.162Z","UpdatedAt":"2023-09-14T08:10:29.162Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"##### super_block\n\n每个挂载的文件系统都有一个对应的 super_block 结构体。它存储了文件系统的整体信息，如文件系统的状态、属性和挂载点等。一个文件系统所有的inode都要连接到超级块上。super_block 存储在磁盘上的一个特殊扇区中(因此该对象的名称)。非基于磁盘的文件系统(例如，基于虚拟内存的文件系统，如sysfs)动态生成超级块并将其存储在内存中。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L625\n\n```c\nstruct inode {\n    umode_t\t\t\ti_mode;\n    ...\n    struct super_block\t*i_sb;\n    ...\n}\n```\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L1153\n\n```c\nstruct super_block {\n    ...\n    unsigned long\t\ts_flags;\n    ...\n}\n```","collapsed":false,"parent":235,"child":0,"next":236}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":240,"CreatedAt":"2023-09-14T08:11:17.06Z","UpdatedAt":"2023-09-14T08:11:41.423Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/fs/namei.c#L456\n\n```c\n/**\n * do_inode_permission - UNIX permission checking\n * @idmap:\tidmap of the mount the inode was found from\n * @inode:\tinode to check permissions on\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)\n *\n * We _really_ want to just do \"generic_permission()\" without\n * even looking at the inode->i_op values. So we keep a cache\n * flag in inode->i_opflags, that says \"this has not special\n * permission function, use the fast case\".\n */\nstatic inline int do_inode_permission(struct mnt_idmap *idmap,\n\t\t\t\t      struct inode *inode, int mask)\n{\n\tif (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {\n\t\tif (likely(inode->i_op->permission))\n\t\t\treturn inode->i_op->permission(idmap, inode, mask);\n\n\t\t/* This gets set once for the inode lifetime */\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_FASTPERM;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn generic_permission(idmap, inode, mask);\n}\n```","collapsed":false,"last":235,"child":0,"next":241},{"ID":236,"CreatedAt":"2023-09-14T08:08:27.769Z","UpdatedAt":"2023-09-14T08:08:27.769Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`sb_rdonly()` 函数通过检查 `super_block` 的标志位来确定文件系统是否只读。\n\n注意，`nosuid` 等标志是特定于inode的， 而 `SB_RDONLY` 始终应用于整个文件系统。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L1978\n\n```c\n/*\n * Note that nosuid etc flags are inode-specific: setting some file-system\n * flags just means all the inodes inherit those flags by default. It might be\n * possible to override it selectively if you really wanted to with some\n * ioctl() that is not currently implemented.\n *\n * Exception: SB_RDONLY is always applied to the entire file system.\n *\n * Unfortunately, it is possible to change a filesystems flags with it mounted\n * with files in use.  This means that all of the inodes will not have their\n * i_flags updated.  Hence, i_flags no longer inherit the superblock mount\n * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org\n */\n\nstatic inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & SB_RDONLY; }\n```","collapsed":false,"last":239,"child":237,"next":238},{"ID":237,"CreatedAt":"2023-09-14T08:08:41.548Z","UpdatedAt":"2023-09-14T08:08:41.548Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/fs.h#L1079\n\n```c\n/*\n * sb->s_flags.  Note that these mirror the equivalent MS_* flags where\n * represented in both.\n */\n#define SB_RDONLY       BIT(0)\t/* Mount read-only */\n```","collapsed":false,"parent":236,"child":0,"next":0}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":241,"CreatedAt":"2023-09-14T08:14:21.168Z","UpdatedAt":"2023-09-14T08:14:43.028Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/device_cgroup.h#L17\n\n```c\n#if defined(CONFIG_CGROUP_DEVICE) || defined(CONFIG_CGROUP_BPF)\n...\nstatic inline int devcgroup_inode_permission(struct inode *inode, int mask)\n{\n\tshort type, access = 0;\n\n\tif (likely(!inode->i_rdev))\n\t\treturn 0;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\ttype = DEVCG_DEV_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\ttype = DEVCG_DEV_CHAR;\n\telse\n\t\treturn 0;\n\n\tif (mask & MAY_WRITE)\n\t\taccess |= DEVCG_ACC_WRITE;\n\tif (mask & MAY_READ)\n\t\taccess |= DEVCG_ACC_READ;\n\n\treturn devcgroup_check_permission(type, imajor(inode), iminor(inode),\n\t\t\t\t\t  access);\n}\n...\n#else\nstatic inline int devcgroup_check_permission(short type, u32 major, u32 minor,\n\t\t\t       short access)\n{ return 0; }\n```","collapsed":false,"last":240,"child":0,"next":242},{"ID":238,"CreatedAt":"2023-09-14T08:09:17.985Z","UpdatedAt":"2023-09-14T08:09:17.985Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"`S_ISLNK, S_ISREG, S_ISDIR` 判断给定文件模式是否表示一个符号链接、常规文件、目录\n\n`S_IFMT` 是一个掩码（mask），表示文件类型的位掩码。它的值是八进制数 00170000，这个掩码用于提取文件模式中的文件类型部分。\n\n`S_IFLNK, S_IFREG, S_IFDIR` 是一个常量，表示符号链接（symbolic link）、常规文件（regular file）、目录。它的值分别是八进制数 0120000，0100000， 0040000。用于设置或比较文件模式中的文件类型。\n\n`S_ISLNK,S_ISREG,S_ISDIR` 是一个宏，用于检查给定文件模式 m 的文件类型。它通过将文件模式 m 与文件类型掩码 `S_IFMT` 进行按位与运算，并将结果与常规文件类型常量 进行比较。如果结果相等，则表示文件是相应类型的文件。\n\nhttps://github.com/torvalds/linux/blob/v6.4/include/uapi/linux/stat.h#L21C1-L23\n\n```c\n#define S_IFMT  00170000\n...\n#define S_IFLNK\t 0120000\n#define S_IFREG  0100000\n...\n#define S_IFDIR  0040000\n...\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n```","collapsed":false,"last":236,"child":0,"next":0}],[{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":0,"markdown":""},{"ID":242,"CreatedAt":"2023-09-14T08:17:18.142Z","UpdatedAt":"2023-09-14T08:17:18.142Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/include/linux/security.h#L354\n\n```c\n#ifdef CONFIG_SECURITY\n...\nint security_inode_permission(struct inode *inode, int mask);\n...\n#else /* CONFIG_SECURITY */\n...\nstatic inline int security_inode_permission(struct inode *inode, int mask)\n{\n\treturn 0;\n}\n```","collapsed":false,"last":241,"child":243,"next":0},{"ID":243,"CreatedAt":"2023-09-14T08:17:35.94Z","UpdatedAt":"2023-09-14T08:18:00.581Z","DeletedAt":null,"title":"","function_declare":"","git_url":"","note":"","code":"","markdown":"https://github.com/torvalds/linux/blob/v6.4/security/security.c#L2068\n\n```c\n/**\n * security_inode_permission() - Check if accessing an inode is allowed\n * @inode: inode\n * @mask: access mask\n *\n * Check permission before accessing an inode.  This hook is called by the\n * existing Linux permission function, so a security module can use it to\n * provide additional checking for existing Linux permission checks.  Notice\n * that this hook is called when a file is opened (as well as many other\n * operations), whereas the file_security_ops permission hook is called when\n * the actual read/write operations are performed.\n *\n * Return: Returns 0 if permission is granted.\n */\nint security_inode_permission(struct inode *inode, int mask)\n{\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\treturn call_int_hook(inode_permission, 0, inode, mask);\n}\n```","collapsed":false,"parent":242,"child":0,"next":0}]],"toc":{"headings":[{"nodeName":"H2","innerText":"0. define CAP_DAC_READ_SEARCH  2","id":"0-define-cap_dac_read_search--2"},{"nodeName":"H2","innerText":"1. 基础权限检查：generic_permission","id":"1-基础权限检查generic_permission"},{"nodeName":"H2","innerText":"2. open_by_handle_at(syscall)","id":"2-open_by_handle_atsyscall"},{"nodeName":"H2","innerText":"3. link","id":"3-link"},{"nodeName":"H3","innerText":"3.1 linkat (syscall)","id":"31-linkat-syscall"},{"nodeName":"H4","innerText":"do_linkat","id":"do_linkat"},{"nodeName":"H5","innerText":"CAP, AT_EMPTY_PATH","id":"cap-at_empty_path"},{"nodeName":"H5","innerText":"super_block","id":"super_block"},{"nodeName":"H3","innerText":"3.2 link (syscall)","id":"32-link-syscall"},{"nodeName":"H3","innerText":"3.3 io_linkat(io_uring)","id":"33-io_linkatio_uring"},{"nodeName":"H2","innerText":"4. overlayfs","id":"4-overlayfs"},{"nodeName":"H3","innerText":"4.1 ovl_decode_real_fh","id":"41-ovl_decode_real_fh"},{"nodeName":"H4","innerText":"4.1.1 fh_to_dentry","id":"411-fh_to_dentry"},{"nodeName":"H4","innerText":"4.1.2 ovl_lookup","id":"412-ovl_lookup"},{"nodeName":"H4","innerText":"4.1.3 ovl_verify_index","id":"413-ovl_verify_index"},{"nodeName":"H3","innerText":"4.2 ovl_can_decode_fh","id":"42-ovl_can_decode_fh"},{"nodeName":"H2","innerText":"5. btrfs","id":"5-btrfs"}],"title":{"nodeName":"H1","innerText":"Linux Kernel CAP_DAC_READ_SEARCH 源码分析","id":"linux-kernel-cap_dac_read_search-源码分析"}}}