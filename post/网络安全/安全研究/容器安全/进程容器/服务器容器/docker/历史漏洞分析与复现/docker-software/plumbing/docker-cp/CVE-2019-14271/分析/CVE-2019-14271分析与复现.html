<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author"
    content="">
<meta name="description"
    content="tags: container,漏洞分析 docker CVE-2019-14271分析与复现 一、基本信息    条目 详情 备注     项目地址 https://github.com/moby/moby    发布日期 2019-07-25    CVE-ID CVE-2019-14271    EDB-ID \    exploits swr.cn-southwest-2.myhuaweicloud.com/container_pentest/cve-2019-14271:v0.1
https://bestwing.me/CVE-2019-14271-docker-escape.html
https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/    cvedetails https://www.cvedetails.com/cve/CVE-2019-14271/    官方公告影响范围 v19.03.0    实际影响范围 v18.09.9&amp;lt;=docker&amp;lt;v19.03.8    业界公告修复版本 v19.03.1 紧急修复   实际修复版本 v19.03.8 完整修复   CVSS 9.8 CVSS:3." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/docker-software/plumbing/docker-cp/CVE-2019-14271/%E5%88%86%E6%9E%90/CVE-2019-14271%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html" />


<title>
    
    CVE-2019-14271分析与复现 :: welcome to st0n3&#39;s blog 
    
</title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.de959d61dd13c2cd41136acd491ffb0749779e1afe37b1fed6d5cba0b7e1938d.css">



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="theme-color" content="#252627"><meta itemprop="name" content="CVE-2019-14271分析与复现">
<meta itemprop="description" content="tags: container,漏洞分析 docker CVE-2019-14271分析与复现 一、基本信息    条目 详情 备注     项目地址 https://github.com/moby/moby    发布日期 2019-07-25    CVE-ID CVE-2019-14271    EDB-ID \    exploits swr.cn-southwest-2.myhuaweicloud.com/container_pentest/cve-2019-14271:v0.1
https://bestwing.me/CVE-2019-14271-docker-escape.html
https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/    cvedetails https://www.cvedetails.com/cve/CVE-2019-14271/    官方公告影响范围 v19.03.0    实际影响范围 v18.09.9&lt;=docker&lt;v19.03.8    业界公告修复版本 v19.03.1 紧急修复   实际修复版本 v19.03.8 完整修复   CVSS 9.8 CVSS:3.">
<meta itemprop="datePublished" content="2021-03-30T06:32:34+00:00" />
<meta itemprop="dateModified" content="2021-03-30T06:32:34+00:00" />
<meta itemprop="wordCount" content="1038">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2019-14271分析与复现"/>
<meta name="twitter:description" content="tags: container,漏洞分析 docker CVE-2019-14271分析与复现 一、基本信息    条目 详情 备注     项目地址 https://github.com/moby/moby    发布日期 2019-07-25    CVE-ID CVE-2019-14271    EDB-ID \    exploits swr.cn-southwest-2.myhuaweicloud.com/container_pentest/cve-2019-14271:v0.1
https://bestwing.me/CVE-2019-14271-docker-escape.html
https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/    cvedetails https://www.cvedetails.com/cve/CVE-2019-14271/    官方公告影响范围 v19.03.0    实际影响范围 v18.09.9&lt;=docker&lt;v19.03.8    业界公告修复版本 v19.03.1 紧急修复   实际修复版本 v19.03.8 完整修复   CVSS 9.8 CVSS:3."/>




<meta property="article:published_time" content="2021-03-30 06:32:34 &#43;0000 UTC" />







    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/st0n3</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/aboutme.html">About</a></li><li><a href="/post.html">Blog</a></li><li><a href="/hackerbot">Hackerbot</a></li><li><a href="/skill_tree/">SkillTree</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/docker-software/plumbing/docker-cp/CVE-2019-14271/%E5%88%86%E6%9E%90/CVE-2019-14271%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html">CVE-2019-14271分析与复现</a></h2>

            

            <div class="post-content">
                <hr>
<h2 id="tags-container漏洞分析">tags: container,漏洞分析</h2>
<h1 id="docker-cve-2019-14271分析与复现">docker CVE-2019-14271分析与复现</h1>
<h2 id="一基本信息">一、基本信息</h2>
<table>
<thead>
<tr>
<th>条目</th>
<th>详情</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>项目地址</td>
<td><a href="https://github.com/moby/moby">https://github.com/moby/moby</a></td>
<td></td>
</tr>
<tr>
<td>发布日期</td>
<td>2019-07-25</td>
<td></td>
</tr>
<tr>
<td>CVE-ID</td>
<td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14271">CVE-2019-14271</a></td>
<td></td>
</tr>
<tr>
<td>EDB-ID</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>exploits</td>
<td>swr.cn-southwest-2.myhuaweicloud.com/container_pentest/cve-2019-14271:v0.1<br><a href="https://bestwing.me/CVE-2019-14271-docker-escape.html">https://bestwing.me/CVE-2019-14271-docker-escape.html</a><br><a href="https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/">https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/</a></td>
<td></td>
</tr>
<tr>
<td>cvedetails</td>
<td><a href="https://www.cvedetails.com/cve/CVE-2019-14271/">https://www.cvedetails.com/cve/CVE-2019-14271/</a></td>
<td></td>
</tr>
<tr>
<td>官方公告影响范围</td>
<td>v19.03.0</td>
<td></td>
</tr>
<tr>
<td>实际影响范围</td>
<td>v18.09.9&lt;=docker&lt;v19.03.8</td>
<td></td>
</tr>
<tr>
<td>业界公告修复版本</td>
<td>v19.03.1</td>
<td><a href="https://github.com/moby/moby/pull/39612">紧急修复</a></td>
</tr>
<tr>
<td>实际修复版本</td>
<td>v19.03.8</td>
<td><a href="https://github.com/moby/moby/commit/aa6a9891b09cce3d9004121294301a30d45d998d#diff-630ba09448af522154f38ef7685ef1f44b0f3e9430f80829a03ce24f400f3754">完整修复</a></td>
</tr>
<tr>
<td>CVSS</td>
<td>9.8 CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H</td>
<td></td>
</tr>
<tr>
<td>发现人</td>
<td>docker官方</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="二docker-cp简介">二、docker cp简介</h2>
<p>在容器和宿主机的文件系统直接复制文件。执行cp命令的入口有两个，分别是docker container cp和docker cp, 两者作用相同。命令格式为<code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</code>或<code>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</code>，分别表示从容器内复制文件到宿主机，或从宿主机复制文件到容器内。不可以在容器间复制文件，也不可以在容器外之间复制文件。</p>
<h2 id="三漏洞详情">三、漏洞详情</h2>
<h3 id="1-介绍">1. 介绍</h3>
<p>根据<a href="https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-cp/docker-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">docker cp 源码分析</a>, docker cp命令在容器中打包和解包文件时，分别会调用<code>docker-tar</code>和<code>docker-untar</code>命令。为了防止这两个命令的写操作影响到宿主机，在执行具体操作前，进行了<code>chroot</code>。根据<a href="https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-tardocker-untar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">docker-tar,docker-untar源码分析</a>，我们知道，这些函数是不受<code>capbility</code>,<code>seccomp</code>和<code>LSM</code>的限制的。</p>
<p>受CVE-2019-14271漏洞影响的docker在执行docker cp命令时，docker-tar进程可能在chroot到容器rootfs后，加载nsswitch动态库。攻击者可以将容器内的nsswitch动态库修改为恶意文件，从而获取docker-tar进程权限，实现容器逃逸。</p>
<h3 id="2-影响">2. 影响</h3>
<p>本节(2.影响)的分析较长，且需要对CVE-2019-14271已有了解，因此可以先跳过此节，阅读完全文后再回头阅读。</p>
<h4 id="21-漏洞危害">2.1 漏洞危害</h4>
<p>攻击者可以将容器内的nsswitch动态库修改为恶意文件，从而获取docker-tar进程权限，实现容器逃逸。</p>
<h4 id="22-受影响版本">2.2 受影响版本</h4>
<ul>
<li>静态编译
<ul>
<li>不受影响</li>
</ul>
</li>
<li>非静态编译
<ul>
<li>19.03.0 &lt;= docker &lt; 19.03.1 受影响</li>
<li>docker=18.09.9, 19.03.1 &lt;= docker &lt; 19.03.8 有条件受影响(在宿主机加载nsswitch共享库失败)</li>
<li>18.09.0 &lt;= docker &lt; 18.09.8 不受影响</li>
</ul>
</li>
</ul>
<p>docker=18.09.9, 19.03.1 &lt;= docker &lt; 19.03.8 有条件受影响</p>
<ul>
<li>ubuntu18.04-docker19.03.5 <a href="https://github.com/moby/moby/issues/39449#issuecomment-570729463">https://github.com/moby/moby/issues/39449#issuecomment-570729463</a></li>
<li>debian9.11-docker19.03.5 <a href="https://github.com/moby/moby/issues/39449#issuecomment-572993986">https://github.com/moby/moby/issues/39449#issuecomment-572993986</a></li>
<li>docker19.03.5 <a href="https://github.com/moby/moby/issues/39449#issuecomment-573635439">https://github.com/moby/moby/issues/39449#issuecomment-573635439</a></li>
<li>ubuntu16.04amd64-docker19.03.6 <a href="https://github.com/moby/moby/issues/39449#issuecomment-587187043">https://github.com/moby/moby/issues/39449#issuecomment-587187043</a></li>
<li>Ubuntu16.04.4amd64-dockerce19.03.4 <a href="https://github.com/moby/moby/issues/40211">https://github.com/moby/moby/issues/40211</a></li>
<li>Ubuntu16.04.6-docker19.03.5 <a href="https://github.com/moby/moby/issues/40211#issuecomment-562973937">https://github.com/moby/moby/issues/40211#issuecomment-562973937</a></li>
<li>Ubuntu18.04.5-docker19.03.6 <a href="https://github.com/moby/moby/pull/39612#issuecomment-848854698">https://github.com/moby/moby/pull/39612#issuecomment-848854698</a></li>
</ul>
<p>原因可能是在宿主机加载nsswitch共享库时失败，因此在chroot到容器rootfs后可以重新加载。</p>
<h4 id="23-1809是否受影响">2.3 18.09是否受影响</h4>
<p>TL;DR:
18.09.9未彻底修复; 18.09.0&lt;= docker &lt;=18.09.8不受影响，因其使用的archive/tar库，是从go源码中复制到vendor的代码，这段代码不会去加载nsswitch动态库；go1.11没有所谓的bug</p>
<p>在19.03.1的修复中，docker的开源项目经理thaJeztah在解答“为什么18.09不受影响”时这样解释：</p>
<blockquote>
<p>current versions of 18.09 are not affected because they are still using Go 1.10, and a custom archive implementation.
The 18.09 release branch was recently updated to Go 1.11 (which also removed the custom archive implementation), but no release was done yet with that code, but we had to backport the fix to prevent the next patch release being vulnerable
<a href="https://github.com/moby/moby/pull/39612#issuecomment-517999360">https://github.com/moby/moby/pull/39612#issuecomment-517999360</a></p>
</blockquote>
<p>他认为18.09不受影响，是因为18.09版本使用的go编译器版本是go1.10, 因此不受影响。</p>
<p>互联网上搜到的大部分分析文章，几乎都是 Yuval Avrahami的文章<a href="https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/">docker修复了最严重漏洞CVE-2019-14271</a>的改编或重写。文章中提到：</p>
<blockquote>
<p>Docker is written in Golang. Specifically, the vulnerable Docker version was compiled with Go v1.11. In this version, some packages that contained embedded C code (cgo) would dynamically load shared libraries at runtime.</p>
</blockquote>
<p>他认为，在go1.11版本中，有一些因为cgo引入的代码会动态得加载共享库。因此，我们找到的其他文章几乎都是类似的观点，认为go1.11有一个bug。</p>
<p>thaJeztah与Yuval Avrahami的观点类似，他更进一步得认为，go1.10没有这样的bug。</p>
<p>而在实际的分析中，我发现<strong>go1.11没有所谓的bug</strong>。</p>
<p>我花了相当长的时间，摸索清楚了其中真实的漏洞成因。</p>
<p>我发现，go1.10和go1.11的archive/tar库，都会调用<code>user.LookupId</code>函数, 这个函数会导致nsswitch动态库的加载。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/go1.10/src/archive/tar/stat_unix.go#L39">https://github.com/golang/go/blob/go1.10/src/archive/tar/stat_unix.go#L39</a></li>
<li><a href="https://github.com/golang/go/blob/go1.11/src/archive/tar/stat_unix.go#L39">https://github.com/golang/go/blob/go1.11/src/archive/tar/stat_unix.go#L39</a></li>
</ul>
<p>跟进这个函数，我们最终定位到该函数会调用os/user库的<code>mygetpwuid_r</code>, <code>mygetpwuid_r</code>是nsswitch的<code>getpwuid_r</code>封装。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/go1.10/src/os/user/cgo_lookup_unix.go#L100">https://github.com/golang/go/blob/go1.10/src/os/user/cgo_lookup_unix.go#L100</a></li>
<li><a href="https://github.com/golang/go/blob/go1.11/src/os/user/cgo_lookup_unix.go#L100">https://github.com/golang/go/blob/go1.11/src/os/user/cgo_lookup_unix.go#L100</a></li>
</ul>
<p>在以上的行为上，两者没有差异。与之相反的，go1.11在这个问题上，是做了改进的。</p>
<p>go1.11增加了osusergo的build tag，如果指定了osusergo, 则编译器不会包含这个文件，也不会将相关代码编译进二进制文件中。
<a href="https://github.com/golang/go/blob/go1.11/src/os/user/cgo_lookup_unix.go#L6">https://github.com/golang/go/blob/go1.11/src/os/user/cgo_lookup_unix.go#L6</a></p>
<pre><code>// +build cgo,!osusergo
</code></pre><p>这个改变，是在go1.11才引入的，这解决了历史版本的一个问题，即静态编译不会再因为nsswitch而被打破。</p>
<p><a href="https://github.com/golang/go/commit/62f0127d81">https://github.com/golang/go/commit/62f0127d81</a></p>
<p>这是一个提升，这个提升并不会导致CVE-2019-14271的产生，即, 使用go1.11的安全性不会比使用go1.10的安全性弱。</p>
<p>docker18.09使用go1.10,19.03使用go1.11，这个变化，在理论上不会对是是否加载nsswitch产生变化。但是为什么实际验证中，发现docker18.09不会加载nsswitch动态库呢？</p>
<p>在分析go1.10和go1.11没有发现区别后，我转而分析docker18.09和19.03的区别。</p>
<p>我在<a href="https://github.com/moby/moby/commits/aa6a9891b09cce3d9004121294301a30d45d998d/vendor/archive/tar">19.03分支vendor/archive/tar文件夹相关的commit记录</a>中，发现一个奇怪的现象，即一开始是有vendor/archive/tar的(这表示，go在编译docker时，会优先选在vendor的库，而不是gosrc中的库)。vendor/archive/tar中的代码，不会调用上文提到的<code>user.LookupId</code>函数，也就不会加载nsswitch库。</p>
<p>在相当久之前，这个commit增加了vendor/archive/tar:
<a href="https://github.com/moby/moby/commit/72df48d1ad417401a5ce0a7ee82a3c8ba33e091c#diff-63d9c33e601a452591d5b82832ad760af4d1b4994675659217058ff5638c77e8">https://github.com/moby/moby/commit/72df48d1ad417401a5ce0a7ee82a3c8ba33e091c#diff-63d9c33e601a452591d5b82832ad760af4d1b4994675659217058ff5638c77e8</a></p>
<p>代码如下：未调用<code>user.LookupId</code>函数
<a href="https://github.com/moby/moby/blob/72df48d1ad417401a5ce0a7ee82a3c8ba33e091c/vendor/archive/tar/stat_unix.go#L18">https://github.com/moby/moby/blob/72df48d1ad417401a5ce0a7ee82a3c8ba33e091c/vendor/archive/tar/stat_unix.go#L18</a></p>
<pre><code class="language-go!" data-lang="go!">func statUnix(fi os.FileInfo, h *Header) error {
	sys, ok := fi.Sys().(*syscall.Stat_t)
	if !ok {
		return nil
	}
	h.Uid = int(sys.Uid)
	h.Gid = int(sys.Gid)
	h.AccessTime = statAtime(sys)
	h.ChangeTime = statCtime(sys)
	return nil
}
</code></pre><p>在<a href="https://github.com/golang/go/commit/62f0127d81">Kolyshkin参与的向go1.11中加入osusergo的build tag</a>后不久，Kolyshkin在docker19.03的分支中增加了一个删除vendor/archive/tar的commit。</p>
<p><a href="https://github.com/moby/moby/commit/10fd0516b9f9f04d0f0e2c0755e704303f1a487f#diff-63d9c33e601a452591d5b82832ad760af4d1b4994675659217058ff5638c77e8">https://github.com/moby/moby/commit/10fd0516b9f9f04d0f0e2c0755e704303f1a487f#diff-63d9c33e601a452591d5b82832ad760af4d1b4994675659217058ff5638c77e8</a></p>
<p>删除vendor/archive/tar，意味着会使用go官方archive/tar库。根据上文的分析，如果使用静态编译，并使用osusergo tag，则不会加载nsswitch。如果使用非静态编译，则会调用<code>user.LookupId</code>函数。</p>
<p>就是这个commit直接导致了漏洞的。虽然osusergo的引入，使得静态编译的二进制文件，不会再加载nsswitch动态库。但是对于非静态编译的二进制文件，因为archive/tar的变化，由不加载变成了加载。</p>
<p>回答我们之前的疑问，为什么18.09不会加载nsswitch动态库呢？</p>
<p>因为18.09.8之前一直都有vendor/archive/tar, 因此，go版本的变化不会对其造成影响。</p>
<p><a href="https://github.com/moby/moby/blob/v18.09.8/vendor/archive/tar/stat_unix.go">https://github.com/moby/moby/blob/v18.09.8/vendor/archive/tar/stat_unix.go</a></p>
<p>但v18.09.9，v18.09.9-rc1删除了vendor/archive/tar。
<a href="https://github.com/moby/moby/commit/ebf396050d6e977df2669d5e7d3f38098719f7c2#diff-fc3997a1697456150eac42ad2a2f77c420757ce451fdaf4f95a509cfe6e70cdb">https://github.com/moby/moby/commit/ebf396050d6e977df2669d5e7d3f38098719f7c2#diff-fc3997a1697456150eac42ad2a2f77c420757ce451fdaf4f95a509cfe6e70cdb</a></p>
<p>因此18.09.9中，对于该漏洞只有如下一处修复，可能未修复彻底。
<a href="https://github.com/moby/moby/blob/v18.09.9/pkg/chrootarchive/archive.go#L16">https://github.com/moby/moby/blob/v18.09.9/pkg/chrootarchive/archive.go#L16</a></p>
<pre><code class="language-go!" data-lang="go!">func init() {
	// initialize nss libraries in Glibc so that the dynamic libraries are loaded in the host
	// environment not in the chroot from untrusted files.
	_, _ = user.Lookup(&quot;docker&quot;)
	_, _ = net.LookupHost(&quot;localhost&quot;)
}
</code></pre><h4 id="24-为什么静态编译版本明确不受影响">2.4 为什么静态编译版本明确不受影响？</h4>
<p>在上一个问题中我们有提到，尽管v19.03.0使用go官方的archive/tar库，因为静态编译使用了osusergo这个build tag，也不会将 可能导致加载nsswitch库的 代码编译进来。</p>
<p><a href="https://github.com/moby/moby/blob/v19.03.0/hack/make.sh#L148">https://github.com/moby/moby/blob/v19.03.0/hack/make.sh#L148</a></p>
<pre><code class="language-makefile!" data-lang="makefile!">LDFLAGS_STATIC=''
EXTLDFLAGS_STATIC='-static'
ORIG_BUILDFLAGS=( -tags &quot;autogen netgo osusergo static_build $DOCKER_BUILDTAGS&quot; -installsuffix netgo )
BUILDFLAGS=( ${BUILDFLAGS} &quot;${ORIG_BUILDFLAGS[@]}&quot; )
</code></pre><p><a href="https://github.com/golang/go/commit/62f0127d81">https://github.com/golang/go/commit/62f0127d81</a></p>
<pre><code>// +build cgo,!osusergo
</code></pre><p>docker在v18.09.0开始使用osusergo</p>
<p><a href="https://github.com/moby/moby/commit/70cdb1c66429582ecfdc5abed67189dd90ab7572#diff-50020d1afbd04b368ec34bed9b221ddd792210aac8f130a50e70b74fcb4a7e0c">https://github.com/moby/moby/commit/70cdb1c66429582ecfdc5abed67189dd90ab7572#diff-50020d1afbd04b368ec34bed9b221ddd792210aac8f130a50e70b74fcb4a7e0c</a></p>
<p>即使未使用osusergo, 使用go1.10前(不含)编译的二进制文件，也不会加载nsswitch。
<a href="https://github.com/golang/go/commit/0564e304a6ea394a42929060c588469dbd6f32af#diff-e0ee3deb6e5f67035f8a9808f8ec1af5e8b8926ff4d2de8fd664379fd3a85ae9">https://github.com/golang/go/commit/0564e304a6ea394a42929060c588469dbd6f32af#diff-e0ee3deb6e5f67035f8a9808f8ec1af5e8b8926ff4d2de8fd664379fd3a85ae9</a></p>
<p>那么是否存在未使用osusergo，但是使用了go1.10的版本呢？</p>
<p>docker在v18.05.0-ce-rc1开始使用go1.10
<a href="https://github.com/moby/moby/blob/v18.05.0-ce/Dockerfile#L38">https://github.com/moby/moby/blob/v18.05.0-ce/Dockerfile#L38</a></p>
<p>但vendor/archive/tar早在v17.06.1-ce-rc2就已经引入了，因此静态编译版本不受影响。
<a href="https://github.com/moby/moby/commit/89bacc278b3b6707d57b1b9f95a9221091bbde93">https://github.com/moby/moby/commit/89bacc278b3b6707d57b1b9f95a9221091bbde93</a></p>
<h4 id="25-为什么需要osusergo">2.5 为什么需要osusergo?</h4>
<p>不同版本glibc中的函数实现可能不同，所需的参数不同。静态编译的文件如果需要调用c代码，则可能只能在特定版本的glibc库上运行，这不符合docker设计的初衷。</p>
<h4 id="26-是否影响docker以外的软件">2.6 是否影响docker以外的软件</h4>
<p><span style="color: red">// TODO</span></p>
<p><a href="https://github.com/containers/buildah">https://github.com/containers/buildah</a></p>
<p><a href="https://github.com/containerd/containerd/pull/2476">https://github.com/containerd/containerd/pull/2476</a></p>
<h2 id="四漏洞复现">四、漏洞复现</h2>
<h3 id="1-环境">1. 环境</h3>
<pre><code class="language-!" data-lang="!">st0n3@yoga:~$ docker run -ti ssst0n3/docker_archive:CVE-2019-14271
... // wait for container starting up
Ubuntu 20.04.1 LTS ubuntu ttyS0

ubuntu login: root
Password: root
Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-56-generic x86_64)
...

root@ubuntu:~# docker version
Client: Docker Engine - Community
 Version:           19.03.0
 API version:       1.40
 Go version:        go1.12.5
 Git commit:        aeac949
 Built:             Wed Jul 17 18:15:07 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.0
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.5
  Git commit:       aeac949
  Built:            Wed Jul 17 18:13:43 2019
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.2.6
  GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
 runc:
  Version:          1.0.0-rc8
  GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683
root@ubuntu:~# 
</code></pre><h3 id="2-复现19030">2. 复现(19.03.0)</h3>
<p>确认libnss_files.so版本相同，避免兼容性问题</p>
<pre><code class="language-!" data-lang="!">root@ubuntu:~# ls -lah /lib/x86_64-linux-gnu/libnss_files.so.2 
lrwxrwxrwx 1 root root 20 Aug 17  2020 /lib/x86_64-linux-gnu/libnss_files.so.2 -&gt; libnss_files-2.31.so

root@ubuntu:~# docker run -d -ti --name cve-2019-14271 swr.cn-southwest-2.myhuaweicloud.com/container_pentest/cve-2019-14271:v0.1
e4df8bf1c8594d57285d4670f9f9c6b7e578c0b963071a1b6541e2f16d64ba6e
root@ubuntu:~# docker exec -ti cve-2019-14271 ls -lah /lib/x86_64-linux-gnu/libnss_files.so.2
lrwxrwxrwx 1 root root 20 Aug 17  2020 /lib/x86_64-linux-gnu/libnss_files.so.2 -&gt; libnss_files-2.31.so

</code></pre><p>模拟攻击过程，执行docker cp命令后，可以发现容器内挂载了host_fs</p>
<pre><code>root@ubuntu:~# docker cp cve-2019-14271:/etc/hosts . 
root@ubuntu:~# docker exec -ti cve-2019-14271 ls -lahd /host_fs
drwxr-xr-x 19 root root 4.0K Apr  6 10:06 /host_fs
</code></pre><p>详细exp参考 <a href="https://bestwing.me/CVE-2019-14271-docker-escape.html">https://bestwing.me/CVE-2019-14271-docker-escape.html</a></p>
<h3 id="3-复现docker18099或19031docker19037">3. 复现(docker=18.09.9或19.03.1&lt;=docker&lt;=19.03.7)</h3>
<p>区别在于需要通过删除/etc/nsswitch.conf和libnss_files.so.2等方式，使在宿主机上nsswitch相关动态库加载失败。</p>
<pre><code class="language-!" data-lang="!">root@host $ docker run -ti ssst0n3/docker_archive:ubuntu-20.04_docker-ce-18.09.9_docker-ce-cli-18.09.9_containerd.io-1.2.2-3_runc-1.0.0-rc6
ubuntu login: root
Password: root
root@ubuntu:~# docker version
Client:
 Version:           18.09.9
 API version:       1.39
 Go version:        go1.11.13
 Git commit:        039a7df9ba
 Built:             Wed Sep  4 17:24:10 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.9
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.11.13
  Git commit:       039a7df
  Built:            Wed Sep  4 16:19:38 2019
  OS/Arch:          linux/amd64
  Experimental:     false

</code></pre><pre><code class="language-!" data-lang="!">root@ubuntu:~# rm /lib/x86_64-linux-gnu/libnss_files.so.2
root@ubuntu:~# rm /etc/nsswitch.conf
root@ubuntu:~# docker run -d -ti --name cve-2019-14271 swr.cn-southwest-2.myhuaweicloud.com/container_pentest/cve-2019-14271:v0.1
root@ubuntu:~# docker cp cve-2019-14271:/etc/hosts .
root@ubuntu:~# docker exec -ti cve-2019-14271 ls -lahd /host_fs
drwxr-xr-x 19 root root 4.0K May 27 03:12 /host_fs
root@ubuntu:~# docker exec -ti cve-2019-14271 cat /host_fs/etc/hostname
ubuntu
</code></pre><h2 id="五漏洞分析">五、漏洞分析</h2>
<h3 id="1-docker-cp流程分析">1. docker cp流程分析</h3>
<p>参见：
<a href="https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-cp/docker-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-cp/docker-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</a></p>
<h3 id="2-docker-tar与docker-untar">2. docker-tar与docker-untar</h3>
<p>根据docker cp的源码分析，我们已经知道docker-tar, docker-untar的存在，也需要理解一下这两个命令的执行过程，参见：</p>
<p><a href="https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-tardocker-untar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-tardocker-untar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</a></p>
<p>docker-tar和dockerd共用一个二进制，基于docker的reexec库实现，有一个简单的调试技巧，可以跳过docker cp的前序步骤，直接进入docker-tar的逻辑：</p>
<p>因为reexec是以cmdline选择命令代码的，所以可以通过复制或链接，得到一个docker-tar。</p>
<pre><code class="language-!" data-lang="!">root@ubuntu:~# which dockerd
/usr/bin/dockerd
root@ubuntu:~# ln -sf /usr/bin/dockerd /usr/bin/docker-tar
root@ubuntu:~# docker-tar --help
Usage of docker-tar:
</code></pre><p>使用strace可以调试docker-tar执行时的系统调用</p>
<pre><code class="language-!" data-lang="!">echo &quot;{}&quot; &gt; /tmp/json
mkdir /tmp/test
cp /etc/hosts /tmp/test/
strace -r -f docker-tar &lt;/tmp/json /test/ /tmp/ &gt; /tmp/test.tar
strace -r -f -k -e trace=open,openat,chdir,chroot docker-tar &lt;/tmp/json /test/ /tmp/ &gt; /tmp/test.tar
</code></pre><p>docker-untar的调试类似</p>
<pre><code class="language-!" data-lang="!">echo &quot;{}&quot; &gt; /tmp/json
docker-tar &lt;/tmp/json /etc/hosts /tmp/ &gt; /tmp/hosts.tar
strace -f docker-untar &lt;/tmp/hosts.tar  3&lt;/tmp/json /etc/ /tmp/
</code></pre><p>如果要gdb调试，可以将dockerd中的&quot;docker-tar&quot;字符串等长度替换，并dockerd复制到对应路径。这样gdb调用的进程的cmdline就一致了。</p>
<p>例如</p>
<pre><code>sed -i s@docker-tar@/bin/r-tar@g dockerd
cp dockerd /bin/r-tar
</code></pre><p>在gdb内，使用set args指定参数</p>
<pre><code>set args &lt;/tmp/json /test/ /tmp/ &gt; /tmp/test.tar
</code></pre><h3 id="3-docker-tar-chroot">3. docker-tar chroot</h3>
<p>docker-tar进程是一个特权进程，为了避免对宿主机造成影响，会chroot到容器的rootfs内执行打包动作
<a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L135-L137">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L135-L137</a></p>
<pre><code>func tar() {
    ...
    if err := realChroot(root); err != nil {
        fatal(err)
    }
    ...
    rdr, err := archive.TarWithOptions(src, &amp;options)
</code></pre><h3 id="4-docker-tar-为什么要加载nsswitch">4. docker-tar 为什么要加载nsswitch?</h3>
<p>上面的源码分析已经涉及到了，具体原因是：</p>
<p>docker-tar调用的archive/tar库在收集文件所属用户信息时，调用了glibc的mygetpwuid_r函数，这个函数是基于nsswitch框架开发的，在执行时会动态加载nsswitch相关库（不在文件头中列出，执运行时动态加载）。</p>
<p><a href="https://github.com/golang/go/blob/go1.11/src/os/user/cgo_lookup_unix.go#L100">https://github.com/golang/go/blob/go1.11/src/os/user/cgo_lookup_unix.go#L100</a></p>
<pre><code class="language-!" data-lang="!">return syscall.Errno(C.mygetpwuid_r(C.int(uid),
			&amp;pwd,
			(*C.char)(buf.ptr),
			C.size_t(buf.size),
			&amp;result))
</code></pre><p>如果在容器的rootfs内加载nsswitch动态库，则有可能会加载恶意的文件，导致docker-tar进程权限被获取。</p>
<h3 id="5-如何判断是否编译了会加载nsswitch的代码">5. 如何判断是否编译了会加载nsswitch的代码？</h3>
<p><code>strings /usr/bin/dockerd |grep mygetpwuid_r</code></p>
<p>注：编译了但不一定会执行</p>
<h3 id="6-docker-untar为什么不受影响">6. docker-untar为什么不受影响？</h3>
<p>因为未执行会加载nsswitch的代码，通常只有在解析host和user,group信息时才会加载nsswitch。</p>
<h2 id="六漏洞修复分析">六、漏洞修复分析</h2>
<h3 id="1-修复分析">1. 修复分析</h3>
<p>v19.03.1版本，在chroot前就主动执行了user.Lookup和net.Lookup,这样会提前加载nsswitch动态库，在chroot后就不需要再次加载。
<a href="https://github.com/moby/moby/pull/39612">https://github.com/moby/moby/pull/39612</a></p>
<pre><code class="language-!" data-lang="!">func init() {
    // initialize nss libraries in Glibc so that the dynamic libraries are loaded in the host
    // environment not in the chroot from untrusted files.
    _, _ = user.Lookup(&quot;docker&quot;)
    _, _ = net.LookupHost(&quot;localhost&quot;)
}
</code></pre><p>但版本发布后，仍有用户反馈存在同样的问题，原因我们在上文有过分析。后续docker在v19.03.8进行了完整修复。</p>
<h3 id="2-完整修复">2. 完整修复</h3>
<p>为了不打破静态编译，docker前期已经应用了名为osusergo的build tag, 这保证了静态编译的版本不会受此风险。
<a href="https://github.com/golang/go/commit/62f0127d81">https://github.com/golang/go/commit/62f0127d81</a></p>
<p><a href="https://github.com/moby/moby/commit/70cdb1c66429582ecfdc5abed67189dd90ab7572#diff-50020d1afbd04b368ec34bed9b221ddd792210aac8f130a50e70b74fcb4a7e0c">https://github.com/moby/moby/commit/70cdb1c66429582ecfdc5abed67189dd90ab7572#diff-50020d1afbd04b368ec34bed9b221ddd792210aac8f130a50e70b74fcb4a7e0c</a></p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/hack/make.sh#L115">https://github.com/moby/moby/blob/v20.10.6/hack/make.sh#L115</a></p>
<p>静态编译的二进制文件，不会加载nsswitch动态库。</p>
<p>但是动态编译的版本，例如ubuntu的<code>docker.io</code>，<code>docker-ce</code>，可能还是会加载。</p>
<p>所以，又将不会加载nsswitch动态库的旧版本archive/tar放入了vendor中。
<a href="https://github.com/moby/moby/commit/aa6a9891b09cce3d9004121294301a30d45d998d#diff-630ba09448af522154f38ef7685ef1f44b0f3e9430f80829a03ce24f400f3754">https://github.com/moby/moby/commit/aa6a9891b09cce3d9004121294301a30d45d998d#diff-630ba09448af522154f38ef7685ef1f44b0f3e9430f80829a03ce24f400f3754</a></p>
<p>至此可以认为彻底解决了此漏洞。</p>
<h3 id="3-当前修复局限性">3. 当前修复局限性</h3>
<p>尽管不再存在此漏洞,但是当前将archive/tar复制到vendor下，显然不够优雅。也是不可持续的——如果golang官方做了某关键更新，docker还需要重点监测并维护。</p>
<p>当然，这些都不是问题，但是作为go语言的明星项目，docker在未来很可能会考虑一种优雅的实现，届时可能会导致新的漏洞产生。正如，CVE-2019-14271的产生一样。</p>
<h3 id="4-future">4. future</h3>
<p>和我们预测得一样，docker已经把 将archive/tar从vendor中移除的工作，加入了 roadmap。</p>
<p><a href="https://github.com/moby/moby/issues/42402">https://github.com/moby/moby/issues/42402</a></p>
<blockquote>
<p>commit aa6a989 (19.03 branch) and #40672 (master / 20.10) re-introduced a local copy of go&rsquo;s archive/tar package, with a patch applied patches/0001-archive-tar-do-not-populate-user-group-names.patch.</p>
<p>This patch was applied for the 19.03.8 release to improve mitigation for CVE-2019-14271 for some nscd configuration.</p>
<p>We should try to get rid of this fork again.</p>
<p>The discussion on #40672 (comment) mentioned we should open a ticket / pull request in upstream Go to make this functionality &ldquo;optional&rdquo;, but I think @tonistiigi also had alternatives in mind to address it.</p>
</blockquote>
<h2 id="六总结">六、总结</h2>
<h3 id="1-漏洞产生经过">1. 漏洞产生经过</h3>
<p>根据我们一连串的分析，像查案一样，我们似乎可以推测出事件发生的大致时间线：</p>
<ol>
<li>docker即将升级go至1.11,开发者开始做一些准备工作，其中移除vendor/archive/tar就是顺便要解决的目标</li>
<li>如果要使用go官方的archive/tar, 则必须要先推动golang实现osusergo，这样可以保证静态编译的二进制文件不会加载nsswitch</li>
<li>golang增加了osusergo</li>
<li>docker升级go至1.11,并移除vendor/archive/tar</li>
<li>忽略了非静态编译场景，glibc加载nsswitch的情况，导致漏洞产生</li>
<li>在chroot前主动加载nsswitch，规避漏洞</li>
<li>有众多issues报告问题仍然存在</li>
<li>恢复vendor/archive/tar</li>
</ol>
<h3 id="2-受影响的条件">2. 受影响的条件</h3>
<ol>
<li>使用go1.10及以上版本编译</li>
<li>非静态编译，或静态编译但未使用osusergo tag (这要求编译环境和执行环境的glibc环境相同，否则可能glibc的函数实现和代码中的不一致)</li>
<li>docker使用go官方archive/tar库</li>
</ol>
<h3 id="3-docker-cp漏洞挖掘">3. docker cp漏洞挖掘</h3>
<p>我们在docker cp相关的漏洞中，多次发现同一个关键因素——特权进程。试想，如果docker-tar的权限与容器的进程一致，即使存在相关问题，也不会有利用价值。要彻底解决这类问题，应从设计角度，限制此类进程权限，否则未来可能仍然会出现类似漏洞。</p>
<p>例如：
docker-tar进程是否会、何时会加载nsswitch，是glibc决定的，如果glibc的行为有变化，则可能会导致CVE-2019-14271重新生效。例如glibc2.33引入的reloadable nsswitch特性，即可支持在检测到nsswitch配置变化后，自动加载nsswitch，这样的功能是可能导致docker的漏洞的。</p>
<p>好在glibc社区已经提前发现了这个风险，做了限制，chroot后不主动加载nsswitch。</p>
<p><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=12459">https://sourceware.org/bugzilla/show_bug.cgi?id=12459</a>
<a href="https://github.com/bminor/glibc/commit/429029a73ec2dba7f808f69ec8b9e3d84e13e804">https://github.com/bminor/glibc/commit/429029a73ec2dba7f808f69ec8b9e3d84e13e804</a></p>
<p>但是，这样的问题仍然让我们心有余悸。相信如果docker-tar等进程不改变这一关键性质，未来可能还会出现相关漏洞。</p>
<h2 id="附">附</h2>
<h3 id="参考链接">参考链接</h3>
<ul>
<li>original issue: <a href="https://github.com/moby/moby/issues/39449">https://github.com/moby/moby/issues/39449</a></li>
</ul>
<h3 id="git时间线">git时间线</h3>
<ul>
<li>docker v17.06.1-ce-rc2 起增加vendor/archive/tar
<ul>
<li><a href="https://github.com/moby/moby/commit/89bacc278b3b6707d57b1b9f95a9221091bbde93">https://github.com/moby/moby/commit/89bacc278b3b6707d57b1b9f95a9221091bbde93</a></li>
<li><a href="https://github.com/moby/moby/commit/72df48d1ad417401a5ce0a7ee82a3c8ba33e091c">https://github.com/moby/moby/commit/72df48d1ad417401a5ce0a7ee82a3c8ba33e091c</a></li>
</ul>
</li>
<li>docker v18.05.0-ce-rc1 起使用go1.10
<ul>
<li><a href="https://github.com/moby/moby/blob/v18.05.0-ce-rc1/Dockerfile#L38">https://github.com/moby/moby/blob/v18.05.0-ce-rc1/Dockerfile#L38</a></li>
<li><a href="https://github.com/moby/moby/commit/be8885525c4d1ef4a13bbd6396f60e8657bc5573#diff-dd2c0eb6ea5cfc6c4bd4eac30934e2d5746747af48fef6da689e85b752f39557">https://github.com/moby/moby/commit/be8885525c4d1ef4a13bbd6396f60e8657bc5573#diff-dd2c0eb6ea5cfc6c4bd4eac30934e2d5746747af48fef6da689e85b752f39557</a></li>
</ul>
</li>
<li>docker v18.09.0起使用osusergo
<ul>
<li><a href="https://github.com/moby/moby/commit/70cdb1c66429582ecfdc5abed67189dd90ab7572#diff-50020d1afbd04b368ec34bed9b221ddd792210aac8f130a50e70b74fcb4a7e0c">https://github.com/moby/moby/commit/70cdb1c66429582ecfdc5abed67189dd90ab7572#diff-50020d1afbd04b368ec34bed9b221ddd792210aac8f130a50e70b74fcb4a7e0c</a></li>
</ul>
</li>
<li>go1.11增加名为osusergo的build tag
<ul>
<li><a href="https://github.com/golang/go/commit/62f0127d81">https://github.com/golang/go/commit/62f0127d81</a></li>
</ul>
</li>
<li>docker v18.09.9起升级go至1.11,删除了vendor/archive/tar
<ul>
<li><a href="https://github.com/moby/moby/commit/ebf396050d6e977df2669d5e7d3f38098719f7c2#diff-fc3997a1697456150eac42ad2a2f77c420757ce451fdaf4f95a509cfe6e70cdb">https://github.com/moby/moby/commit/ebf396050d6e977df2669d5e7d3f38098719f7c2#diff-fc3997a1697456150eac42ad2a2f77c420757ce451fdaf4f95a509cfe6e70cdb</a></li>
<li><a href="https://github.com/moby/moby/commit/10fd0516b9f9f04d0f0e2c0755e704303f1a487f#diff-63d9c33e601a452591d5b82832ad760af4d1b4994675659217058ff5638c77e8">https://github.com/moby/moby/commit/10fd0516b9f9f04d0f0e2c0755e704303f1a487f#diff-63d9c33e601a452591d5b82832ad760af4d1b4994675659217058ff5638c77e8</a></li>
</ul>
</li>
<li>docker v19.03.0 收到issue报告，分配漏洞编号CVE-2019-14271
<ul>
<li><a href="https://github.com/moby/moby/issues/39449">https://github.com/moby/moby/issues/39449</a></li>
</ul>
</li>
<li>docker v19.03.1起，在chroot前主动加载nsswitch
<ul>
<li><a href="https://github.com/moby/moby/pull/39612">https://github.com/moby/moby/pull/39612</a></li>
</ul>
</li>
<li>docker v19.03.8起，恢复vendor/archive/tar
<ul>
<li><a href="https://github.com/moby/moby/commit/aa6a9891b09cce3d9004121294301a30d45d998d#diff-630ba09448af522154f38ef7685ef1f44b0f3e9430f80829a03ce24f400f3754">https://github.com/moby/moby/commit/aa6a9891b09cce3d9004121294301a30d45d998d#diff-630ba09448af522154f38ef7685ef1f44b0f3e9430f80829a03ce24f400f3754</a></li>
</ul>
</li>
</ul>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            
            <span></span>
            <span> <a href="/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/st0n3">st0n3</a></span>
            <span>Based on <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      
      jax: ["input/TeX", "output/CommonHTML"],
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": { fonts: ["TeX"] },
      displayAlign: "left"
    });
  </script>

<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_CHTML"></script>


</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.4c3fb12a087ceed4a52cb5d57068a9795c7069617a01ca70f788052ad66e1791779e6c72686e1dc0ca13dc03b0203204b6566bb0dd1ee80de2b7ff4d8fe53db2.js" integrity="sha512-TD&#43;xKgh87tSlLLXVcGipeVxwaWF6Acpw94gFKtZuF5F3nmxyaG4dwMoT3AOwIDIEtlZrsN0e6A3it/9Nj&#43;U9sg=="></script>



    </body>
</html>
