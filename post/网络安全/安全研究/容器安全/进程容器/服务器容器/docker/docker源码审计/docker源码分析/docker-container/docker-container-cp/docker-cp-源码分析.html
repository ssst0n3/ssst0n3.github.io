<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author"
    content="">
<meta name="description"
    content="tags: container,源码分析 docker cp 源码分析 本文编写时，最新release为v20.10.6, 因此代码均为v20.10.6分支的代码
1. docker cp简介 在容器和宿主机的文件系统直接复制文件。执行cp命令的入口有两个，分别是docker container cp和docker cp, 两者作用相同， 后者可能在未来会被删除。
https://docs.docker.com/engine/reference/commandline/container_cp/
2. 源码入口位置 由cli接收cp命令参数,发送至docker engine api
cli与engine api的代码入口分别位于:
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go
3. docker-cli 执行cp命令的两个入口分别位于
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cmd.go#L20
func NewContainerCommand(dockerCli command.Cli) *cobra.Command { ... cmd.AddCommand( ... NewCopyCommand(dockerCli), ... https://github.com/docker/cli/blob/v20.10.6/cli/command/commands/commands.go#L96
func AddCommands(cmd *cobra.Command, dockerCli command.Cli) { ... cmd.AddCommand( ... hide(container.NewCopyCommand(dockerCli)), ... 两者分别用docker cp命令和docker container cp命令，两者都调用同一个函数NewCopyCommand。
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
func NewCopyCommand(dockerCli command.Cli) *cobra.Command { var opts copyOptions cmd := &amp;amp;cobra.Command{ ... Args: cli." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-cp/docker-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" />


<title>
    
    docker cp 源码分析 :: welcome to st0n3&#39;s blog 
    
</title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.de959d61dd13c2cd41136acd491ffb0749779e1afe37b1fed6d5cba0b7e1938d.css">



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="theme-color" content="#252627"><meta itemprop="name" content="docker cp 源码分析">
<meta itemprop="description" content="tags: container,源码分析 docker cp 源码分析 本文编写时，最新release为v20.10.6, 因此代码均为v20.10.6分支的代码
1. docker cp简介 在容器和宿主机的文件系统直接复制文件。执行cp命令的入口有两个，分别是docker container cp和docker cp, 两者作用相同， 后者可能在未来会被删除。
https://docs.docker.com/engine/reference/commandline/container_cp/
2. 源码入口位置 由cli接收cp命令参数,发送至docker engine api
cli与engine api的代码入口分别位于:
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go
3. docker-cli 执行cp命令的两个入口分别位于
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cmd.go#L20
func NewContainerCommand(dockerCli command.Cli) *cobra.Command { ... cmd.AddCommand( ... NewCopyCommand(dockerCli), ... https://github.com/docker/cli/blob/v20.10.6/cli/command/commands/commands.go#L96
func AddCommands(cmd *cobra.Command, dockerCli command.Cli) { ... cmd.AddCommand( ... hide(container.NewCopyCommand(dockerCli)), ... 两者分别用docker cp命令和docker container cp命令，两者都调用同一个函数NewCopyCommand。
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
func NewCopyCommand(dockerCli command.Cli) *cobra.Command { var opts copyOptions cmd := &amp;cobra.Command{ ... Args: cli.">
<meta itemprop="datePublished" content="2021-04-27T08:27:47+00:00" />
<meta itemprop="dateModified" content="2021-04-27T08:27:47+00:00" />
<meta itemprop="wordCount" content="1726">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="docker cp 源码分析"/>
<meta name="twitter:description" content="tags: container,源码分析 docker cp 源码分析 本文编写时，最新release为v20.10.6, 因此代码均为v20.10.6分支的代码
1. docker cp简介 在容器和宿主机的文件系统直接复制文件。执行cp命令的入口有两个，分别是docker container cp和docker cp, 两者作用相同， 后者可能在未来会被删除。
https://docs.docker.com/engine/reference/commandline/container_cp/
2. 源码入口位置 由cli接收cp命令参数,发送至docker engine api
cli与engine api的代码入口分别位于:
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go
3. docker-cli 执行cp命令的两个入口分别位于
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cmd.go#L20
func NewContainerCommand(dockerCli command.Cli) *cobra.Command { ... cmd.AddCommand( ... NewCopyCommand(dockerCli), ... https://github.com/docker/cli/blob/v20.10.6/cli/command/commands/commands.go#L96
func AddCommands(cmd *cobra.Command, dockerCli command.Cli) { ... cmd.AddCommand( ... hide(container.NewCopyCommand(dockerCli)), ... 两者分别用docker cp命令和docker container cp命令，两者都调用同一个函数NewCopyCommand。
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
func NewCopyCommand(dockerCli command.Cli) *cobra.Command { var opts copyOptions cmd := &amp;cobra.Command{ ... Args: cli."/>




<meta property="article:published_time" content="2021-04-27 08:27:47 &#43;0000 UTC" />







    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/st0n3</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/aboutme.html">About</a></li><li><a href="/post.html">Blog</a></li><li><a href="/hackerbot">Hackerbot</a></li><li><a href="/skill_tree/">SkillTree</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-cp/docker-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">docker cp 源码分析</a></h2>

            

            <div class="post-content">
                <hr>
<h2 id="tags-container源码分析">tags: container,源码分析</h2>
<h1 id="docker-cp-源码分析">docker cp 源码分析</h1>
<p><small>本文编写时，最新release为v20.10.6, 因此代码均为v20.10.6分支的代码</small></p>
<h2 id="1-docker-cp简介">1. docker cp简介</h2>
<p>在容器和宿主机的文件系统直接复制文件。执行cp命令的入口有两个，分别是<code>docker container cp</code>和<code>docker cp</code>, 两者作用相同， 后者可能在未来会被删除。</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/container_cp/">https://docs.docker.com/engine/reference/commandline/container_cp/</a></p>
<h2 id="2-源码入口位置">2. 源码入口位置</h2>
<p>由cli接收cp命令参数,发送至docker engine api</p>
<p>cli与engine api的代码入口分别位于:</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43</a></p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go">https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go</a></p>
<h2 id="3-docker-cli">3. docker-cli</h2>
<p>执行cp命令的两个入口分别位于</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cmd.go#L20">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cmd.go#L20</a></p>
<pre><code class="language-go=" data-lang="go=">func NewContainerCommand(dockerCli command.Cli) *cobra.Command {
    ...
	cmd.AddCommand(
    ...
		NewCopyCommand(dockerCli),
    ...
</code></pre><p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/commands/commands.go#L96">https://github.com/docker/cli/blob/v20.10.6/cli/command/commands/commands.go#L96</a></p>
<pre><code class="language-go=" data-lang="go=">func AddCommands(cmd *cobra.Command, dockerCli command.Cli) {
    ...
    cmd.AddCommand(
    ...
        hide(container.NewCopyCommand(dockerCli)),
    ...
</code></pre><p>两者分别用docker cp命令和docker container cp命令，两者都调用同一个函数<code>NewCopyCommand</code>。</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43</a></p>
<pre><code class="language-go=" data-lang="go=">func NewCopyCommand(dockerCli command.Cli) *cobra.Command {
	var opts copyOptions

	cmd := &amp;cobra.Command{
        ...
		Args: cli.ExactArgs(2),
		RunE: func(cmd *cobra.Command, args []string) error {
			if args[0] == &quot;&quot; {
				return errors.New(&quot;source can not be empty&quot;)
			}
			if args[1] == &quot;&quot; {
				return errors.New(&quot;destination can not be empty&quot;)
			}
			opts.source = args[0]
			opts.destination = args[1]
			return runCopy(dockerCli, opts)
		},
	}

	flags := cmd.Flags()
	flags.BoolVarP(&amp;opts.followLink, &quot;follow-link&quot;, &quot;L&quot;, false, &quot;Always follow symbol link in SRC_PATH&quot;)
	flags.BoolVarP(&amp;opts.copyUIDGID, &quot;archive&quot;, &quot;a&quot;, false, &quot;Archive mode (copy all uid/gid information)&quot;)
	return cmd
}
</code></pre><p>该函数定义了cp命令的参数, 具体实现调用<code>runCopy</code>函数。仅支持从容器复制到宿主机、从宿主机复制到容器，分别调用<code>copyFromContainer</code>，<code>copyToContainer</code>，不支持容器间复制，也不支持仅在宿主机间复制。</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L77">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L77</a></p>
<pre><code class="language-go=" data-lang="go=">func runCopy(dockerCli command.Cli, opts copyOptions) error {
	srcContainer, srcPath := splitCpArg(opts.source)
	destContainer, destPath := splitCpArg(opts.destination)

    ...

	switch direction {
	case fromContainer:
		return copyFromContainer(ctx, dockerCli, copyConfig)
	case toContainer:
		return copyToContainer(ctx, dockerCli, copyConfig)
	case acrossContainers:
		return errors.New(&quot;copying between containers is not supported&quot;)
	default:
		return errors.New(&quot;must specify at least one container source&quot;)
</code></pre><p><code>copyFromContainer</code>和<code>copyToContainer</code>主要负责拼装参数,并调用docker engine api</p>
<h3 id="31-copyfromcontainer">3.1 copyFromContainer</h3>
<p>如果执行cp命令时设置了followLink选项，则会将srcPath更新为软链接指向的地址。</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L137-L154">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L137-L154</a></p>
<pre><code class="language-go=" data-lang="go=">if copyConfig.followLink {
    srcStat, err := client.ContainerStatPath(ctx, copyConfig.container, srcPath)

    // If the destination is a symbolic link, we should follow it.
    if err == nil &amp;&amp; srcStat.Mode&amp;os.ModeSymlink != 0 {
        linkTarget := srcStat.LinkTarget
        ...
        srcPath = linkTarget
    }

}
</code></pre><p>其中，获取软链接指向地址是由<a href="https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L18">ContainerStatPath</a>函数通过调用api实现的。</p>
<p>实际复制的操作是由<a href="https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L63">CopyFromContainer</a>函数通过调用api实现的。</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L156">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L156</a></p>
<pre><code class="language-go=" data-lang="go=">content, stat, err := client.CopyFromContainer(ctx, copyConfig.container, srcPath)
</code></pre><p>下面将调用api得到的输出复制到dstPath。</p>
<p>如果dstPath是<code>-</code>, 就会直接输出到stdout。
<a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L162-L179">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L162-L179</a></p>
<pre><code class="language-go=" data-lang="go=">if dstPath == &quot;-&quot; {
    _, err = io.Copy(dockerCli.Out(), content)
    return err
}
</code></pre><p>如果之前使用了followLink选项，因为更改了srcPath, 所以要把打包文件中的路径修正回原始的路径</p>
<pre><code class="language-go=" data-lang="go=">preArchive := content
if len(srcInfo.RebaseName) != 0 {
    _, srcBase := archive.SplitPathDirEntry(srcInfo.Path)
    preArchive = archive.RebaseArchiveEntries(content, srcBase, srcInfo.RebaseName)
}
</code></pre><p>最后将打包文件复制到目的路径。</p>
<pre><code class="language-go=" data-lang="go=">return archive.CopyTo(preArchive, srcInfo, dstPath)
</code></pre><p>这一过程虽然调用的是docker engine的pkg代码，但完全由cli执行, 主要就是将archive解压到dstPath。</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/pkg/archive/copy.go#L402">https://github.com/moby/moby/blob/v20.10.6/pkg/archive/copy.go#L402</a></p>
<h3 id="32-copytocontainer">3.2 copyToContainer</h3>
<p>如果<code>dstPath</code>是一个软链接， 则将目的路径更新为软链接指向的地址</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L200-L219">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L200-L219</a></p>
<pre><code class="language-go=" data-lang="go=">dstStat, err := client.ContainerStatPath(ctx, copyConfig.container, dstPath)

// If the destination is a symbolic link, we should evaluate it.
if err == nil &amp;&amp; dstStat.Mode&amp;os.ModeSymlink != 0 {
    linkTarget := dstStat.LinkTarget
    if !system.IsAbs(linkTarget) {
        // Join with the parent directory.
        dstParent, _ := archive.SplitPathDirEntry(dstPath)
        linkTarget = filepath.Join(dstParent, linkTarget)
    }

    dstInfo.Path = linkTarget
...
}
</code></pre><p>如果<code>srcPath</code>是<code>-</code>, 则目的路径必须是目录(根据帮助文档，设计上就是这样从stdin解压到目录，但不清楚为什么这么设计)</p>
<p><a href="https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L236-L242">https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L236-L242</a></p>
<pre><code class="language-go=" data-lang="go=">if srcPath == &quot;-&quot; {
    content = os.Stdin
    resolvedDstPath = dstInfo.Path
    if !dstInfo.IsDir {
        return errors.Errorf(&quot;destination \&quot;%s:%s\&quot; must be a directory&quot;, copyConfig.container, dstPath)
    }
}
</code></pre><p>将srcPath打包（如果设置了followLink选项，srcPath会更新为目的地址）</p>
<pre><code class="language-go=" data-lang="go=">// Prepare source copy info.
srcInfo, err := archive.CopyInfoSourcePath(srcPath, copyConfig.followLink)
if err != nil {
    return err
}

srcArchive, err := archive.TarResource(srcInfo)
if err != nil {
    return err
}
defer srcArchive.Close()
dstDir, preparedArchive, err := archive.PrepareArchiveCopy(srcArchive, srcInfo, dstInfo)
if err != nil {
    return err
}
defer preparedArchive.Close()

resolvedDstPath = dstDir
content = preparedArchive
</code></pre><p>最后复制到容器，实际复制的操作是由<a href="https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L33-L59">CopyToContainer</a>函数通过调用api实现的。</p>
<pre><code class="language-go=" data-lang="go=">options := types.CopyToContainerOptions{
    AllowOverwriteDirWithFile: false,
    CopyUIDGID:                copyConfig.copyUIDGID,
}
return client.CopyToContainer(ctx, copyConfig.container, resolvedDstPath, content, options)
</code></pre><h2 id="4-docker-engine-api">4. docker engine api</h2>
<p>在cli中调用的api有3个:</p>
<ul>
<li><a href="https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L18">ContainerStatPath</a></li>
<li><a href="https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L63">CopyFromContainer</a></li>
<li><a href="https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L33-L59">CopyToContainer</a></li>
</ul>
<p>对应的服务端代码分别为：</p>
<ul>
<li><a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/container.go#L36">head <code>/containers/{name:.*}/archive</code> headContainersArchive</a></li>
<li><a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/container.go#L47">get <code>/containers/{name:.*}/archive</code> getContainersArchive</a></li>
<li><a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/container.go#L68">put <code>/containers/{name:.*}/archive</code> putContainersArchive</a></li>
</ul>
<p>下面分析这三个函数的具体流程</p>
<h3 id="41-headcontainersarchivecontainerstatpath">4.1 headContainersArchive(ContainerStatPath)</h3>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L78">https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L78</a></p>
<p>这个api有两个参数，分别是requestUri中传入的name(=ContainerID)和query中传入的path。</p>
<p>path取值可能为srcPath,dstPath,dstPath指向的地址</p>
<p>解析完name, path参数后，由ContainerStatPath函数处理</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L75">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L75</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) ContainerStatPath(name string, path string) (stat *types.ContainerPathStat, err error) {
	container, err := daemon.GetContainer(name)
    ...
	stat, err = daemon.containerStatPath(container, path)
    ...
}
</code></pre><p>先挂载容器的文件系统和各个存储卷, 然后得到path在rootfs下的resolvedPath(// TODO)和absPath(//TODO), 再根据它们得到ContainerPathStat</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L152">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L152</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) containerStatPath(container *container.Container, path string) (stat *types.ContainerPathStat, err error) {
    ...
	if err = daemon.Mount(container); err != nil {
		return nil, err
	}
    ...
	err = daemon.mountVolumes(container)
    ...
	resolvedPath, absPath, err := container.ResolvePath(path)
    ...
	return container.StatPath(resolvedPath, absPath)
}
</code></pre><p>ContainerPathStat是这样得到的</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/container/archive.go#L51">https://github.com/moby/moby/blob/v20.10.6/container/archive.go#L51</a></p>
<pre><code class="language-go=" data-lang="go=">func (container *Container) StatPath(resolvedPath, absPath string) (stat *types.ContainerPathStat, err error) {
    ...
	lstat, err := driver.Lstat(resolvedPath)
	if err != nil {
		return nil, err
	}

	var linkTarget string
	if lstat.Mode()&amp;os.ModeSymlink != 0 {
		// Fully evaluate the symlink in the scope of the container rootfs.
		hostPath, err := container.GetResourcePath(absPath)
		if err != nil {
			return nil, err
		}

		linkTarget, err = driver.Rel(driver.Path(), hostPath)
		if err != nil {
			return nil, err
		}

		// Make it an absolute path.
		linkTarget = driver.Join(string(driver.Separator()), linkTarget)
	}

	return &amp;types.ContainerPathStat{
		Name:       driver.Base(absPath),
		Size:       lstat.Size(),
		Mode:       lstat.Mode(),
		Mtime:      lstat.ModTime(),
		LinkTarget: linkTarget,
	}, nil
}
</code></pre><p>最后,将ContainerPathStat返回到header头中
<a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L64">https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L64</a></p>
<pre><code class="language-go=" data-lang="go=">func setContainerPathStatHeader(stat *types.ContainerPathStat, header http.Header) error {
	statJSON, err := json.Marshal(stat)
	if err != nil {
		return err
	}

	header.Set(
		&quot;X-Docker-Container-Path-Stat&quot;,
		base64.StdEncoding.EncodeToString(statJSON),
	)

	return nil
}
</code></pre><h3 id="42-getcontainersarchivecopyfromcontainer">4.2 getContainersArchive(CopyFromContainer)</h3>
<p>这个api有两个参数，分别是requestUri中传入的name(=ContainerID)和query中传入的path(=srcPath)。</p>
<p>打包完后将数据压缩并返回在body中。</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L115">https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L115</a></p>
<pre><code class="language-go=" data-lang="go=">func (s *containerRouter) getContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error {
	v, err := httputils.ArchiveFormValues(r, vars)
	if err != nil {
		return err
	}

	tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)
	if err != nil {
		return err
	}
	defer tarArchive.Close()

	if err := setContainerPathStatHeader(stat, w.Header()); err != nil {
		return err
	}

	w.Header().Set(&quot;Content-Type&quot;, &quot;application/x-tar&quot;)
	return writeCompressedResponse(w, r, tarArchive)
}
</code></pre><p>调用<code>daemon.containerArchivePath</code>函数打包
<a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L100">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L100</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) ContainerArchivePath(name string, path string) (content io.ReadCloser, stat *types.ContainerPathStat, err error) {
    ctr, err := daemon.GetContainer(name)
    ...
    content, stat, err = daemon.containerArchivePath(ctr, path)
    ...
</code></pre><p><code>containerArchivePath</code>函数会创建一个关于path的归档文件，并返回一个<code>ContainerPathStat</code></p>
<p>其中获取ContainerPathStat的过程与headContainersArchive几乎一致
<a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L182-L218">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L182-L218</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) containerArchivePath(container *container.Container, path string) (content io.ReadCloser, stat *types.ContainerPathStat, err error) {
    ...
    if err = daemon.Mount(container); err != nil {
        return nil, nil, err
    }
    ...
    if err = daemon.mountVolumes(container); err != nil {
        return nil, nil, err
    }

    // Normalize path before sending to rootfs
    path = container.BaseFS.FromSlash(path)

    resolvedPath, absPath, err := container.ResolvePath(path)
    ...
    stat, err = container.StatPath(resolvedPath, absPath)
    ...
}
</code></pre><p>关键在于打包的过程:</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L231-L263">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L231-L263</a></p>
<pre><code class="language-go=" data-lang="go=">driver := container.BaseFS
...
opts := archive.TarResourceRebaseOpts(sourceBase, driver.Base(absPath))

data, err := archivePath(driver, sourceDir, opts, container.BaseFS.Path())
...
content = ioutils.NewReadCloserWrapper(data, func() error {
    err := data.Close()
    container.DetachAndUnmount(daemon.LogVolumeEvent)
    daemon.Unmount(container)
    container.Unlock()
    return err
})

</code></pre><p>如果driver(container.BaseFS)有实现ArchivePath函数，则优先使用该函数。</p>
<blockquote>
<p>目前localfs均未实现该函数，仅发现remotefs(lcowfs)有此实现
<a href="https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L83">https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L83</a></p>
</blockquote>
<p>否则，使用<code>chrootarchive.Tar</code>打包</p>
<pre><code class="language-go=" data-lang="go=">func archivePath(i interface{}, src string, opts *archive.TarOptions, root string) (io.ReadCloser, error) {
	if ap, ok := i.(archiver); ok {
		return ap.ArchivePath(src, opts)
	}
	return chrootarchive.Tar(src, opts, root)
}
</code></pre><h4 id="421-chrootarchivetar">4.2.1 chrootarchive.Tar</h4>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive.go#L101">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive.go#L101</a></p>
<pre><code class="language-go=" data-lang="go=">func Tar(srcPath string, options *archive.TarOptions, root string) (io.ReadCloser, error) {
	if options == nil {
		options = &amp;archive.TarOptions{}
	}
	return invokePack(srcPath, options, root)
}
</code></pre><p>调用<code>docker-tar</code>命令打包
<a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L178">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L178</a></p>
<pre><code class="language-go=" data-lang="go=">func invokePack(srcPath string, options *archive.TarOptions, root string) (io.ReadCloser, error) {
    if root == &quot;&quot; {
        return nil, errors.New(&quot;root path must not be empty&quot;)
    }

    ...

    cmd := reexec.Command(&quot;docker-tar&quot;, relSrc, root)
</code></pre><p>docker-tar的实现对应tar函数
<a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/init_unix.go#L17">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/init_unix.go#L17</a></p>
<pre><code class="language-go=" data-lang="go=">reexec.Register(&quot;docker-tar&quot;, tar)
</code></pre><p>具体实现调用<code>archive.TarWithOptions</code>(关于archive模块的源码分析，暂不在本文展开)， 但在此之前先进行了chroot</p>
<pre><code class="language-go=" data-lang="go=">func tar() {
    ...
    if err := realChroot(root); err != nil {
        fatal(err)
    }
    ...	
    rdr, err := archive.TarWithOptions(src, &amp;options)
    if err != nil {
        fatal(err)
    }
    defer rdr.Close()

    if _, err := io.Copy(os.Stdout, rdr); err != nil {
        fatal(err)
    }

    os.Exit(0)
}
</code></pre><h4 id="422-lcowfs">4.2.2 lcowfs</h4>
<p>lcowfs通过执行<code>remotefs archivepath path</code>命令打包</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L83">https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L83</a></p>
<pre><code class="language-go=" data-lang="go=">if err := l.runRemoteFSProcess(tarBuf, w, remotefs.ArchivePathCmd, src); err != nil {
...
</code></pre><p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L127-L129">https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L127-L129</a></p>
<pre><code class="language-go=" data-lang="go=">func (l *lcowfs) runRemoteFSProcess(stdin io.Reader, stdout io.Writer, args ...string) error {
    ...
    cmd := fmt.Sprintf(&quot;%s %s&quot;, remotefs.RemotefsCmd, strings.Join(args, &quot; &quot;))
    stderr := &amp;bytes.Buffer{}
    if err := l.currentSVM.runProcess(cmd, stdin, stdout, stderr); err != nil {
        return err
    }
    ...
}
</code></pre><p><code>remotefs</code>是一个大命令,<code>archivepath</code>是其中一个子命令。<code>archivePath</code>对应的实现为</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/vendor/github.com/Microsoft/opengcs/service/gcsutils/remotefs/remotefs.go#L48">https://github.com/moby/moby/blob/v20.10.6/vendor/github.com/Microsoft/opengcs/service/gcsutils/remotefs/remotefs.go#L48</a></p>
<pre><code class="language-go=" data-lang="go=">// Commands provide a string -&gt; remotefs function mapping.
// This is useful for commandline programs that will receive a string
// as the function to execute.
var Commands = map[string]Func{
    ...
	ArchivePathCmd:    ArchivePath,
}
</code></pre><p>archivepath具体实现如下，打包函数实际为<a href="https://github.com/moby/moby/blob/v20.10.6/pkg/archive/archive.go#L724">archive.TarWithOptions</a>, 关于archive模块的源码分析，暂不在本文展开。</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/vendor/github.com/Microsoft/opengcs/service/gcsutils/remotefs/remotefs.go#L559">https://github.com/moby/moby/blob/v20.10.6/vendor/github.com/Microsoft/opengcs/service/gcsutils/remotefs/remotefs.go#L559</a></p>
<pre><code class="language-go=" data-lang="go=">// ArchivePath archives the given directory and writes it to out.
// Args:
// - in = size of json | json of archive.TarOptions
// - args[0] = source directory name
// Out:
// - out = tar file of the archive
func ArchivePath(in io.Reader, out io.Writer, args []string) error {
	if len(args) &lt; 1 {
		return ErrInvalid
	}

	opts, err := ReadTarOptions(in)
	if err != nil {
		return err
	}

	r, err := archive.TarWithOptions(args[0], opts)
	if err != nil {
		return err
	}

	if _, err := io.Copy(out, r); err != nil {
		return err
	}
	return nil
}

</code></pre><h3 id="43-putcontainersarchivecopytocontainer">4.3 putContainersArchive(CopyToContainer)</h3>
<p><code>putContainersArchive</code>有4个由客户端传入的参数，分别是requestUri中传入的name(=ContainerID),query中传入的path(=dstPath), noOverwriteDirNonDir(=true), copyUIDGID(=true)
<a href="https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L33-L59">https://github.com/moby/moby/blob/v20.10.6/client/container_copy.go#L33-L59</a></p>
<pre><code class="language-go=" data-lang="go=">query.Set(&quot;path&quot;, filepath.ToSlash(dstPath)) // Normalize the paths used in the API.
// Do not allow for an existing directory to be overwritten by a non-directory and vice versa.
if !options.AllowOverwriteDirWithFile {
    query.Set(&quot;noOverwriteDirNonDir&quot;, &quot;true&quot;)
}

if options.CopyUIDGID {
    query.Set(&quot;copyUIDGID&quot;, &quot;true&quot;)
}

apiPath := &quot;/containers/&quot; + containerID + &quot;/archive&quot;
</code></pre><p>解析完参数后，由<code>putContainersArchive</code>函数解包
<a href="https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L135">https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go#L135</a></p>
<pre><code class="language-go=" data-lang="go=">func (s *containerRouter) putContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error {
    ...
    return s.backend.ContainerExtractToDir(v.Name, v.Path, copyUIDGID, noOverwriteDirNonDir, r.Body)
}
</code></pre><p><code>containerExtractToDir</code>函数中，一开始仍然是先执行<code>mount</code>rootfs和volume操作
<a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L273-L289">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L273-L289</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) containerExtractToDir(container *container.Container, path string, copyUIDGID, noOverwriteDirNonDir bool, content io.Reader) (err error) {
    container.Lock()
    defer container.Unlock()

    if err = daemon.Mount(container); err != nil {
        return err
    }
    defer daemon.Unmount(container)

    err = daemon.mountVolumes(container)
    defer container.DetachAndUnmount(daemon.LogVolumeEvent)
    if err != nil {
        return err
    }

    // Normalize path before sending to rootfs'
    path = container.BaseFS.FromSlash(path)
    driver := container.BaseFS
</code></pre><p>获取软链接目的路径，判断目的路径是否是目录，如果不是目录，返回报错</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L315-L318">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L315-L318</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) containerExtractToDir(container *container.Container, path string, copyUIDGID, noOverwriteDirNonDir bool, content io.Reader) (err error) {
    ...
    
    resolvedPath, err := container.GetResourcePath(absPath)
    if err != nil {
        return err
    }

    stat, err := driver.Lstat(resolvedPath)
    if err != nil {
        return err
    }

    if !stat.IsDir() {
        return ErrExtractPointNotDirectory
    }
</code></pre><p>限制目的路径不能是只读的</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L356-L363">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L356-L363</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) containerExtractToDir(container *container.Container, path string, copyUIDGID, noOverwriteDirNonDir bool, content io.Reader) (err error) {
    ...
    toVolume, err := checkIfPathIsInAVolume(container, absPath)
    ...
    if !toVolume &amp;&amp; container.HostConfig.ReadonlyRootfs {
        return ErrRootFSReadOnly
    }
</code></pre><p>调用<code>extractArchive</code>函数解包，如果配置了copyUIDGID，会把文件的uid,gid修改为容器内的主用户，否则保留原文件的uid,gid。
<a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L365-L379">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L365-L379</a></p>
<pre><code class="language-go=" data-lang="go=">func (daemon *Daemon) containerExtractToDir(container *container.Container, path string, copyUIDGID, noOverwriteDirNonDir bool, content io.Reader) (err error) {
    ...
    options := daemon.defaultTarCopyOptions(noOverwriteDirNonDir)

    if copyUIDGID {
        var err error
        // tarCopyOptions will appropriately pull in the right uid/gid for the
        // user/group and will set the options.
        options, err = daemon.tarCopyOptions(container, noOverwriteDirNonDir)
        if err != nil {
            return err
        }
    }

    if err := extractArchive(driver, content, resolvedPath, options, container.BaseFS.Path()); err != nil {
        return err
    }
</code></pre><p>如果driver(container.BaseFS)有ExtractArchive方法，则使用该方法(目前只有lcowfs实现了该方法)。否则调用<code>chrootarchive.UntarWithRoot</code></p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L34">https://github.com/moby/moby/blob/v20.10.6/daemon/archive.go#L34</a></p>
<pre><code class="language-go=" data-lang="go=">func extractArchive(i interface{}, src io.Reader, dst string, opts *archive.TarOptions, root string) error {
    if ea, ok := i.(extractor); ok {
        return ea.ExtractArchive(src, dst, opts)
    }

    return chrootarchive.UntarWithRoot(src, dst, opts, root)
}
</code></pre><h4 id="431-chrootarchiveuntarwithroot">4.3.1 chrootarchive.UntarWithRoot</h4>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive.go#L54">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive.go#L54</a></p>
<pre><code class="language-go=" data-lang="go=">func UntarWithRoot(tarArchive io.Reader, dest string, options *archive.TarOptions, root string) error {
	return untarHandler(tarArchive, dest, options, true, root)
}
</code></pre><p>如果容器内不存在目的目录，就创建并chown，然后调用<code>invokeUnpack</code>函数。
<a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive.go#L66">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive.go#L66</a></p>
<pre><code class="language-go=" data-lang="go=">func untarHandler(tarArchive io.Reader, dest string, options *archive.TarOptions, decompress bool, root string) error {
    ...
    if _, err := os.Stat(dest); os.IsNotExist(err) {
        if err := idtools.MkdirAllAndChownNew(dest, 0755, rootIDs); err != nil {
            return err
        }
    }
    ...
    return invokeUnpack(r, dest, options, root)
    }
</code></pre><p>调用docker-untar命令解包</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L61">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L61</a></p>
<pre><code class="language-go=" data-lang="go=">func invokeUnpack(decompressedArchive io.Reader, dest string, options *archive.TarOptions, root string) error {
    ...
	cmd := reexec.Command(&quot;docker-untar&quot;, dest, root)
	cmd.Stdin = decompressedArchive
    ...
	if err := cmd.Start(); err != nil {
		w.Close()
		return fmt.Errorf(&quot;Untar error on re-exec cmd: %v&quot;, err)
	}
    ...
}
</code></pre><p>docker-untar实现对应chrootarchive.untar函数，先chroot,再调用archive.Unpack解包。 关于archive模块的源码分析，暂不在本文展开。</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L25">https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L25</a></p>
<pre><code class="language-go=" data-lang="go=">func untar() {
	...
	if err := chroot(root); err != nil {
		fatal(err)
	}

	if err := archive.Unpack(os.Stdin, dst, &amp;options); err != nil {
		fatal(err)
	}
	...
}
</code></pre><h4 id="432-lcowfs">4.3.2 lcowfs</h4>
<p>lcowfs中调用<code>extractarchive</code>实现解包</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L77">https://github.com/moby/moby/blob/v20.10.6/daemon/graphdriver/lcow/remotefs.go#L77</a></p>
<pre><code class="language-go=" data-lang="go=">func (l *lcowfs) ExtractArchive(src io.Reader, dst string, opts *archive.TarOptions) error {
    ...
    if err := l.runRemoteFSProcess(input, nil, remotefs.ExtractArchiveCmd, dst); err != nil {
}
</code></pre><p><code>extractarchive</code>命令对应<code>ExtractArchive</code>函数</p>
<p><a href="https://github.com/moby/moby/blob/v20.10.6/vendor/github.com/Microsoft/opengcs/service/gcsutils/remotefs/remotefs.go#L47">https://github.com/moby/moby/blob/v20.10.6/vendor/github.com/Microsoft/opengcs/service/gcsutils/remotefs/remotefs.go#L47</a></p>
<pre><code class="language-go=" data-lang="go=">var Commands = map[string]Func{
    ...
    ExtractArchiveCmd: ExtractArchive,
</code></pre><p><code>ExtractArchive</code>函数中调用<code>archive.Untar</code></p>
<pre><code class="language-go=" data-lang="go=">func ExtractArchive(in io.Reader, out io.Writer, args []string) error {
    ...
    if err := archive.Untar(in, args[0], opts); err != nil {
}
</code></pre>
            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            
            <span></span>
            <span> <a href="/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/st0n3">st0n3</a></span>
            <span>Based on <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      
      jax: ["input/TeX", "output/CommonHTML"],
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": { fonts: ["TeX"] },
      displayAlign: "left"
    });
  </script>

<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_CHTML"></script>


</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.4c3fb12a087ceed4a52cb5d57068a9795c7069617a01ca70f788052ad66e1791779e6c72686e1dc0ca13dc03b0203204b6566bb0dd1ee80de2b7ff4d8fe53db2.js" integrity="sha512-TD&#43;xKgh87tSlLLXVcGipeVxwaWF6Acpw94gFKtZuF5F3nmxyaG4dwMoT3AOwIDIEtlZrsN0e6A3it/9Nj&#43;U9sg=="></script>



    </body>
</html>
